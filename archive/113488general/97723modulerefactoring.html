---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/97723modulerefactoring.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html">module refactoring</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="134359525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134359525" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134359525">Mario Carneiro (Sep 21 2018 at 06:31)</a>:</h4>
<p>I'm a bit late for my birthday deadline, but I have enough of the refactoring done that I'm ready to get feedback on it. See <a href="https://github.com/leanprover/mathlib/compare/master...leanprover-community:module" target="_blank" title="https://github.com/leanprover/mathlib/compare/master...leanprover-community:module">leanprover-community/module</a>. Remarks:</p>
<ul>
<li>The main contributions here are the complete bundling of <code>linear_map</code> and <code>submodule</code>. In fact both of these were already present in mathlib, but making them primary makes everything go so much smoother.</li>
<li>The structure of <code>submodule</code> and its category-theory-like interactions with <code>linear_map</code> are emphasized heavily. In particular, <code>submodule</code> is a complete lattice, <code>map</code> and <code>comap</code> are galois connections, there are tons of theorems about the map of an inf or the comap of fst and so on.</li>
<li>The amount of duality here is staggering. I guess someone who is category theory minded will tell me that Mod is its own opposite category or some such thing, but it really shows in the equational theory. Even stuff like <code>inl</code> being dual to <code>fst</code> causes some nice properties, and some stuff plays even nicer than on Set like <code>prod p q ⊔ prod p' q' = prod (p ⊔ p') (q ⊔ q')</code>.</li>
<li>Injectivity and surjectivity of linear maps is expressed through <code>ker</code> and <code>range</code> (should I call it <code>im</code>?), and even <code>linear_independent</code> and <code>basis</code> can be expressed using properties of the <code>lc.total</code> function.</li>
</ul>
<p>On the whole, I'm feeling really good about the results, and the proofs are much cleaner.</p>

<a name="134359600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134359600" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134359600">Johan Commelin (Sep 21 2018 at 06:33)</a>:</h4>
<p>This is really cool! And yes, please call use <code>im</code> <span class="emoji emoji-1f606" title="lol">:lol:</span></p>

<a name="134359655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134359655" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134359655">Mario Carneiro (Sep 21 2018 at 06:34)</a>:</h4>
<p>The name <code>range</code> is of course borrowed from terminology on <code>set</code>. I would rather not confuse with <code>image</code> which is <code>map</code> here</p>

<a name="134359741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134359741" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134359741">Mario Carneiro (Sep 21 2018 at 06:36)</a>:</h4>
<p><code>map f p</code> is the submodule <code>f[p]</code> where <code>p</code> is a submodule, and <code>range f = map f \top = f[univ]</code> which was previously called <code>im</code> on linear maps</p>

<a name="134359814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134359814" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134359814">Mario Carneiro (Sep 21 2018 at 06:38)</a>:</h4>
<p>What is the common name for the coproduct pairing function? I called it <a href="https://github.com/leanprover-community/mathlib/blob/45f72059515083a0ae74567432dfc7853f791235/linear_algebra/basic.lean#L113-L114" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/45f72059515083a0ae74567432dfc7853f791235/linear_algebra/basic.lean#L113-L114"><code>copair</code></a> since <code>pair</code> is used for the product pairing operation</p>

<a name="134360028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134360028" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134360028">Kenny Lau (Sep 21 2018 at 06:42)</a>:</h4>
<p>but it's the same...</p>

<a name="134360049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134360049" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134360049">Johan Commelin (Sep 21 2018 at 06:43)</a>:</h4>
<p>I think <span class="user-mention" data-user-id="110087">@Scott Morrison</span>  and <span class="user-mention" data-user-id="110032">@Reid Barton</span> have the most experience with such decisions</p>

<a name="134363426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134363426" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134363426">Johannes Hölzl (Sep 21 2018 at 08:03)</a>:</h4>
<p>this is really nice!</p>

<a name="134364133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134364133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134364133">Patrick Massot (Sep 21 2018 at 08:21)</a>:</h4>
<p>Mario, could you explain how all this solves the trouble we had with instance loops and multiple possible base rings?</p>

<a name="134370222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134370222" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134370222">Kevin Buzzard (Sep 21 2018 at 10:51)</a>:</h4>
<p>I got caught up with something else this morning but later on today, when I have Lean time, I will just merge the patch and see how Hilbert basis goes with it. Does it compile sorry-free?</p>

<a name="134370418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134370418" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134370418">Reid Barton (Sep 21 2018 at 10:56)</a>:</h4>
<p><code>copair</code>/<code>pair</code> seems as good as anything else.<br>
Normally we just write an arrow <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>⊕</mo><mi>B</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A \oplus B \to C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord mathit">A</span><span class="mbin">⊕</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span> and let the reader do the boring work of figuring out what map we are actually talking about.</p>

<a name="134370446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134370446" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134370446">Kenny Lau (Sep 21 2018 at 10:57)</a>:</h4>
<p>how about product or coproduct as a bifunctor?</p>

<a name="134388143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134388143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134388143">Mario Carneiro (Sep 21 2018 at 16:21)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span>  This doesn't address that issue, although it prepares the way a bit. I anticipate that this should be a comparatively simple change, but I didn't want the two refactorings to interact so I'm going to start on it as soon as this is done.</p>

<a name="134388211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134388211" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134388211">Mario Carneiro (Sep 21 2018 at 16:22)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> It's not yet building. I finished the main linear algebra files, but I haven't finished up the cleanup of uses outside linear algebra. (There are no sorries, it just breaks.)</p>

<a name="134388442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134388442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134388442">Johannes Hölzl (Sep 21 2018 at 16:26)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> by the way: the introduction of <code>coe</code> rewrites broke some proofs in <code>set_theory/ordinal</code> and <code>cofinality</code>. I fixed this, but you might want to do a different fix</p>

<a name="134389089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134389089" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134389089">Mario Carneiro (Sep 21 2018 at 16:39)</a>:</h4>
<p>yeah, apologies for pushing stuff last night that broke things; my computer was running very slow and I was lacking feedback on whether my fixes worked</p>

<a name="134389417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134389417" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134389417">Johannes Hölzl (Sep 21 2018 at 16:45)</a>:</h4>
<p>No problem. But I'm not sure if these are the intended changes. I didn't look too deep how these new simp rules are supposed to work.</p>

<a name="134389493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134389493" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134389493">Mario Carneiro (Sep 21 2018 at 16:46)</a>:</h4>
<p>The idea is that <code>coe</code> will infer transitive instances, but since simp rules are only written on single coercions they won't fire on these composite instances. So we unfold them to multiple coe arrows first</p>

<a name="134389521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134389521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134389521">Mario Carneiro (Sep 21 2018 at 16:47)</a>:</h4>
<p>I don't think I realized this until lately, but lean will also infer transitive instances for <code>coe</code> + <code>coe_fn</code> and <code>coe</code> + <code>coe_sort</code>, and since the instances are different there are more simp lemmas associated to these</p>

<a name="134389602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134389602" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134389602">Mario Carneiro (Sep 21 2018 at 16:49)</a>:</h4>
<p>I think the breakage is because some simp LHSs were written with composite instances, which now break because simp normal form doesn't have any composite instances. The fix is to make sure simp LHSs have multiple coercion in these cases</p>

<a name="134390066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134390066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134390066">Patrick Massot (Sep 21 2018 at 16:58)</a>:</h4>
<p>Ok, I'm less confused then (about modules, I'm still 100% confused about topological groups). I couldn't understand how those changes could help with the lost ring issue</p>

<a name="134390560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134390560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134390560">Chris Hughes (Sep 21 2018 at 17:05)</a>:</h4>
<p>Is it worth bundling ideals and subgroups as well?</p>

<a name="134391051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134391051" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134391051">Johannes Hölzl (Sep 21 2018 at 17:12)</a>:</h4>
<p>I think we should replace ideals by submodules, so yes we want to have them bundled. I'm not sure about subgroups. We surely want a bundled version, but maybe still an unbundled one too</p>

<a name="134392526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134392526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134392526">Kevin Buzzard (Sep 21 2018 at 17:36)</a>:</h4>
<p>Johannes -- the idea about ideals was that submodule R M makes sense for varying R and M, but ideal R = submodule R R so only one input is needed.</p>

<a name="134392890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134392890" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134392890">Chris Hughes (Sep 21 2018 at 17:43)</a>:</h4>
<p>But I think you want lattice and semiring on ideals as well, so you need bundles for that.</p>

<a name="134396604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134396604" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134396604">Mario Carneiro (Sep 21 2018 at 18:44)</a>:</h4>
<p>I am of the opinion that <code>subgroup</code> and other such algebraic classes should also be bundled; almost all of the lattice structure theorems done here hold for anything that fits the structure of a universal algebra. <code>ideal R := submodule R R</code> can be defined as reducible so that all the theorems about submodules still apply.</p>

<a name="134396657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134396657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134396657">Mario Carneiro (Sep 21 2018 at 18:45)</a>:</h4>
<p>What are some examples where you think not having <code>is_sub*</code> will cause problems?</p>

<a name="134403252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134403252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134403252">Johan Commelin (Sep 21 2018 at 20:38)</a>:</h4>
<blockquote>
<p><code>ideal R := submodule R R</code> can be defined as reducible so that all the theorems about submodules still apply.</p>
</blockquote>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  I thought you said in Orsay that you couldn't think of any reason why a definition should be reducible. Has that changed? If so, can you explain?</p>

<a name="134412301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134412301" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134412301">Kevin Buzzard (Sep 21 2018 at 23:40)</a>:</h4>
<p>If I open polynomial.lean (which I need for Hilbert basis) I just get 1000 errors. I think I would be happier to give feedback by trying to write Lean code and then getting stuck or finding things easier than before and reporting back. I find it hard to theorise about changes that I may not fully understand.</p>

<a name="134414013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134414013" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134414013">Mario Carneiro (Sep 22 2018 at 00:26)</a>:</h4>
<p>Yeah, sorry about that. Mostly you can just open and read <code>algebra.module</code> and <code>linear_algebra.basic</code> for now. I'll let you know when it's really done (by pushing it to <code>master</code>, unless someone objects)</p>

<a name="134414027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134414027" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134414027">Mario Carneiro (Sep 22 2018 at 00:27)</a>:</h4>
<p>I just didn't want to get too far afield with a change this sweeping without some input</p>

<a name="134414217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134414217" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134414217">Mario Carneiro (Sep 22 2018 at 00:33)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> That's a fair point. There are three options here: (1) nonreducible def (2) reducible def (3) notation. In Orsay I argued that either (1) or (3) suffices in most cases where you think you want (2).</p>
<p>In this case, I don't think it matters too much, although (1) will require copying some instances like the <code>complete_lattice</code> instance, and possibly some theorems. Doing this would make the cleanest separation, allowing us to present a solid API for ideals that doesn't talk about modules half the time. (2) and (3) will entail some amount of API leakage here, moreso with (3) since it is <code>submodule R R</code> that will appear in all your statements. </p>
<p>The downsides of reducible defs (inconsistent handling in rw and simp) don't really apply when the def is a type since you don't usually do rewrites on a type, you just force it to be defeq to something else.</p>

<a name="134781266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134781266" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134781266">Mario Carneiro (Sep 27 2018 at 23:46)</a>:</h4>
<p>This is a change I haven't implemented, but I'm considering it and want to get some feedback. Maybe a basis should be an injective function from some type into the module, i.e. the "basis" is really the range of this function, and the function gets to pick its indexing type. The reason is because we often tend to use a basis as an index for a sum, or as the domain of the free vector space to which to express isomorphism, or as the set whose cardinality is the dimension of the space - all of these roles are better accommodated by having an algebra of indexing types (which we already have courtesy of DTT) where measuring cardinality and indexing is more natural. (Also, it allows a basis to carry computational content, which isn't super important but indicates that this might be moving in the right direction.)</p>

<a name="134781707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134781707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134781707">Reid Barton (Sep 27 2018 at 23:59)</a>:</h4>
<p>From a mathematical perspective this change is very natural. We often write things like "let {b_1, ..., b_n} be a basis of V" but usually (whether we are aware of it or not) we really mean we are working with an indexed collection b_i, i.e., a function {1, ..., n} -&gt; V.</p>

<a name="134781777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134781777" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134781777">Reid Barton (Sep 28 2018 at 00:00)</a>:</h4>
<p>It's easy to say things which are false if taken literally in the "set style". For example: {x, y} is a linearly independent set in a vector space if and only if there do not exist nonzero a, b such that ax + by = 0. Well, not if x = y!</p>

<a name="134781792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134781792" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134781792">Reid Barton (Sep 28 2018 at 00:01)</a>:</h4>
<p>On the other hand there are occasionally times when you genuinely need to work with subsets because you want to use the order structure and/or know that the collection of all possible bases is small, for example when proving that every vector space has a basis</p>

<a name="134781797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134781797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134781797">Mario Carneiro (Sep 28 2018 at 00:01)</a>:</h4>
<p>I think the statement about every vector space has a basis will explicitly use subsets</p>

<a name="134781842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134781842" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134781842">Reid Barton (Sep 28 2018 at 00:02)</a>:</h4>
<p>I think the function approach is not really restrictive then anyways. You just say "a subset such that the inclusion is a basis".</p>

<a name="134781853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134781853" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134781853">Mario Carneiro (Sep 28 2018 at 00:02)</a>:</h4>
<p>i.e. every vector space has a basis where the function is the subtype coercion and the indexing set is a subtype of the vector space</p>

<a name="134781855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134781855" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134781855">Reid Barton (Sep 28 2018 at 00:02)</a>:</h4>
<p>(By the way, injectivity of the function is a consequence of being a basis, not a precondition.)</p>

<a name="134781869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134781869" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134781869">Mario Carneiro (Sep 28 2018 at 00:03)</a>:</h4>
<p>I agree, I think under most circumstances you should be able to prove injectivity, except in trivial cases and in those cases you probably don't want to impose it additionally</p>

<a name="134781913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134781913" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134781913">Mario Carneiro (Sep 28 2018 at 00:04)</a>:</h4>
<p>(bases over the zero ring are weird)</p>

<a name="134781932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134781932" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134781932">Reid Barton (Sep 28 2018 at 00:05)</a>:</h4>
<p>Hmm... yes</p>

<a name="134781956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134781956" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134781956">Mario Carneiro (Sep 28 2018 at 00:05)</a>:</h4>
<p>speaking of which... <code>unit</code> should be a ring</p>

<a name="134781998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134781998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134781998">Mario Carneiro (Sep 28 2018 at 00:06)</a>:</h4>
<p>it would fit nicely with the ring instance for products and Pis</p>

<a name="134782068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134782068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134782068">Reid Barton (Sep 28 2018 at 00:08)</a>:</h4>
<p>The nlab definition of basis is: A basis of a free R-module M (possibly a vector space, see basis of a vector space) is a linear isomorphism <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo separator="true">:</mo><mi>M</mi><mo>→</mo><msub><mo>⊕</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub><mi>R</mi></mrow><annotation encoding="application/x-tex">B\colon M \to \oplus_{i\in I}R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8607em;vertical-align:-0.17737em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mpunct">:</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mrel">→</span><span class="mord"><span class="mbin">⊕</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathit mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17737em;"></span></span></span></span></span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span> to a direct sum of copies of the ring R, regarded as a module over itself.</p>

<a name="134782086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134782086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134782086">Reid Barton (Sep 28 2018 at 00:09)</a>:</h4>
<p>I think this kind of property is more important than "for all i /= j, b_i /= b_j"</p>

<a name="134782104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134782104" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134782104">Reid Barton (Sep 28 2018 at 00:09)</a>:</h4>
<p>... if you find yourself having to make some decision regarding the zero ring</p>

<a name="134782355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134782355" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134782355">Reid Barton (Sep 28 2018 at 00:15)</a>:</h4>
<p>Yes okay, now I see you were saying the same thing regarding definition of bases over the zero ring</p>

<a name="134783593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134783593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134783593">Mario Carneiro (Sep 28 2018 at 00:47)</a>:</h4>
<p>so what does this say about linearly independent sets?</p>

<a name="134783641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134783641" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134783641">Mario Carneiro (Sep 28 2018 at 00:48)</a>:</h4>
<p>I guess these should also be indexed</p>

<a name="134785061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134785061" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134785061">Johan Commelin (Sep 28 2018 at 01:31)</a>:</h4>
<blockquote>
<p>speaking of which... <code>unit</code> should be a ring</p>
</blockquote>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="o">:</span> <span class="n">comm_ring</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">tidy</span>
</pre></div>

<a name="134785183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134785183" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134785183">Johan Commelin (Sep 28 2018 at 01:34)</a>:</h4>
<p>Good luck golfing that...</p>

<a name="134785315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134785315" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134785315">Johan Commelin (Sep 28 2018 at 01:38)</a>:</h4>
<p>I'm pretty sure that <code>tidy</code> will also prove for you that it is the terminal object in <code>Ring</code> and <code>CRing</code></p>

<a name="134807675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/134807675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#134807675">Kevin Buzzard (Sep 28 2018 at 07:48)</a>:</h4>
<p>I must confess I was surprised when I first saw that in Lean a basis was a subset. Mulling over this, I realised that it was because I was used to teaching students about bases of <em>finite-dimensional</em> vector spaces -- and this is not a conversation about bases, this is also a conversation about the concepts of linear independence and spanning -- and in these cases it seems more convenient when developing the theory to be considering lists of elements rather than subsets (so order matters, and repeats are OK). For a dumb example, consider the zero ring <code>R</code>. Then <code>R^3=R</code> and hence I want <code>[0,0,0]</code> to be a basis for <code>R</code>, which it is. This is the only case where bases can have repeated elements and also the only case where bases can have different cardinalities. A less pathological example is that if a basis of a fdvs is a list then a linear map is a matrix, rather than some weird concept of a matrix where we don't mind permuting the rows and columns which we'd get for sets. My students did a bunch of stuff involving this over the summer -- linear maps = matrices and so on -- and although their code is probably not mathlib-ready it would not surprise me if they had worked out some good useful and correct statements.</p>
<p>The only situation I know where subsets are better than maps from a type is in the Zorn proof that every vector space has a basis. But this result is in some sense a bit of a novelty, my impression is that working mathematicians very rarely think about infinite-dimensional vector spaces with no extra structure at all, and if there is extra structure (a topology or whatever) then the abstract notion of a basis is usually not what we want anyway (c.f. "basis" of a Hilbert space = lin ind subset with dense span).</p>

<a name="135187101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135187101" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135187101">Johan Commelin (Oct 04 2018 at 13:50)</a>:</h4>
<p>If we are refactoring modules... would it make sense to rename <code>span</code> to <code>generate</code>? It would be more in line with all the other forms of <code>generate</code>...</p>

<a name="135193289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135193289" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135193289">Mario Carneiro (Oct 04 2018 at 14:41)</a>:</h4>
<p>I was actually thinking about going the other way :)</p>

<a name="135193368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135193368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135193368">Mario Carneiro (Oct 04 2018 at 14:42)</a>:</h4>
<p>specifically as relates to other "closure" operations e.g. subgroup closure and normal closure</p>

<a name="135193424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135193424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135193424">Mario Carneiro (Oct 04 2018 at 14:43)</a>:</h4>
<p>For set-of-set operations like <code>filter</code> and <code>topology</code> I prefer <code>generate</code>, but maybe that's not principled enough</p>

<a name="135193452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135193452" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135193452">Mario Carneiro (Oct 04 2018 at 14:43)</a>:</h4>
<p>I agree some uniformity of naming would be a good thing</p>

<a name="135193845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135193845" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135193845">Johan Commelin (Oct 04 2018 at 14:49)</a>:</h4>
<p>Ok, I don't really care which one gets chosen <span class="emoji emoji-1f606" title="lol">:lol:</span></p>

<a name="135377864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135377864" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135377864">Mario Carneiro (Oct 08 2018 at 03:45)</a>:</h4>
<p>So I've got to working on <code>ideal</code> now, and I have come to realize that ideal theory is not simply a specialization of submodule theory. It's obvious in hindsight, but as a category the homs are different - a ring hom is not a linear map, and a linear map is not a ring hom</p>

<a name="135377912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135377912" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135377912">Mario Carneiro (Oct 08 2018 at 03:46)</a>:</h4>
<p>So this means that things like <code>map</code> and <code>comap</code> don't work the same way on rings</p>

<a name="135377924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135377924" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135377924">Mario Carneiro (Oct 08 2018 at 03:46)</a>:</h4>
<p>In particular I don't even think there is a notion of <code>ideal.map</code> unless you assume the map is surjective</p>

<a name="135378146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135378146" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135378146">Mario Carneiro (Oct 08 2018 at 03:53)</a>:</h4>
<p>Is there a way to make sense of a ring-changing hom from (R,M) to (R',M') modules?</p>

<a name="135378473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135378473" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135378473">Scott Morrison (Oct 08 2018 at 04:02)</a>:</h4>
<p>Perhaps there's a notion of a map (R,M) to (R',M') as a linear map f : M to M', and a ring hom g : R' to R (note this is backwards), satisfying g(r') m = r' f(m).</p>

<a name="135378476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135378476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135378476">Scott Morrison (Oct 08 2018 at 04:03)</a>:</h4>
<p>I'm not sure it's particularly useful.</p>

<a name="135378488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135378488" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135378488">Mario Carneiro (Oct 08 2018 at 04:03)</a>:</h4>
<p>yeah I was thinking the ring part might end up contravariant</p>

<a name="135378490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135378490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135378490">Mario Carneiro (Oct 08 2018 at 04:03)</a>:</h4>
<p>so I guess this does not generalize ring homs as maps (R,R) -&gt; (R', R')</p>

<a name="135378925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135378925" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135378925">Johan Commelin (Oct 08 2018 at 04:17)</a>:</h4>
<blockquote>
<p>Is there a way to make sense of a ring-changing hom from (R,M) to (R',M') modules?</p>
</blockquote>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> What exactly do you mean with this question?</p>

<a name="135378968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135378968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135378968">Mario Carneiro (Oct 08 2018 at 04:18)</a>:</h4>
<p>I wonder if there is a common generalization of ring homs, (R,R) -&gt; (R', R') and linear maps (R,M) -&gt; (R, M')</p>

<a name="135378976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135378976" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135378976">Mario Carneiro (Oct 08 2018 at 04:19)</a>:</h4>
<p>is there a category theory operation for taking a "total space" over the categories R-Mod where R is an object in the category Ring?</p>

<a name="135378980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135378980" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135378980">Johan Commelin (Oct 08 2018 at 04:19)</a>:</h4>
<p>Sure.</p>

<a name="135378985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135378985" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135378985">Johan Commelin (Oct 08 2018 at 04:19)</a>:</h4>
<p>That's a fibered category</p>

<a name="135378994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135378994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135378994">Johan Commelin (Oct 08 2018 at 04:19)</a>:</h4>
<p>And this one is one of the first examples</p>

<a name="135379047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379047" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379047">Johan Commelin (Oct 08 2018 at 04:21)</a>:</h4>
<p>A map <code>(R,M) → (R',M')</code> is a pair <code>R → R'</code> + <code>R' \otimes_R M → M'</code>. (Or do I need commutativity for that tensor product?)</p>

<a name="135379051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379051" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379051">Johan Commelin (Oct 08 2018 at 04:21)</a>:</h4>
<p>Yes, I do.</p>

<a name="135379052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379052" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379052">Johan Commelin (Oct 08 2018 at 04:21)</a>:</h4>
<p>This doesn't work for arbitrary <code>R → R'</code>.</p>

<a name="135379094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379094">Johan Commelin (Oct 08 2018 at 04:22)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Were you planning on doing left- right- and two-sided-ideals?</p>

<a name="135379097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379097" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379097">Johan Commelin (Oct 08 2018 at 04:22)</a>:</h4>
<p>Or only ideals in comm_rings?</p>

<a name="135379102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379102" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379102">Mario Carneiro (Oct 08 2018 at 04:23)</a>:</h4>
<p>Just comm ring ideals, since that's what's there now</p>

<a name="135379107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379107" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379107">Johan Commelin (Oct 08 2018 at 04:23)</a>:</h4>
<p>Ok, so for comm_ring modules you get this really nice fibered category <code>Mod</code>.</p>

<a name="135379109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379109" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379109">Johan Commelin (Oct 08 2018 at 04:23)</a>:</h4>
<p>Is that what you were looking for?</p>

<a name="135379113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379113" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379113">Johan Commelin (Oct 08 2018 at 04:23)</a>:</h4>
<p>Note that by adjunction you can also just give a map <code>M → M'</code> that is <code>R</code>-linear</p>

<a name="135379128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379128">Mario Carneiro (Oct 08 2018 at 04:24)</a>:</h4>
<blockquote>
<p><code>R' \otimes_R M</code></p>
</blockquote>
<p>what is this</p>

<a name="135379153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379153" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379153">Johan Commelin (Oct 08 2018 at 04:24)</a>:</h4>
<p>Tensor product</p>

<a name="135379154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379154" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379154">Johan Commelin (Oct 08 2018 at 04:24)</a>:</h4>
<p>turning <code>M</code> into an <code>R'</code>-module</p>

<a name="135379155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379155">Mario Carneiro (Oct 08 2018 at 04:24)</a>:</h4>
<p>so R' is viewed as a R-module here?</p>

<a name="135379156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379156" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379156">Johan Commelin (Oct 08 2018 at 04:24)</a>:</h4>
<p>Yes</p>

<a name="135379164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379164" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379164">Mario Carneiro (Oct 08 2018 at 04:25)</a>:</h4>
<p>oh, there's an interesting construction we don't have</p>

<a name="135379166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379166" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379166">Johan Commelin (Oct 08 2018 at 04:25)</a>:</h4>
<p>Which one?</p>

<a name="135379169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379169" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379169">Mario Carneiro (Oct 08 2018 at 04:25)</a>:</h4>
<p>a ring hom <code>R -&gt; R'</code> yields a R-module structure on <code>R'</code></p>

<a name="135379173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379173">Johan Commelin (Oct 08 2018 at 04:25)</a>:</h4>
<p>You mean the forgetful functor?</p>

<a name="135379176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379176" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379176">Johan Commelin (Oct 08 2018 at 04:25)</a>:</h4>
<p>From <code>R'</code>-mod to <code>R</code>-mod?</p>

<a name="135379216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379216">Mario Carneiro (Oct 08 2018 at 04:26)</a>:</h4>
<p>It's not forgetful, right?</p>

<a name="135379218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379218" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379218">Johan Commelin (Oct 08 2018 at 04:26)</a>:</h4>
<p>Not really</p>

<a name="135379219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379219" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379219">Mario Carneiro (Oct 08 2018 at 04:26)</a>:</h4>
<p>The hom could be anything</p>

<a name="135379222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379222" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379222">Johan Commelin (Oct 08 2018 at 04:26)</a>:</h4>
<p>I still think of it as "forgetting"</p>

<a name="135379229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379229">Johan Commelin (Oct 08 2018 at 04:26)</a>:</h4>
<p>We have <code>R</code> is an <code>R</code>-mod</p>

<a name="135379233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379233" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379233">Johan Commelin (Oct 08 2018 at 04:27)</a>:</h4>
<p>So if you chain that to the "forget" instance, you have what you want.</p>

<a name="135379239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379239">Mario Carneiro (Oct 08 2018 at 04:27)</a>:</h4>
<p>I don't follow</p>

<a name="135379242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379242" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379242">Johan Commelin (Oct 08 2018 at 04:27)</a>:</h4>
<p>I tried adding "forget" about 3 months ago, and I ran into trouble.</p>

<a name="135379244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379244">Mario Carneiro (Oct 08 2018 at 04:27)</a>:</h4>
<p>what forget instance?</p>

<a name="135379248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379248" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379248">Johan Commelin (Oct 08 2018 at 04:27)</a>:</h4>
<p>But maybe with the refactor, you can now do it.</p>

<a name="135379249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379249" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379249">Johan Commelin (Oct 08 2018 at 04:27)</a>:</h4>
<p>I mean <code>R'</code> is an <code>R'</code>-mod + every <code>R'</code>-mod is an <code>R</code>-mod.</p>

<a name="135379273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379273" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379273">Johan Commelin (Oct 08 2018 at 04:28)</a>:</h4>
<p>I want your instance to be broken into 2 steps.</p>

<a name="135379301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379301" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379301">Johan Commelin (Oct 08 2018 at 04:28)</a>:</h4>
<blockquote>
<p>what forget instance?</p>
</blockquote>
<p>The "forgetful" functor instance</p>

<a name="135379302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379302" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379302">Mario Carneiro (Oct 08 2018 at 04:28)</a>:</h4>
<blockquote>
<p>every R'-mod is an R-mod</p>
</blockquote>
<p>This one requires an explicit ring hom input</p>

<a name="135379308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379308" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379308">Johan Commelin (Oct 08 2018 at 04:29)</a>:</h4>
<p>Hmmm, it does... unless we turn <code>R'</code> into an algebra</p>

<a name="135379310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379310">Johan Commelin (Oct 08 2018 at 04:29)</a>:</h4>
<p>over <code>R</code></p>

<a name="135379318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379318" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379318">Mario Carneiro (Oct 08 2018 at 04:29)</a>:</h4>
<p>ah, we don't have anything like that yet</p>

<a name="135379369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379369" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379369">Mario Carneiro (Oct 08 2018 at 04:30)</a>:</h4>
<p>I needed assoc algebras around this time in metamath, now I forget why</p>

<a name="135379428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379428">Mario Carneiro (Oct 08 2018 at 04:32)</a>:</h4>
<p>Ah - multivariate polynomials are the free assoc algebra</p>

<a name="135379457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379457">Johan Commelin (Oct 08 2018 at 04:33)</a>:</h4>
<p>The ones we have are also commutative</p>

<a name="135379496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379496" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379496">Johan Commelin (Oct 08 2018 at 04:34)</a>:</h4>
<p>At some point we might want non-commutative polynomials as well</p>

<a name="135379511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379511">Mario Carneiro (Oct 08 2018 at 04:35)</a>:</h4>
<p>I have never touched noncomm polynomials, but I guess it's not so hard with the group ring construction</p>

<a name="135379514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379514" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379514">Mario Carneiro (Oct 08 2018 at 04:35)</a>:</h4>
<p>... + free monoid construction which we already have</p>

<a name="135379515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379515">Johan Commelin (Oct 08 2018 at 04:35)</a>:</h4>
<p>So, could we have <code>f^* M'</code>?</p>

<a name="135379555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379555" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379555">Mario Carneiro (Oct 08 2018 at 04:36)</a>:</h4>
<p>I think so, what does that mean?</p>

<a name="135379556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379556">Johan Commelin (Oct 08 2018 at 04:36)</a>:</h4>
<p>where <code>f</code> is a ring hom <code>R → R'</code> and <code>M'</code> is an <code>R'</code>-mod</p>

<a name="135379559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379559" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379559">Johan Commelin (Oct 08 2018 at 04:36)</a>:</h4>
<p>So <code>f^*</code> is the functor <code>R'-mod → R-mod</code></p>

<a name="135379565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379565" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379565">Mario Carneiro (Oct 08 2018 at 04:37)</a>:</h4>
<p>ah, okay so this is the contravariant thing that scott mentioned</p>

<a name="135379567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379567" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379567">Johan Commelin (Oct 08 2018 at 04:37)</a>:</h4>
<p>Right, and it is adjoint to tensoring.</p>

<a name="135379568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379568" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379568">Johan Commelin (Oct 08 2018 at 04:37)</a>:</h4>
<p>Which is covariant</p>

<a name="135379570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379570" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379570">Johan Commelin (Oct 08 2018 at 04:37)</a>:</h4>
<p>no, that's bullcrap</p>

<a name="135379571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379571">Johan Commelin (Oct 08 2018 at 04:37)</a>:</h4>
<p>I'm brainfarting</p>

<a name="135379609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379609" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379609">Johan Commelin (Oct 08 2018 at 04:38)</a>:</h4>
<p>tensor is adjoint to hom</p>

<a name="135379614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135379614" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135379614">Johan Commelin (Oct 08 2018 at 04:38)</a>:</h4>
<p>Lol. So you get to choose: either you use <code>f^*</code> which is contravariant. Or you use tensor products, and you get something covariant, but "harder to parse".</p>

<a name="135383276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135383276" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135383276">Johan Commelin (Oct 08 2018 at 06:40)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> How would all this abstract nonsense help with:</p>
<blockquote>
<p>So I've got to working on <code>ideal</code> now, and I have come to realize that ideal theory is not simply a specialization of submodule theory. It's obvious in hindsight, but as a category the homs are different - a ring hom is not a linear map, and a linear map is not a ring hom</p>
</blockquote>

<a name="135383285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135383285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135383285">Kenny Lau (Oct 08 2018 at 06:41)</a>:</h4>
<p>And nobody here has pointed out that extensions of ideals exist, c.f. Atiyah-Macdonald P.9</p>

<a name="135383328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135383328" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135383328">Kenny Lau (Oct 08 2018 at 06:42)</a>:</h4>
<blockquote>
<p>In particular I don't even think there is a notion of <code>ideal.map</code> unless you assume the map is surjective</p>
</blockquote>
<p>if f:A-&gt;B is a ring hom and L is an ideal in A then L^e is the ideal generated by f(L)</p>

<a name="135383339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135383339" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135383339">Kenny Lau (Oct 08 2018 at 06:43)</a>:</h4>
<p><a href="/user_uploads/3121/OAIFV_UuuBZXylsyoLFs_sUK/2018-10-08.png" target="_blank" title="2018-10-08.png">2018-10-08.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/OAIFV_UuuBZXylsyoLFs_sUK/2018-10-08.png" target="_blank" title="2018-10-08.png"><img src="/user_uploads/3121/OAIFV_UuuBZXylsyoLFs_sUK/2018-10-08.png"></a></div>

<a name="135383404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135383404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135383404">Mario Carneiro (Oct 08 2018 at 06:45)</a>:</h4>
<p>yeah, okay that's a better idea</p>

<a name="135383408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135383408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135383408">Mario Carneiro (Oct 08 2018 at 06:45)</a>:</h4>
<p>just close the resulting set under ideal operations</p>

<a name="135383456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135383456" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135383456">Johan Commelin (Oct 08 2018 at 06:46)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Do you have some sort of todo list of what remains for this refactor?</p>

<a name="135383458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135383458" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135383458">Mario Carneiro (Oct 08 2018 at 06:46)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> It's just some idle speculation on my part, I don't really have any concrete implementation ideas</p>

<a name="135383464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135383464" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135383464">Mario Carneiro (Oct 08 2018 at 06:47)</a>:</h4>
<p>I'm currently in "tying up loose ends" mode in the refactor, I don't want to introduce new things</p>

<a name="135383467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135383467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135383467">Johan Commelin (Oct 08 2018 at 06:47)</a>:</h4>
<p>Great!</p>

<a name="135383470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135383470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135383470">Mario Carneiro (Oct 08 2018 at 06:47)</a>:</h4>
<p>it's already behind schedule too much</p>

<a name="135383513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135383513" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135383513">Mario Carneiro (Oct 08 2018 at 06:48)</a>:</h4>
<p>although it has made several other projects come to the fore, which I will probably have to start working on after I'm done</p>

<a name="135383515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135383515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135383515">Mario Carneiro (Oct 08 2018 at 06:48)</a>:</h4>
<p>foremost of which is the multiple scalar field thing</p>

<a name="135383519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135383519" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135383519">Johan Commelin (Oct 08 2018 at 06:48)</a>:</h4>
<p>After you are done, I think <code>faster</code> should be the first thing on your list. <span class="emoji emoji-1f606" title="lol">:lol:</span></p>

<a name="135383522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135383522" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135383522">Mario Carneiro (Oct 08 2018 at 06:48)</a>:</h4>
<p>I'm actually working on that ATM</p>

<a name="135383525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135383525" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135383525">Johan Commelin (Oct 08 2018 at 06:49)</a>:</h4>
<p>Wonderful! Thanks for doing that!</p>

<a name="135384515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135384515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135384515">Kevin Buzzard (Oct 08 2018 at 07:15)</a>:</h4>
<p>Here are some thoughts. The fundamental notion in algebraic geometry is an "f-map" -- see 6.21.7 in <a href="https://stacks.math.columbia.edu/tag/008C" target="_blank" title="https://stacks.math.columbia.edu/tag/008C">the stacks project</a>. Lemma 6.21.8 shows that this is a natural idea. Although it's dressed up in a geometric language, this is something related to the conversation here. The notion of an f-map shows up in the definition of a morphism of ringed spaces in <a href="https://stacks.math.columbia.edu/tag/0090" target="_blank" title="https://stacks.math.columbia.edu/tag/0090">definition 6.21</a>. In the discussion just below 6.26.3 <a href="https://stacks.math.columbia.edu/tag/0094" target="_blank" title="https://stacks.math.columbia.edu/tag/0094">here</a> we see the notion of an f-map of sheaves of modules. Note in particular in that discussion that the f-maps from G to F are in canonical bijection with two other hom sets, one involving only sheaves on X and one involving only sheaves on Y.</p>
<p>Now of course all this needs a lot of unravelling, and the way to unravel is to ask how what de Jong writes translates into the case of affine schemes, which are just commutative rings in disguise. If I got it right, then he says to focus on the following idea: if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f:A\to B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mrel">:</span><span class="mord mathit">A</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> is a map of rings and if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">G</span></span></span></span> is an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span>-module and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span> a <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>-module, an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>-map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>→</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">G\to F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">G</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span> is simply an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span>-module homomorphism from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">G</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span>, and the observation is that such maps naturally biject with the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>-module homomorphisms from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><msub><mo>⊗</mo><mi>A</mi></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">G\otimes_AB</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord mathit">G</span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span>. I think this is different to what Scott suggests -- he went the other way.</p>

<a name="135384772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135384772" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135384772">Kevin Buzzard (Oct 08 2018 at 07:20)</a>:</h4>
<blockquote>
<p>I wonder if there is a common generalization of ring homs, (R,R) -&gt; (R', R') and linear maps (R,M) -&gt; (R, M')</p>
</blockquote>
<p>I think <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>-maps give this. An <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>-map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>R</mi><mo separator="true">,</mo><mi>M</mi><mo>)</mo><mo>→</mo><mo>(</mo><msup><mi>R</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><msup><mi>M</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">(R,M)\to (R',M')</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mrel">→</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is a ring map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>→</mo><msup><mi>R</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">R\to R'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mrel">→</span><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> and an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span>-module map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>→</mo><msup><mi>M</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">M\to M'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mrel">→</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> (note I'm constantly using this trick of, the moment I have a ring map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>→</mo><msup><mi>R</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">R\to R'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mrel">→</span><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>, considering all <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>R</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">R'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>-modules as <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span>-modules). If <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>→</mo><msup><mi>R</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">R\to R'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mrel">→</span><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> is the identity then this is just an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span>-module homomorphism, and an <em>example</em> of an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>-map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>R</mi><mo separator="true">,</mo><mi>R</mi><mo>)</mo><mo>→</mo><mo>(</mo><msup><mi>R</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><msup><mi>R</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">(R,R)\to(R',R')</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mrel">→</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is given by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>f</mi><mo separator="true">,</mo><mi>f</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(f,f)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>, but given <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>:</mo><mi>R</mi><mo>→</mo><msup><mi>R</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">f:R\to R'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mrel">:</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mrel">→</span><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> there are <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>-maps <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>R</mi><mo separator="true">,</mo><mi>R</mi><mo>)</mo><mo>→</mo><mo>(</mo><msup><mi>R</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><msup><mi>R</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">(R,R)\to (R',R')</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mrel">→</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> which are not <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>f</mi><mo separator="true">,</mo><mi>f</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(f,f)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>.</p>

<a name="135385018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135385018" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135385018">Kevin Buzzard (Oct 08 2018 at 07:26)</a>:</h4>
<p>OK so Johan has isolated exactly the same idea, but somehow it seems that he has come from a completely different viewpoint (I don't know what a fibred category is). Regarding commutative v non-commutative, I think it's a good idea to push commutative here. Someone impressed on me decades ago that one should not think of commutative ring theory as a special case of non-commutative ring theory but regard them as completely different areas. I don't know anything about research into non-commutative ring theory, but commutative ring theory is very much alive and kicking -- e.g. ideas from the theory of perfectoid spaces were used here <a href="https://arxiv.org/abs/1608.08882" target="_blank" title="https://arxiv.org/abs/1608.08882">https://arxiv.org/abs/1608.08882</a> to resolve a the direct summand conjecture. Commutative algebra is the foundation of modern algebraic geometry and I have always been of the opinion (even before I knew anything about formal proof verification software) that books like Atiyah--Macdonald and Matsumura (both standard commutative algebra textbooks) somehow "operated close to the axioms" whilst still being of great modern interest. If we want to push Lean as a tool for algebraic geometry, which it one day might become, then there's no harm focussing on commutative algebra. When someone eventually decides to do some basic representation theory of finite groups we might have to plough through basics of semisimple algebras but that is somehow a completely different project.</p>

<a name="135385035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135385035" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135385035">Johan Commelin (Oct 08 2018 at 07:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> A fibered category is the thing that underlies a stack.</p>

<a name="135385039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135385039" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135385039">Johan Commelin (Oct 08 2018 at 07:27)</a>:</h4>
<p>Basically it abstracts <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>-maps</p>

<a name="135385344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135385344" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135385344">Kevin Buzzard (Oct 08 2018 at 07:33)</a>:</h4>
<blockquote>
<blockquote>
<p>every R'-mod is an R-mod</p>
</blockquote>
<p>This one requires an explicit ring hom input</p>
</blockquote>
<p>Patrick mentioned recently that sometimes it's best to concentrate on the morphisms, not the objects. In alg geom we even see it in the name -- an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>-map is a construction which depends on a map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span> of rings. In fact Johan is saying all the right things, I need to get up much earlier to get ahead of him. Given <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>:</mo><mi>R</mi><mo>→</mo><msup><mi>R</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">f:R\to R'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mrel">:</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mrel">→</span><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> there are then adjoint functors <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>R</mi><mo>−</mo><mi>m</mi><mi>o</mi><mi>d</mi><mo>)</mo><mo>→</mo><mo>(</mo><msup><mi>R</mi><mo mathvariant="normal">′</mo></msup><mo>−</mo><mi>m</mi><mi>o</mi><mi>d</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(R-mod)\to(R'-mod)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">−</span><span class="mord mathit">m</span><span class="mord mathit">o</span><span class="mord mathit">d</span><span class="mclose">)</span><span class="mrel">→</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span><span class="mbin">−</span><span class="mord mathit">m</span><span class="mord mathit">o</span><span class="mord mathit">d</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msup><mi>R</mi><mo mathvariant="normal">′</mo></msup><mo>−</mo><mi>m</mi><mi>o</mi><mi>d</mi><mo>)</mo><mo>→</mo><mo>(</mo><mi>R</mi><mo>−</mo><mi>m</mi><mi>o</mi><mi>d</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(R'-mod)\to(R-mod)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span><span class="mbin">−</span><span class="mord mathit">m</span><span class="mord mathit">o</span><span class="mord mathit">d</span><span class="mclose">)</span><span class="mrel">→</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">−</span><span class="mord mathit">m</span><span class="mord mathit">o</span><span class="mord mathit">d</span><span class="mclose">)</span></span></span></span> and hopefully Kenny proved enough about universal property of tensor products to show that these are adjoints. I think that Scott's punt went in the wrong direction. There is a time when you get maps one way and the other way, but that's when you go back to schemes.</p>

<a name="135385406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135385406" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135385406">Johan Commelin (Oct 08 2018 at 07:34)</a>:</h4>
<blockquote>
<p>In fact Johan is saying all the right things, I need to get up much earlier to get ahead of him. </p>
</blockquote>
<p>I've got a 2-year old daughter. You can't win.</p>

<a name="135385439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135385439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135385439">Johan Commelin (Oct 08 2018 at 07:35)</a>:</h4>
<p>Well, what I think that Scott meant that <code>f → f^*</code> is contravariant.</p>

<a name="135385440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135385440" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135385440">Kevin Buzzard (Oct 08 2018 at 07:35)</a>:</h4>
<p>Kenny's construction is something else though. If <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">L</span></span></span></span> is an ideal of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span> then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>L</mi><mi>e</mi></msup></mrow><annotation encoding="application/x-tex">L^e</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">e</span></span></span></span></span></span></span></span></span></span></span>, the pushforward ideal, is less well-behaved. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>L</mi><mi>e</mi></msup></mrow><annotation encoding="application/x-tex">L^e</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">e</span></span></span></span></span></span></span></span></span></span></span> is the image of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><msub><mo>⊗</mo><mi>A</mi></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">L\otimes_AB</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord mathit">L</span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> (the canonical thing when it comes to modules) under the natural map from this guy to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> corresponding by adjointness to the map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">L\to B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">L</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>. So it might satisfy some universal property for ideals, but probably not for modules.</p>

<a name="135385492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135385492" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135385492">Kevin Buzzard (Oct 08 2018 at 07:36)</a>:</h4>
<p>OK I think that's all I have to say and I think that most of it had been said already, but at least I caught up.</p>

<a name="135385493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135385493" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135385493">Johan Commelin (Oct 08 2018 at 07:36)</a>:</h4>
<p>For ideals it will probably give you a Galois connection. Here! I said it. Without checking.</p>

<a name="135385562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135385562" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135385562">Mario Carneiro (Oct 08 2018 at 07:38)</a>:</h4>
<p>But I guess <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>L</mi><mi>e</mi></msup></mrow><annotation encoding="application/x-tex">L^e</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">e</span></span></span></span></span></span></span></span></span></span></span> is the best you can do when you have a ring hom A-&gt;B and an ideal L?</p>

<a name="135385574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135385574" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135385574">Johan Commelin (Oct 08 2018 at 07:38)</a>:</h4>
<p>If you want an ideal of <code>B</code>, yes.</p>

<a name="135385584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135385584" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135385584">Johan Commelin (Oct 08 2018 at 07:39)</a>:</h4>
<p>Otherwise, you could just tensor, and treat it as a module.</p>

<a name="135385586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135385586" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135385586">Mario Carneiro (Oct 08 2018 at 07:39)</a>:</h4>
<p>Is this a thing we can currently do?</p>

<a name="135385590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135385590" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135385590">Johan Commelin (Oct 08 2018 at 07:39)</a>:</h4>
<p>What?</p>

<a name="135385592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135385592" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135385592">Mario Carneiro (Oct 08 2018 at 07:39)</a>:</h4>
<p>tensoring like that</p>

<a name="135385594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135385594" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135385594">Johan Commelin (Oct 08 2018 at 07:39)</a>:</h4>
<p>I guess almost</p>

<a name="135385634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135385634" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135385634">Johan Commelin (Oct 08 2018 at 07:40)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> Did you include extension of scalars in your work on tensor products?</p>

<a name="135385647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135385647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135385647">Johan Commelin (Oct 08 2018 at 07:40)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Given what we have, it shouldn't be too hard</p>

<a name="135385977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135385977" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135385977">Kenny Lau (Oct 08 2018 at 07:49)</a>:</h4>
<p>I don’t think I did.</p>

<a name="135386823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135386823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135386823">Kevin Buzzard (Oct 08 2018 at 08:07)</a>:</h4>
<p>Oh I see. The issue is that if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">M</span></span></span></span> is an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span>-module and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> is an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span>-algebra (and hence an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span>-module) then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>A</mi></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">M\otimes_AB</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> is not just an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span>-module but a <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>-module.</p>

<a name="135386914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135386914" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135386914">Johan Commelin (Oct 08 2018 at 08:08)</a>:</h4>
<p>Right, we don't have something like that atm</p>

<a name="135386928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135386928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135386928">Johan Commelin (Oct 08 2018 at 08:09)</a>:</h4>
<p>But it shouldn't be hard to put a <code>B</code>-mod structure on the tensor product.</p>

<a name="135387004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135387004" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135387004">Johan Commelin (Oct 08 2018 at 08:10)</a>:</h4>
<p>I don't know if it should "extend" the <code>A</code>-mod structure, in the sense that if you "restrict" scalars you get an <code>A</code>-mod that is defeq to what you started with.</p>

<a name="135421783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/135421783" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#135421783">Patrick Massot (Oct 08 2018 at 18:55)</a>:</h4>
<blockquote>
<p>foremost of which is the multiple scalar field thing</p>
</blockquote>
<p>I'm completely lost: I thought this module refactor was mostly about multiple scalars</p>

<a name="136304439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136304439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136304439">Kenny Lau (Oct 22 2018 at 23:44)</a>:</h4>
<p>How's it going? <span class="user-mention" data-user-id="110049">@Mario Carneiro</span></p>

<a name="136306139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136306139" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136306139">Mario Carneiro (Oct 23 2018 at 00:22)</a>:</h4>
<p>waiting on my school work to decrease in intensity</p>

<a name="136306145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136306145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136306145">Mario Carneiro (Oct 23 2018 at 00:22)</a>:</h4>
<p>hopefully I should be able to find some time for it this week</p>

<a name="136911662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136911662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136911662">Kenny Lau (Nov 01 2018 at 09:59)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/commits/module" target="_blank" title="https://github.com/leanprover-community/mathlib/commits/module">https://github.com/leanprover-community/mathlib/commits/module</a></p>

<a name="136911664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136911664" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136911664">Kenny Lau (Nov 01 2018 at 09:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> is there anything we can help with?</p>

<a name="136912060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136912060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136912060">Mario Carneiro (Nov 01 2018 at 10:09)</a>:</h4>
<p>Possibly... I'm just short on time these days. The main work is done, I think, but a bunch of files still need to be updated</p>

<a name="136912064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136912064" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136912064">Kenny Lau (Nov 01 2018 at 10:09)</a>:</h4>
<p>what can we do?</p>

<a name="136912067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136912067" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136912067">Kenny Lau (Nov 01 2018 at 10:09)</a>:</h4>
<p>should I fix the errors?</p>

<a name="136912068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136912068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136912068">Mario Carneiro (Nov 01 2018 at 10:09)</a>:</h4>
<p>go in there and make the red squiggles go away</p>

<a name="136912116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136912116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136912116">Kenny Lau (Nov 01 2018 at 10:10)</a>:</h4>
<p>roger that</p>

<a name="136912204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136912204" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136912204">Mario Carneiro (Nov 01 2018 at 10:12)</a>:</h4>
<p>Don't get too attached to anything that you write there, I'll probably have a look through all the files anyway, but it will be a lot easier if it's not already broken</p>

<a name="136919089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136919089" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136919089">Kenny Lau (Nov 01 2018 at 12:44)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> there are things that you deleted and things that depend on them, right</p>

<a name="136919093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136919093" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136919093">Kenny Lau (Nov 01 2018 at 12:44)</a>:</h4>
<p>I'll just leave those untouched</p>

<a name="136919165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136919165" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136919165">Mario Carneiro (Nov 01 2018 at 12:46)</a>:</h4>
<p>like what? I think all deleted files have equivalents</p>

<a name="136919191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136919191" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136919191">Kenny Lau (Nov 01 2018 at 12:47)</a>:</h4>
<p>like the order embedding of submodules of submodules, and the prime ideal, and the trivial ideal</p>

<a name="136919263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136919263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136919263">Kenny Lau (Nov 01 2018 at 12:48)</a>:</h4>
<p>and also this:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">Union_set_of_directed</span> <span class="o">{</span><span class="n">ι</span><span class="o">}</span> <span class="o">(</span><span class="n">hι</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">ι</span><span class="o">)</span>
  <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">submodule</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">S</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">S</span> <span class="n">k</span> <span class="bp">∧</span> <span class="n">S</span> <span class="n">j</span> <span class="bp">≤</span> <span class="n">S</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">((</span><span class="n">supr</span> <span class="n">S</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">)</span> <span class="bp">=</span> <span class="err">⋃</span> <span class="n">i</span><span class="o">,</span> <span class="n">S</span> <span class="n">i</span> <span class="o">:=</span>
</pre></div>

<a name="136919265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136919265" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136919265">Mario Carneiro (Nov 01 2018 at 12:48)</a>:</h4>
<p>prime ideals are still there</p>

<a name="136919287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136919287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136919287">Mario Carneiro (Nov 01 2018 at 12:49)</a>:</h4>
<p>search for that, it moved somewhere else</p>

<a name="136919297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136919297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136919297">Mario Carneiro (Nov 01 2018 at 12:49)</a>:</h4>
<p>I think it is Union_coe now</p>

<a name="136919305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136919305" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136919305">Kenny Lau (Nov 01 2018 at 12:49)</a>:</h4>
<p><code>prime_ideal</code> doesn't give me anything</p>

<a name="136919307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136919307" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136919307">Kenny Lau (Nov 01 2018 at 12:49)</a>:</h4>
<p>and i wouldn't search for <code>prime</code></p>

<a name="136919355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136919355" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136919355">Mario Carneiro (Nov 01 2018 at 12:50)</a>:</h4>
<p>the trivial ideal is bottom</p>

<a name="136919360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136919360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136919360">Kenny Lau (Nov 01 2018 at 12:50)</a>:</h4>
<p>ok I searched for <code>prime</code> and I found it</p>

<a name="136925189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136925189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136925189">Kenny Lau (Nov 01 2018 at 14:32)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> what about the embedding “submodules of N” -&gt; “submodules of M” where N is a submodule of M?</p>

<a name="136928650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136928650" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136928650">Mario Carneiro (Nov 01 2018 at 15:25)</a>:</h4>
<p>I think that's <code>map N.subtype</code> or <code>map_subtype.order_iso</code></p>

<a name="136942283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136942283" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136942283">Kenny Lau (Nov 01 2018 at 18:54)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I've pushed a partial fix</p>

<a name="136942285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136942285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136942285">Kenny Lau (Nov 01 2018 at 18:54)</a>:</h4>
<p>I'll see what more I can do</p>

<a name="136986811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136986811" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136986811">Kenny Lau (Nov 02 2018 at 09:54)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> for principal ideal domains, the situation is that <code>{x | a ∣ x}</code> is a set not an ideal, so these definitions are a bit troublesome:</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">is_principal_ideal</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">principal</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">S</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">a</span> <span class="err">∣</span> <span class="n">x</span><span class="o">})</span>

<span class="n">class</span> <span class="n">principal_ideal_domain</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">integral_domain</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">principal</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">α</span><span class="o">),</span> <span class="n">is_principal_ideal</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">))</span>
</pre></div>

<a name="136986813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/136986813" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#136986813">Kenny Lau (Nov 02 2018 at 09:54)</a>:</h4>
<p>what should I do?</p>

<a name="137008240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137008240" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137008240">Kenny Lau (Nov 02 2018 at 12:32)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <a href="https://github.com/leanprover/mathlib/blob/master/ring_theory/ideals.lean#L140" target="_blank" title="https://github.com/leanprover/mathlib/blob/master/ring_theory/ideals.lean#L140"><code>ideal.quotient.eq</code></a> is missing</p>

<a name="137008271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137008271" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137008271">Kenny Lau (Nov 02 2018 at 12:33)</a>:</h4>
<p>(and <code>submodule.quotient.eq</code> doesn't count)</p>

<a name="137064504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137064504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137064504">Kenny Lau (Nov 02 2018 at 16:17)</a>:</h4>
<p>Successfully reduced to 4 errors. Pushed.</p>

<a name="137076716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137076716" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137076716">Mario Carneiro (Nov 02 2018 at 19:22)</a>:</h4>
<p>the ideal <code>{x | a ∣ x}</code> is now spelled <code>span {a}</code></p>

<a name="137079093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137079093" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137079093">Kenny Lau (Nov 02 2018 at 20:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> by "now" do you mean "I've changed that in my private copy" or "I should change that and then push it"?</p>

<a name="137079105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137079105" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137079105">Mario Carneiro (Nov 02 2018 at 20:06)</a>:</h4>
<p>I mean in the module branch that's how it is currently used</p>

<a name="137079113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137079113" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137079113">Mario Carneiro (Nov 02 2018 at 20:06)</a>:</h4>
<p>so if you find it elsewhere you should use that</p>

<a name="137079114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137079114" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137079114">Kenny Lau (Nov 02 2018 at 20:06)</a>:</h4>
<p>so it's the latter?</p>

<a name="137079118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137079118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137079118">Kenny Lau (Nov 02 2018 at 20:06)</a>:</h4>
<p>ok</p>

<a name="137079137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137079137" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137079137">Mario Carneiro (Nov 02 2018 at 20:07)</a>:</h4>
<p>is_principal_ideal should be a property of S : ideal</p>

<a name="137079292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137079292" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137079292">Kenny Lau (Nov 02 2018 at 20:10)</a>:</h4>
<p>and what is to become of <code>ideal.quotient.eq</code>? <span class="user-mention" data-user-id="110049">@Mario Carneiro</span></p>

<a name="137079358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137079358" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137079358">Mario Carneiro (Nov 02 2018 at 20:11)</a>:</h4>
<p>what does <code>quotient_ring</code> look like now?</p>

<a name="137079414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137079414" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137079414">Kenny Lau (Nov 02 2018 at 20:12)</a>:</h4>
<p>it looks like <code>ideal.quotient</code> now</p>

<a name="137079430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137079430" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137079430">Kenny Lau (Nov 02 2018 at 20:12)</a>:</h4>
<p>we have <code>ideal.quotient.mk := submodule.quotient.mk</code> and we have <code>submodule.quotient,eq</code></p>

<a name="137079446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137079446" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137079446">Kenny Lau (Nov 02 2018 at 20:13)</a>:</h4>
<p>but not <code>ideal.quotient.eq</code></p>

<a name="137079455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137079455" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137079455">Mario Carneiro (Nov 02 2018 at 20:13)</a>:</h4>
<p>oh sure, you can state <code>ideal.quotient.eq</code></p>

<a name="137079458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137079458" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137079458">Kenny Lau (Nov 02 2018 at 20:13)</a>:</h4>
<p>ok</p>

<a name="137079464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137079464" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137079464">Mario Carneiro (Nov 02 2018 at 20:13)</a>:</h4>
<p>it's just a defeq copy paste job</p>

<a name="137079476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137079476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137079476">Kenny Lau (Nov 02 2018 at 20:13)</a>:</h4>
<p>I just thought I wouldn't add things without first asking you</p>

<a name="137079481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137079481" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137079481">Mario Carneiro (Nov 02 2018 at 20:13)</a>:</h4>
<p>I have not added all theorems from submodules to ideals, I intended to add them as needed</p>

<a name="137079549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137079549" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137079549">Mario Carneiro (Nov 02 2018 at 20:14)</a>:</h4>
<p>you can often just use the submodule version directly, but it is slightly less ergonomic</p>

<a name="137079650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137079650" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137079650">Kenny Lau (Nov 02 2018 at 20:16)</a>:</h4>
<p>I agree (with the latter statement)</p>

<a name="137084347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137084347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137084347">Kenny Lau (Nov 02 2018 at 21:38)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">mem_span_singleton</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">x</span> <span class="err">∈</span> <span class="n">span</span> <span class="o">({</span><span class="n">y</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
</pre></div>

<a name="137084351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137084351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137084351">Kenny Lau (Nov 02 2018 at 21:38)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> can I change this to use dvd?</p>

<a name="137084382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137084382" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137084382">Mario Carneiro (Nov 02 2018 at 21:39)</a>:</h4>
<p>maybe make another theorem</p>

<a name="137084453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137084453" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137084453">Kenny Lau (Nov 02 2018 at 21:40)</a>:</h4>
<p>but nobody uses that theorem</p>

<a name="137084455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137084455" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137084455">Kenny Lau (Nov 02 2018 at 21:40)</a>:</h4>
<p>you added that theorem yourself</p>

<a name="137085654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137085654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137085654">Kenny Lau (Nov 02 2018 at 22:04)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">is_maximal_of_irreducible</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="kn">irreducible</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_maximal</span> <span class="o">(</span><span class="n">span</span> <span class="o">({</span><span class="n">p</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">))</span> <span class="o">:=</span>
</pre></div>


<p>Should this be an instance?</p>

<a name="137085959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137085959" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137085959">Mario Carneiro (Nov 02 2018 at 22:11)</a>:</h4>
<p>oh I see, it's copy pasted from the analogous theorem on submodule, where you can't use dvd</p>

<a name="137086049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137086049" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137086049">Mario Carneiro (Nov 02 2018 at 22:13)</a>:</h4>
<p>as for that last one - probably not. Things like <code>irreducible</code> and <code>maximal</code> and <code>nat.prime</code> are forming a new kind of idiom, where the predicate is a <code>class</code> but most of the theorems use it like normal assumptions</p>

<a name="137086099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137086099" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137086099">Mario Carneiro (Nov 02 2018 at 22:14)</a>:</h4>
<p>This is primarily intended to support the few cases where you have to use typeclass inference, like in Z/nZ is a field</p>

<a name="137089370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137089370" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137089370">Kevin Buzzard (Nov 02 2018 at 23:27)</a>:</h4>
<p>I want there to be an "is_an_integer" predicate on eg rat to save me from coercions.</p>

<a name="137089440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137089440" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137089440">Kenny Lau (Nov 02 2018 at 23:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> wrong thread?</p>

<a name="137089490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137089490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137089490">Kevin Buzzard (Nov 02 2018 at 23:30)</a>:</h4>
<p>Isn't that a predicate which is a class?</p>

<a name="137089518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137089518" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137089518">Kenny Lau (Nov 02 2018 at 23:30)</a>:</h4>
<p>oh well this is going off track</p>

<a name="137089626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137089626" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137089626">Chris Hughes (Nov 02 2018 at 23:33)</a>:</h4>
<p>Why is it a class?</p>

<a name="137089816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137089816" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137089816">Mario Carneiro (Nov 02 2018 at 23:37)</a>:</h4>
<p>I don't just mean a predicate that is a class, we have plenty of those like <code>first_countable X</code>. I mean predicates that are classes that we use without instance brackets in most theorems</p>

<a name="137090743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137090743" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137090743">Kenny Lau (Nov 03 2018 at 00:03)</a>:</h4>
<p>I feel like there is not enough transparency with the module refactoring, so I've decided to write something about it.</p>
<p>Major changes made:</p>
<ul>
<li><code>semimodule α β</code> and <code>module α β</code> and <code>vector_space α β</code> now take one more argument, that <code>β</code> is an <code>add_comm_group</code>, i.e. before making an instance of a module, you need to prove that it's an abelian group first.</li>
<li>vector space is no longer over a field, but a discrete field.</li>
<li>The idiom for making an instance <code>module α β</code> (after proving that <code>β</code> is an abelian group) is <code>module.of_core { smul := sorry, smul_add  := sorry, add_smul := sorry, mul_smul := sorry, one_smul := sorry }</code>.</li>
<li><code>is_linear_map</code> and <code>linear_map</code> are now both structures, and they are independent, meaning that <code>linear_map</code> is no longer defined as <code>subtype is_linear_map</code>. The idiom for making <code>linear_map</code> from <code>is_linear_map</code> is <code>is_linear_map.mk' (f : M -&gt; N) (sorry : is_linear_map f)</code>, and the idiom for making <code>is_linear_map</code> from <code>linear_map</code> is <code>f.is_linear</code> (i.e. <code>linear_map.is_linear f</code>).</li>
<li><code>is_linear_map.add</code> etc no longer exist. instead, you can now add two linear maps together, etc.</li>
<li>the class<code>is_submodule</code> is gone, replaced by the structure <code>submodule</code> which contains a carrier, i.e. if <code>N : submodule R M</code> then <code>N.carrier</code> is a type. And there is an instance <code>module R N</code> in the same situation.</li>
<li>similarly, the class <code>is_ideal</code> is gone, replaced by the structure <code>ideal</code>, which also contains a carrier.</li>
<li>endomorphism ring and general linear group are defined.</li>
<li>submodules form a complete lattice. the trivial ideal is now idiomatically the bottom element, and the universal ideal the top element.</li>
<li><code>linear_algebra/quotient_module.lean</code> is deleted, and it's now <code>submodule.quotient</code> (so if <code>N : submodule R M</code> then <code>submodule R N.quotient</code>) Similarly, <code>quotient_ring.quotient</code> is replaced by <code>ideal.quotient</code>. The canonical map from <code>N</code> to <code>N.quotient</code> is <code>submodule.quotient.mk</code>, and the canonical map from the ideal <code>I</code> to <code>I.quotient</code> is <code>ideal.quotient.mk I</code>.</li>
<li><code>linear_equiv</code> is now based on a linear map and an equiv, and the difference being that now you need to prove that the inverse is also linear, and there is currently no interface to get around that.</li>
<li>Everything you want to know about linear independence and basis is now in the newly created file <code>linear_algebra/basis.lean</code>.</li>
<li>Everything you want to know about linear combinations is now in the newly created file <code>linear_algebra/lc.lean</code>.</li>
<li><code>linear_algebra/linear_map_module.lean</code> and <code>linear_algebra/prod_module.lean</code> and <code>linear_algebra/quotient_module.lean</code> and <code>linear_algebra/submodule.lean</code> and <code>linear_algebra/subtype_module.lean</code> are deleted (with their contents placed elsewhere).</li>
</ul>

<a name="137090764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137090764" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137090764">Mario Carneiro (Nov 03 2018 at 00:03)</a>:</h4>
<p>Ha, this was my secret plan all along</p>

<a name="137090808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137090808" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137090808">Kenny Lau (Nov 03 2018 at 00:04)</a>:</h4>
<p>I think one would prefer transparency</p>

<a name="137090810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137090810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137090810">Mario Carneiro (Nov 03 2018 at 00:04)</a>:</h4>
<p>now that kenny had to read the stuff he knows what changed</p>

<a name="137090817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137090817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137090817">Mario Carneiro (Nov 03 2018 at 00:04)</a>:</h4>
<p>and can write a nice summary for us</p>

<a name="137090822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137090822" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137090822">Kenny Lau (Nov 03 2018 at 00:04)</a>:</h4>
<p>lol</p>

<a name="137090864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137090864" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137090864">Mario Carneiro (Nov 03 2018 at 00:05)</a>:</h4>
<p>A remark on <code>module.of_core</code>: it's only intended for use when you aren't proving it's a semimodule first</p>

<a name="137090910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137090910" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137090910">Mario Carneiro (Nov 03 2018 at 00:06)</a>:</h4>
<p>like if you don't care about semimodules</p>

<a name="137090954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137090954" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137090954">Kenny Lau (Nov 03 2018 at 00:07)</a>:</h4>
<p>I'm sure Kevin doesn't</p>

<a name="137090961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137090961" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137090961">Mario Carneiro (Nov 03 2018 at 00:07)</a>:</h4>
<p>By the way, <code>is_linear_map</code> is a late addition. I'm hoping it will not be needed much at all, but it's useful to have as a mixin occasionally</p>

<a name="137091015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137091015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137091015">Kenny Lau (Nov 03 2018 at 00:08)</a>:</h4>
<p>one would have to refactor <code>tensor_product</code> to get rid of all the dependencies thereto, I believe</p>

<a name="137091016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137091016" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137091016">Mario Carneiro (Nov 03 2018 at 00:08)</a>:</h4>
<p>I really want <code>linear_map</code> to be the primary one</p>

<a name="137091023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137091023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137091023">Mario Carneiro (Nov 03 2018 at 00:08)</a>:</h4>
<p>oh, I may have done that already</p>

<a name="137091025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137091025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137091025">Kenny Lau (Nov 03 2018 at 00:08)</a>:</h4>
<p>not entirely</p>

<a name="137091026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137091026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137091026">Mario Carneiro (Nov 03 2018 at 00:08)</a>:</h4>
<p>shoot, I have an unsaved file in vscode</p>

<a name="137091030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137091030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137091030">Kenny Lau (Nov 03 2018 at 00:09)</a>:</h4>
<p>lol</p>

<a name="137091130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137091130" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137091130">Mario Carneiro (Nov 03 2018 at 00:11)</a>:</h4>
<p>re: interface for linear_equiv, you don't need to prove the inverse is linear, that's not in the structure</p>

<a name="137091149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137091149" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137091149">Mario Carneiro (Nov 03 2018 at 00:11)</a>:</h4>
<p>it's just the union (pushout?) of linear_map and equiv</p>

<a name="137091304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137091304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137091304">Kenny Lau (Nov 03 2018 at 00:15)</a>:</h4>
<p>oh, right</p>

<a name="137091863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137091863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137091863">Kenny Lau (Nov 03 2018 at 00:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> are you going to push your file?</p>

<a name="137092023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137092023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137092023">Mario Carneiro (Nov 03 2018 at 00:31)</a>:</h4>
<p>oh wait, looks like I already pushed most of it</p>

<a name="137092026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137092026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137092026">Mario Carneiro (Nov 03 2018 at 00:31)</a>:</h4>
<p>you already had the important stuff</p>

<a name="137092090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137092090" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137092090">Kenny Lau (Nov 03 2018 at 00:33)</a>:</h4>
<p>but tensor product still depends on is_linear_map right?</p>

<a name="137092235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137092235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137092235">Kenny Lau (Nov 03 2018 at 00:36)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">protected</span> <span class="n">def</span> <span class="n">id</span> <span class="o">:</span> <span class="n">R</span> <span class="err">⊗</span> <span class="n">M</span> <span class="err">≃ₗ</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">inv_fun</span> <span class="o">:=</span> <span class="o">(</span><span class="err">⊗ₜ</span><span class="o">)</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="n">lift</span><span class="bp">.</span><span class="n">ext</span>
    <span class="o">(</span><span class="n">linear_map</span><span class="bp">.</span><span class="n">is_linear</span> <span class="err">$</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">is_linear_map</span><span class="bp">.</span><span class="n">mk&#39;</span> <span class="bp">_</span> <span class="err">$</span> <span class="o">(</span><span class="n">bilinear</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">linear_right</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lift</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))</span>
    <span class="n">linear_map</span><span class="bp">.</span><span class="n">id</span><span class="bp">.</span><span class="n">is_linear</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">tmul_smul</span><span class="o">,</span> <span class="err">←</span> <span class="n">smul_tmul</span><span class="o">,</span> <span class="n">smul_eq_mul</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">]),</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="bp">..</span> <span class="o">(</span><span class="n">lift</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span> <span class="n">x</span><span class="o">,</span> <span class="n">c</span> <span class="err">•</span> <span class="n">x</span><span class="o">)</span>
    <span class="bp">⟨λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">is_linear</span> <span class="o">(</span><span class="n">linear_map</span><span class="bp">.</span><span class="n">smul_right</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">id</span> <span class="n">m</span><span class="o">),</span>
    <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">is_linear</span> <span class="o">(</span><span class="n">r</span> <span class="err">•</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">id</span><span class="o">)</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">R</span> <span class="err">⊗</span> <span class="n">M</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">M</span><span class="o">)</span> <span class="o">}</span>
</pre></div>

<a name="137092236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137092236" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137092236">Kenny Lau (Nov 03 2018 at 00:36)</a>:</h4>
<p>I don't think anyone wants to see this</p>

<a name="137092333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137092333" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137092333">Mario Carneiro (Nov 03 2018 at 00:39)</a>:</h4>
<p>what is your objection exactly?</p>

<a name="137092419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137092419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137092419">Kenny Lau (Nov 03 2018 at 00:41)</a>:</h4>
<p>1. the linear map needs to be put after <code>..</code>; 2. lack of <code>is_linear_map.comp</code> and the fact that <code>lift.ext</code> and most of the things in <code>tensor_product</code> depend on <code>is_linear_map</code> make proofs very long and cumbersome</p>

<a name="137093199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137093199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137093199">Mario Carneiro (Nov 03 2018 at 01:02)</a>:</h4>
<p>I've only done the first half of that file, so some things may still need to be hashed out</p>

<a name="137093203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137093203" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137093203">Mario Carneiro (Nov 03 2018 at 01:02)</a>:</h4>
<p><code>lift.ext</code> should take linear maps as input</p>

<a name="137093273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137093273" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137093273">Mario Carneiro (Nov 03 2018 at 01:04)</a>:</h4>
<p>You shouldn't feel bound to the current way statements of theorems are written, that's what refactoring is about</p>

<a name="137093296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137093296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137093296">Mario Carneiro (Nov 03 2018 at 01:05)</a>:</h4>
<p>Ideally, this construction should be easy, just cobbling together functions we already know are linear</p>

<a name="137093354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137093354" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137093354">Mario Carneiro (Nov 03 2018 at 01:07)</a>:</h4>
<p>I think we need another constructor for is_bilinear_map, or is_linear_map, that takes a linear function and asks you to prove equality to the target function</p>

<a name="137093401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137093401" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137093401">Mario Carneiro (Nov 03 2018 at 01:08)</a>:</h4>
<p>which corresponds to the alternate definition <code>def is_linear_map (f : β → γ) := ∃ g : β →ₗ γ, ∀ x, f x = g x</code></p>

<a name="137096037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096037" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096037">Kenny Lau (Nov 03 2018 at 02:35)</a>:</h4>
<blockquote>
<p><code>lift.ext</code> should take linear maps as input</p>
</blockquote>
<p>I don't think that will work, because there are things that need to be proved to be linear</p>

<a name="137096098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096098">Kenny Lau (Nov 03 2018 at 02:37)</a>:</h4>
<p>do you think I should change <code>is_bilinear_map</code> to <code>bilinear_map</code>?</p>

<a name="137096203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096203" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096203">Mario Carneiro (Nov 03 2018 at 02:40)</a>:</h4>
<p>Huh? <code>lift.ext</code> takes two functions and proofs that they are linear</p>

<a name="137096204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096204" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096204">Mario Carneiro (Nov 03 2018 at 02:40)</a>:</h4>
<p>that can always be contracted to a function taking a <code>linear_map</code> arg</p>

<a name="137096254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096254" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096254">Mario Carneiro (Nov 03 2018 at 02:42)</a>:</h4>
<p>I thought about it, but do the set of all bilinear maps have a nice structure like linear maps? Like can you add them and such</p>

<a name="137096331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096331" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096331">Kenny Lau (Nov 03 2018 at 02:45)</a>:</h4>
<p>yes</p>

<a name="137096332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096332" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096332">Kenny Lau (Nov 03 2018 at 02:45)</a>:</h4>
<p>they're even a module</p>

<a name="137096371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096371" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096371">Kenny Lau (Nov 03 2018 at 02:46)</a>:</h4>
<p>they're as nice as linear maps</p>

<a name="137096374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096374" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096374">Kenny Lau (Nov 03 2018 at 02:46)</a>:</h4>
<p>(because of the universal property of tensor product :P)</p>

<a name="137096836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096836" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096836">Mario Carneiro (Nov 03 2018 at 03:02)</a>:</h4>
<p>well okay then</p>

<a name="137096849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096849" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096849">Mario Carneiro (Nov 03 2018 at 03:03)</a>:</h4>
<p>I think <code>bilinear_map</code> still needs to reference <code>is_linear_map</code> though</p>

<a name="137096851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096851" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096851">Kenny Lau (Nov 03 2018 at 03:03)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">bilinear_map</span> <span class="o">:=</span> <span class="n">M</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">N</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">P</span>
</pre></div>

<a name="137096852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096852" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096852">Kenny Lau (Nov 03 2018 at 03:03)</a>:</h4>
<p>how about this</p>

<a name="137096854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096854" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096854">Mario Carneiro (Nov 03 2018 at 03:03)</a>:</h4>
<p>oh! does that work?</p>

<a name="137096856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096856" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096856">Kenny Lau (Nov 03 2018 at 03:03)</a>:</h4>
<p>I'm experimenting with it now</p>

<a name="137096859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096859" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096859">Mario Carneiro (Nov 03 2018 at 03:03)</a>:</h4>
<p>is Mod(R) a CCC?</p>

<a name="137096898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096898" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096898">Kenny Lau (Nov 03 2018 at 03:04)</a>:</h4>
<p>CCC?</p>

<a name="137096899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096899" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096899">Mario Carneiro (Nov 03 2018 at 03:04)</a>:</h4>
<p>cartesian closed category</p>

<a name="137096900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096900" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096900">Mario Carneiro (Nov 03 2018 at 03:04)</a>:</h4>
<p>i.e. that thing means what you want it to</p>

<a name="137096901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096901" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096901">Kenny Lau (Nov 03 2018 at 03:04)</a>:</h4>
<p>yes</p>

<a name="137096910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096910" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096910">Kenny Lau (Nov 03 2018 at 03:05)</a>:</h4>
<p>actually I don't know</p>

<a name="137096913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096913" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096913">Kenny Lau (Nov 03 2018 at 03:05)</a>:</h4>
<p>I just know that Hom(M tensor N, P) = Hom(M, Hom(N, P))</p>

<a name="137096914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096914" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096914">Kenny Lau (Nov 03 2018 at 03:05)</a>:</h4>
<p>so (- tensor N) is right adjoint to Hom(N, -)</p>

<a name="137096923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096923">Mario Carneiro (Nov 03 2018 at 03:05)</a>:</h4>
<p>that looks a lot like the universal property of the exponential</p>

<a name="137096963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137096963" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137096963">Mario Carneiro (Nov 03 2018 at 03:06)</a>:</h4>
<p>Hom(N,P) there is actually an object of the category</p>

<a name="137097797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137097797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137097797">Kenny Lau (Nov 03 2018 at 03:37)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">free_abelian_group</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">squeeze</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">{</span><span class="n">Q</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">Q</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">Q</span><span class="o">]</span>
<span class="n">include</span> <span class="n">R</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">bilinear_map</span> <span class="o">:=</span> <span class="n">M</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">N</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">P</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">M</span> <span class="n">N</span> <span class="n">P</span><span class="o">}</span>

<span class="kn">namespace</span> <span class="n">bilinear_map</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="n">P</span> <span class="n">Q</span><span class="o">}</span>

<span class="kn">section</span> <span class="n">mk</span>
<span class="kn">variable</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">P</span><span class="o">)</span>
<span class="kn">variable</span> <span class="o">(</span><span class="n">H1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m₁</span> <span class="n">m₂</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">m₁</span> <span class="bp">+</span> <span class="n">m₂</span><span class="o">)</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">m₁</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">m₂</span> <span class="n">n</span><span class="o">)</span>
<span class="kn">variable</span> <span class="o">(</span><span class="n">H2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">c</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">c</span> <span class="err">•</span> <span class="n">m</span><span class="o">)</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">c</span> <span class="err">•</span> <span class="n">f</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span>
<span class="kn">variable</span> <span class="o">(</span><span class="n">H3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="n">n₁</span> <span class="n">n₂</span><span class="o">,</span> <span class="n">f</span> <span class="n">m</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">m</span> <span class="n">n₁</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">m</span> <span class="n">n₂</span><span class="o">)</span>
<span class="kn">variable</span> <span class="o">(</span><span class="n">H4</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">c</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">m</span> <span class="o">(</span><span class="n">c</span> <span class="err">•</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span> <span class="err">•</span> <span class="n">f</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span>

<span class="n">def</span> <span class="n">bilinear_map</span><span class="bp">.</span><span class="n">mk</span> <span class="o">:</span>
  <span class="n">bilinear_map</span> <span class="n">R</span> <span class="n">M</span> <span class="n">N</span> <span class="n">P</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">m</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">f</span> <span class="n">m</span><span class="o">,</span> <span class="n">H3</span> <span class="n">m</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">c</span><span class="o">,</span> <span class="n">H4</span> <span class="n">c</span> <span class="n">m</span><span class="bp">⟩</span><span class="o">,</span>
<span class="bp">λ</span> <span class="n">m₁</span> <span class="n">m₂</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">ext</span> <span class="err">$</span> <span class="n">H1</span> <span class="n">m₁</span> <span class="n">m₂</span><span class="o">,</span>
<span class="bp">λ</span> <span class="n">c</span> <span class="n">m</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">ext</span> <span class="err">$</span> <span class="n">H2</span> <span class="n">c</span> <span class="n">m</span><span class="bp">⟩</span>

<span class="kn">theorem</span> <span class="n">bilinear_map</span><span class="bp">.</span><span class="n">mk_apply</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">bilinear_map</span><span class="bp">.</span><span class="n">mk</span> <span class="n">f</span> <span class="n">H1</span> <span class="n">H2</span> <span class="n">H3</span> <span class="n">H4</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">end</span> <span class="n">mk</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">bilinear_map</span> <span class="n">R</span> <span class="n">M</span> <span class="n">N</span> <span class="n">P</span><span class="o">)</span>

<span class="n">def</span> <span class="n">comm</span> <span class="o">:</span> <span class="n">bilinear_map</span> <span class="n">R</span> <span class="n">N</span> <span class="n">M</span> <span class="n">P</span> <span class="o">:=</span>
<span class="n">bilinear_map</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="n">f</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">n₁</span> <span class="n">n₂</span> <span class="n">m</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">map_add</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">map_smul</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">m₁</span> <span class="n">m₂</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">f</span><span class="bp">.</span><span class="n">map_add</span><span class="bp">;</span> <span class="n">refl</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">f</span><span class="bp">.</span><span class="n">map_smul</span><span class="bp">;</span> <span class="n">refl</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">comm_apply</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span><span class="bp">.</span><span class="n">comm</span> <span class="n">n</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="n">def</span> <span class="n">left</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">P</span> <span class="o">:=</span> <span class="n">f</span><span class="bp">.</span><span class="n">comm</span> <span class="n">y</span>
<span class="n">def</span> <span class="n">right</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">P</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">x</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">left_apply</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span><span class="bp">.</span><span class="n">left</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">right_apply</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span><span class="bp">.</span><span class="n">right</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">theorem</span> <span class="n">zero_left</span> <span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f</span><span class="bp">.</span><span class="n">left</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">map_zero</span>
<span class="kn">theorem</span> <span class="n">zero_right</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f</span><span class="bp">.</span><span class="n">right</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">map_zero</span>

<span class="kn">theorem</span> <span class="n">neg_left</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f</span><span class="bp">.</span><span class="n">left</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">map_neg</span> <span class="bp">_</span>
<span class="kn">theorem</span> <span class="n">neg_right</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="o">(</span><span class="bp">-</span><span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f</span><span class="bp">.</span><span class="n">right</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">map_neg</span> <span class="bp">_</span>

<span class="kn">theorem</span> <span class="n">add_left</span> <span class="o">(</span><span class="n">x₁</span> <span class="n">x₂</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="n">x₁</span> <span class="bp">+</span> <span class="n">x₂</span><span class="o">)</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x₁</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">x₂</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f</span><span class="bp">.</span><span class="n">left</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">map_add</span> <span class="bp">_</span> <span class="bp">_</span>
<span class="kn">theorem</span> <span class="n">add_right</span> <span class="o">(</span><span class="n">x</span> <span class="n">y₁</span> <span class="n">y₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="o">(</span><span class="n">y₁</span> <span class="bp">+</span> <span class="n">y₂</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y₁</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y₂</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f</span><span class="bp">.</span><span class="n">right</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">map_add</span> <span class="bp">_</span> <span class="bp">_</span>

<span class="kn">theorem</span> <span class="n">smul_left</span> <span class="o">(</span><span class="n">r</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="n">r</span> <span class="err">•</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f</span><span class="bp">.</span><span class="n">left</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">map_smul</span> <span class="bp">_</span> <span class="bp">_</span>
<span class="kn">theorem</span> <span class="n">smul_right</span> <span class="o">(</span><span class="n">r</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="o">(</span><span class="n">r</span> <span class="err">•</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f</span><span class="bp">.</span><span class="n">right</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">map_smul</span> <span class="bp">_</span> <span class="bp">_</span>

<span class="n">def</span> <span class="n">comp₁</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Q</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">bilinear_map</span> <span class="n">R</span> <span class="n">Q</span> <span class="n">N</span> <span class="n">P</span> <span class="o">:=</span>
<span class="n">linear_map</span><span class="bp">.</span><span class="n">comp</span> <span class="n">f</span> <span class="n">g</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">comp₁_apply</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Q</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">Q</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span><span class="bp">.</span><span class="n">comp₁</span> <span class="n">g</span> <span class="n">q</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">q</span><span class="o">)</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="n">def</span> <span class="n">comp₂</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Q</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">bilinear_map</span> <span class="n">R</span> <span class="n">M</span> <span class="n">Q</span> <span class="n">P</span> <span class="o">:=</span>
<span class="n">linear_map</span><span class="bp">.</span><span class="n">comp</span> <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">comp</span> <span class="n">x</span> <span class="n">g</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="n">f</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">comp₂_apply</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Q</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span><span class="bp">.</span><span class="n">comp₂</span> <span class="n">g</span> <span class="n">m</span> <span class="n">q</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">m</span> <span class="o">(</span><span class="n">g</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="n">def</span> <span class="n">comp₃</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span> <span class="n">bilinear_map</span> <span class="n">R</span> <span class="n">M</span> <span class="n">N</span> <span class="n">Q</span> <span class="o">:=</span>
<span class="n">linear_map</span><span class="bp">.</span><span class="n">comp</span> <span class="bp">⟨</span><span class="n">g</span><span class="bp">.</span><span class="n">comp</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">ext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">g</span><span class="bp">.</span><span class="n">map_add</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="bp">λ</span> <span class="n">c</span> <span class="n">x</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">ext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">g</span><span class="bp">.</span><span class="n">map_smul</span> <span class="bp">_</span> <span class="bp">_⟩</span> <span class="n">f</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">comp₃_apply</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">Q</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span><span class="bp">.</span><span class="n">comp₃</span> <span class="n">g</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">end</span> <span class="n">bilinear_map</span>
</pre></div>

<a name="137097798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137097798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137097798">Kenny Lau (Nov 03 2018 at 03:37)</a>:</h4>
<p>looking good</p>

<a name="137097901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137097901" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137097901">Mario Carneiro (Nov 03 2018 at 03:41)</a>:</h4>
<p>maybe I'm spoiled, but I would hope that there was a direct way to get <code>comm</code></p>

<a name="137097902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137097902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137097902">Mario Carneiro (Nov 03 2018 at 03:41)</a>:</h4>
<p>maybe it requires the tensor product though</p>

<a name="137097943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137097943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137097943">Mario Carneiro (Nov 03 2018 at 03:42)</a>:</h4>
<p>I guess it is equivalent to saying that <code>left</code> is a linear map</p>

<a name="137098004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137098004" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137098004">Mario Carneiro (Nov 03 2018 at 03:45)</a>:</h4>
<p>If <code>apply : M -&gt; (M -&gt;l N) -&gt;l N</code> was linear we would have it</p>

<a name="137098005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137098005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137098005">Kenny Lau (Nov 03 2018 at 03:45)</a>:</h4>
<p>and if <code>comp</code> was also linear.. :P</p>

<a name="137098051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137098051" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137098051">Mario Carneiro (Nov 03 2018 at 03:46)</a>:</h4>
<p>yeah, there should be a principled way to do this using CCCs</p>

<a name="137098052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137098052" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137098052">Kenny Lau (Nov 03 2018 at 03:47)</a>:</h4>
<p>but that would be too category-theoretical for our purposes</p>

<a name="137098057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137098057" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137098057">Mario Carneiro (Nov 03 2018 at 03:47)</a>:</h4>
<p>I mean with the categories unfolded away</p>

<a name="137098062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137098062" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137098062">Mario Carneiro (Nov 03 2018 at 03:48)</a>:</h4>
<p>We know that CCCs interpret lambda calculus, so literally anything you can write down that is type correct will be linear</p>

<a name="137098104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137098104" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137098104">Mario Carneiro (Nov 03 2018 at 03:48)</a>:</h4>
<p>we just need the right building blocks to get everything else</p>

<a name="137098106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137098106" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137098106">Kenny Lau (Nov 03 2018 at 03:49)</a>:</h4>
<p>but we also know that lambda calculus is generated by abstraction and application?</p>

<a name="137098113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137098113" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137098113">Mario Carneiro (Nov 03 2018 at 03:49)</a>:</h4>
<p>yes</p>

<a name="137098114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137098114" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137098114">Kenny Lau (Nov 03 2018 at 03:49)</a>:</h4>
<p>but abstraction isn't a linear map?</p>

<a name="137098116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137098116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137098116">Mario Carneiro (Nov 03 2018 at 03:49)</a>:</h4>
<p>That's <code>apply</code></p>

<a name="137098159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137098159" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137098159">Kenny Lau (Nov 03 2018 at 03:50)</a>:</h4>
<p>so what's the conclusion?</p>

<a name="137098162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137098162" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137098162">Mario Carneiro (Nov 03 2018 at 03:50)</a>:</h4>
<p>er, no - abstraction is the UMP of apply</p>

<a name="137098170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137098170" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137098170">Mario Carneiro (Nov 03 2018 at 03:51)</a>:</h4>
<p>it works because the families we are considering are themselves linear in their free variables</p>

<a name="137098173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137098173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137098173">Mario Carneiro (Nov 03 2018 at 03:51)</a>:</h4>
<p>so you get a "lambda" like operator</p>

<a name="137098216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137098216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137098216">Mario Carneiro (Nov 03 2018 at 03:52)</a>:</h4>
<p>In this context we wouldn't actually be able to write down lambda, because we have "the wrong lambda", it isn't linear because we don't have the right notion of family for the category</p>

<a name="137098221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137098221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137098221">Mario Carneiro (Nov 03 2018 at 03:53)</a>:</h4>
<p>but we can run any lambda term through the CCC translation to get a term using only CCC primitives, and we can prove these are all linear</p>

<a name="137103669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137103669" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137103669">Johan Commelin (Nov 03 2018 at 07:25)</a>:</h4>
<p>I really like where this is going! Keep up the good work!</p>

<a name="137104926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137104926" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137104926">Kevin Buzzard (Nov 03 2018 at 08:14)</a>:</h4>
<p>Yes many thanks Kenny for trying to get the show back on the road. Does this stuff compile yet? Is it worth going back to Hilbert basis theorem yet?</p>

<a name="137110271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137110271" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137110271">Kenny Lau (Nov 03 2018 at 11:39)</a>:</h4>
<p>Fixed</p>

<a name="137110475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137110475" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137110475">Kenny Lau (Nov 03 2018 at 11:46)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> what's the next step?</p>

<a name="137110481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137110481" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137110481">Mario Carneiro (Nov 03 2018 at 11:47)</a>:</h4>
<p>is it compiling now?</p>

<a name="137110485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137110485" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137110485">Kenny Lau (Nov 03 2018 at 11:47)</a>:</h4>
<p>yes</p>

<a name="137110524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137110524" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137110524">Mario Carneiro (Nov 03 2018 at 11:48)</a>:</h4>
<p>sweet</p>

<a name="137110532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137110532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137110532">Mario Carneiro (Nov 03 2018 at 11:49)</a>:</h4>
<p>unfortunately I still need to finish and review it myself, so it's in the queue with the other PRs now</p>

<a name="137110546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137110546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137110546">Mario Carneiro (Nov 03 2018 at 11:49)</a>:</h4>
<p>If things go well I will have time this weekend for it</p>

<a name="137110590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137110590" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137110590">Kenny Lau (Nov 03 2018 at 11:50)</a>:</h4>
<p>nice</p>

<a name="137110591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137110591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137110591">Mario Carneiro (Nov 03 2018 at 11:50)</a>:</h4>
<p>but if you see any other ways to improve it, add more theorems etc, now's the time</p>

<a name="137110605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137110605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137110605">Mario Carneiro (Nov 03 2018 at 11:51)</a>:</h4>
<p>the CCC laws seem like a good place to start</p>

<a name="137110608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137110608" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137110608">Mario Carneiro (Nov 03 2018 at 11:51)</a>:</h4>
<p>prove that <code>curry : (A X B -&gt; C) -&gt; (A -&gt; B -&gt; C)</code> is a linear map</p>

<a name="137110655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137110655" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137110655">Mario Carneiro (Nov 03 2018 at 11:52)</a>:</h4>
<p>an equiv, even</p>

<a name="137110661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137110661" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137110661">Kenny Lau (Nov 03 2018 at 11:53)</a>:</h4>
<p>ok</p>

<a name="137110702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137110702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137110702">Kenny Lau (Nov 03 2018 at 11:54)</a>:</h4>
<p>I don't think that's true</p>

<a name="137110907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137110907" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137110907">Mario Carneiro (Nov 03 2018 at 12:01)</a>:</h4>
<p>put <code>l</code> everywhere</p>

<a name="137110908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137110908" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137110908">Mario Carneiro (Nov 03 2018 at 12:01)</a>:</h4>
<p>that's homs in the category</p>

<a name="137110950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137110950" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137110950">Kenny Lau (Nov 03 2018 at 12:02)</a>:</h4>
<p>it's <code>(M tensor N) -&gt; P</code> equiv <code>M -&gt; (N -&gt; P)</code></p>

<a name="137111063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137111063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137111063">Kenny Lau (Nov 03 2018 at 12:06)</a>:</h4>
<div class="codehilite"><pre><span></span>1. (M ⊗ N) ⊗ P -&gt; M ⊗ (N ⊗ P)
2. (M ⊗ N) -&gt; P -&gt; M ⊗ (N ⊗ P)
3. P -&gt; (M ⊗ N) -&gt; M ⊗ (N ⊗ P)
4. P -&gt; M -&gt; N -&gt; M ⊗ (N ⊗ P)
5. M -&gt; P -&gt; N -&gt; M ⊗ (N ⊗ P)
6. M -&gt; N -&gt; P -&gt; M ⊗ (N ⊗ P)
7. M -&gt; N ⊗ P -&gt; M ⊗ (N ⊗ P)
````
</pre></div>

<a name="137111403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137111403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137111403">Mario Carneiro (Nov 03 2018 at 12:18)</a>:</h4>
<p>yes</p>

<a name="137111408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137111408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137111408">Mario Carneiro (Nov 03 2018 at 12:19)</a>:</h4>
<p>linear equiv I assume</p>

<a name="137111419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137111419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137111419">Mario Carneiro (Nov 03 2018 at 12:19)</a>:</h4>
<p>But I chose that one specifically because it's one of the CCC primitives</p>

<a name="137111422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137111422" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137111422">Johan Commelin (Nov 03 2018 at 12:19)</a>:</h4>
<p><em>canonical</em> linear equiv, even... <span class="emoji emoji-1f601" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span></p>

<a name="137111473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137111473" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137111473">Mario Carneiro (Nov 03 2018 at 12:20)</a>:</h4>
<p><code>apply</code> is another: <code>(M -&gt; N) X M -&gt; N</code></p>

<a name="137111476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137111476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137111476">Mario Carneiro (Nov 03 2018 at 12:21)</a>:</h4>
<p>it's trivial with that equiv though</p>

<a name="137111486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137111486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137111486">Mario Carneiro (Nov 03 2018 at 12:21)</a>:</h4>
<p>I think the hom adjunction is equivalent to a few terms that you can compose</p>

<a name="137111490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137111490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137111490">Mario Carneiro (Nov 03 2018 at 12:21)</a>:</h4>
<p>like apply and curry</p>

<a name="137111532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137111532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137111532">Mario Carneiro (Nov 03 2018 at 12:22)</a>:</h4>
<p>do we have everything we need for the tensor product to be a product?</p>

<a name="137111538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137111538" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137111538">Mario Carneiro (Nov 03 2018 at 12:22)</a>:</h4>
<p>Is it also the coproduct?</p>

<a name="137111546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137111546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137111546">Johan Commelin (Nov 03 2018 at 12:23)</a>:</h4>
<p>Nope</p>

<a name="137111550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137111550" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137111550">Johan Commelin (Nov 03 2018 at 12:23)</a>:</h4>
<p>Coproduct is the direct sum, which is also the product</p>

<a name="137111594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137111594" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137111594">Johan Commelin (Nov 03 2018 at 12:24)</a>:</h4>
<p>Tensor product is in fact the coproduct in the category of commutative rings</p>

<a name="137111617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137111617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137111617">Kevin Buzzard (Nov 03 2018 at 12:25)</a>:</h4>
<p>Yes but for modules over a commutative ring it's a different story. You can see something funny is going on because there aren't natural maps from M to M tensor N or from M tensor N to M</p>

<a name="137111643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137111643" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137111643">Kevin Buzzard (Nov 03 2018 at 12:26)</a>:</h4>
<p>Other than the zero map</p>

<a name="137111668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137111668" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137111668">Mario Carneiro (Nov 03 2018 at 12:26)</a>:</h4>
<p>wait what?</p>

<a name="137111674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137111674" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137111674">Mario Carneiro (Nov 03 2018 at 12:27)</a>:</h4>
<p>this is a funny product indeed</p>

<a name="137112176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137112176" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137112176">Kenny Lau (Nov 03 2018 at 12:42)</a>:</h4>
<div class="codehilite"><pre><span></span>1. (M ⊗ N) ⊗ P -&gt; M ⊗ (N ⊗ P)
2. (M ⊗ N) -&gt; P -&gt; M ⊗ (N ⊗ P)
3. M -&gt; N -&gt; P -&gt; M ⊗ (N ⊗ P)
4. M -&gt; N ⊗ P -&gt; M ⊗ (N ⊗ P)
</pre></div>

<a name="137112714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137112714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137112714">Kenny Lau (Nov 03 2018 at 13:01)</a>:</h4>
<p><code>(N ≃ₗ P) -&gt; ((M →ₗ N) ≃ₗ (M →ₗ P))</code></p>

<a name="137112878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137112878" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137112878">Johan Commelin (Nov 03 2018 at 13:07)</a>:</h4>
<p>Are you listing the things that you are currently proving?</p>

<a name="137113439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137113439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137113439">Mario Carneiro (Nov 03 2018 at 13:26)</a>:</h4>
<p>I think he's just enumerating type correct statements and looking for inhabited types?</p>

<a name="137113487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137113487" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137113487">Johan Commelin (Nov 03 2018 at 13:28)</a>:</h4>
<p>Do we have <code>dual</code>?</p>

<a name="137113493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137113493" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137113493">Johan Commelin (Nov 03 2018 at 13:29)</a>:</h4>
<p>Because <code>M.dual \otimes N = Hom(M,N)</code> might be an interesting statement...</p>

<a name="137113504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137113504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137113504">Kenny Lau (Nov 03 2018 at 13:29)</a>:</h4>
<p>that's just <code>M -&gt;L R</code></p>

<a name="137113549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137113549" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137113549">Kenny Lau (Nov 03 2018 at 13:30)</a>:</h4>
<p>and what you said is only true for M finitely dimensional vector space</p>

<a name="137113551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137113551" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137113551">Johan Commelin (Nov 03 2018 at 13:30)</a>:</h4>
<p>Of course, but it is a useful concept.</p>

<a name="137113555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137113555" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137113555">Johan Commelin (Nov 03 2018 at 13:30)</a>:</h4>
<p>I'm probably missing some hypotheses...</p>

<a name="137113557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137113557" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137113557">Mario Carneiro (Nov 03 2018 at 13:30)</a>:</h4>
<p>don't let truth get in the way of beauty</p>

<a name="137114111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114111">Kenny Lau (Nov 03 2018 at 13:51)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">protected</span> <span class="n">def</span> <span class="n">assoc</span> <span class="o">:</span> <span class="o">(</span><span class="n">M</span> <span class="err">⊗</span> <span class="n">N</span><span class="o">)</span> <span class="err">⊗</span> <span class="n">P</span> <span class="err">≃ₗ</span> <span class="n">M</span> <span class="err">⊗</span> <span class="o">(</span><span class="n">N</span> <span class="err">⊗</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">linear_equiv</span><span class="bp">.</span><span class="n">of_linear</span>
  <span class="o">(</span><span class="n">lift</span> <span class="err">$</span> <span class="n">lift</span> <span class="err">$</span> <span class="n">comp</span> <span class="o">(</span><span class="n">unlift&#39;</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="err">$</span> <span class="n">unlift</span> <span class="n">id</span><span class="o">)</span>
  <span class="o">(</span><span class="n">lift</span> <span class="err">$</span> <span class="n">comp</span> <span class="o">(</span><span class="n">lift&#39;</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="err">$</span> <span class="n">unlift</span> <span class="err">$</span> <span class="n">unlift</span> <span class="n">id</span><span class="o">)</span>
  <span class="o">(</span><span class="n">lift</span><span class="bp">.</span><span class="n">ext&#39;</span> <span class="err">$</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">ext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">lift</span><span class="bp">.</span><span class="n">ext&#39;</span> <span class="err">$</span> <span class="n">bilinear_map</span><span class="bp">.</span><span class="n">ext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">n</span> <span class="n">p</span><span class="o">,</span>
    <span class="k">by</span> <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">lift</span><span class="bp">.</span><span class="n">tmul</span> <span class="bp">&lt;|&gt;</span> <span class="n">rw</span> <span class="n">comp₃_apply</span> <span class="bp">&lt;|&gt;</span> <span class="n">rw</span> <span class="n">comp_apply</span> <span class="bp">&lt;|&gt;</span> <span class="n">rw</span> <span class="n">mk_apply</span> <span class="bp">&lt;|&gt;</span>
        <span class="n">rw</span> <span class="n">lift&#39;_apply</span> <span class="bp">&lt;|&gt;</span> <span class="n">rw</span> <span class="n">comm&#39;_apply</span> <span class="bp">&lt;|&gt;</span> <span class="n">rw</span> <span class="n">unlift_apply</span> <span class="bp">&lt;|&gt;</span> <span class="n">rw</span> <span class="n">unlift&#39;_apply</span> <span class="bp">&lt;|&gt;</span> <span class="n">rw</span> <span class="n">id_apply</span> <span class="o">})</span>
  <span class="o">(</span><span class="n">lift</span><span class="bp">.</span><span class="n">ext&#39;</span> <span class="err">$</span> <span class="n">comm_inj</span> <span class="err">$</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">ext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">lift</span><span class="bp">.</span><span class="n">ext&#39;</span> <span class="err">$</span> <span class="n">bilinear_map</span><span class="bp">.</span><span class="n">ext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span>
    <span class="k">by</span> <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">lift</span><span class="bp">.</span><span class="n">tmul</span> <span class="bp">&lt;|&gt;</span> <span class="n">rw</span> <span class="n">comp₃_apply</span> <span class="bp">&lt;|&gt;</span> <span class="n">rw</span> <span class="n">comp_apply</span> <span class="bp">&lt;|&gt;</span> <span class="n">rw</span> <span class="n">comm_apply</span> <span class="bp">&lt;|&gt;</span> <span class="n">rw</span> <span class="n">mk_apply</span> <span class="bp">&lt;|&gt;</span>
        <span class="n">rw</span> <span class="n">lift&#39;_apply</span> <span class="bp">&lt;|&gt;</span> <span class="n">rw</span> <span class="n">comm&#39;_apply</span> <span class="bp">&lt;|&gt;</span> <span class="n">rw</span> <span class="n">unlift_apply</span> <span class="bp">&lt;|&gt;</span> <span class="n">rw</span> <span class="n">unlift&#39;_apply</span> <span class="bp">&lt;|&gt;</span> <span class="n">rw</span> <span class="n">id_apply</span> <span class="o">})</span>
</pre></div>

<a name="137114113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114113" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114113">Johan Commelin (Nov 03 2018 at 13:51)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> How far are we from defining the category of commutative <code>R</code>-algebras?</p>

<a name="137114114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114114" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114114">Kenny Lau (Nov 03 2018 at 13:51)</a>:</h4>
<p>oh well</p>

<a name="137114116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114116">Kenny Lau (Nov 03 2018 at 13:51)</a>:</h4>
<p>what's the concrete version of your question?</p>

<a name="137114155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114155">Johan Commelin (Nov 03 2018 at 13:52)</a>:</h4>
<p>Flat ring homs</p>

<a name="137114159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114159" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114159">Kenny Lau (Nov 03 2018 at 13:52)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">bilinear_map</span> <span class="o">:=</span> <span class="n">M</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">N</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">P</span>
</pre></div>

<a name="137114160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114160">Kenny Lau (Nov 03 2018 at 13:52)</a>:</h4>
<p>should we just remove <code>bilinear_map</code> entirely?</p>

<a name="137114169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114169" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114169">Johan Commelin (Nov 03 2018 at 13:53)</a>:</h4>
<p>I think we can leave it out till people start complaining.</p>

<a name="137114173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114173">Johan Commelin (Nov 03 2018 at 13:53)</a>:</h4>
<p>I would encourage everyone to use linear maps out of the tensor product.</p>

<a name="137114231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114231">Johan Commelin (Nov 03 2018 at 13:55)</a>:</h4>
<p>Anyway, I would be really happy if we have flat ring homs. Especially if it is readable, instead of the obfuscated kludge that we sometimes see... I think flat ring homs can be a good test case to see if mathlib is ready for the 25 other properties of ring homs that algebraic geometry depends upon.</p>

<a name="137114271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114271" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114271">Kenny Lau (Nov 03 2018 at 13:56)</a>:</h4>
<p>what are the 25 other properties?</p>

<a name="137114278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114278" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114278">Kenny Lau (Nov 03 2018 at 13:58)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">map</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span> <span class="n">M</span> <span class="err">⊗</span> <span class="n">N</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">P</span> <span class="err">⊗</span> <span class="n">Q</span> <span class="o">:=</span>
<span class="n">lift</span> <span class="err">$</span> <span class="n">comp₁</span> <span class="o">(</span><span class="n">comp₂</span> <span class="o">(</span><span class="n">mk</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="n">g</span><span class="o">)</span> <span class="n">f</span>
</pre></div>


<p>man my interface is really good</p>

<a name="137114317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114317">Johan Commelin (Nov 03 2018 at 13:58)</a>:</h4>
<p><a href="https://stacks.math.columbia.edu/tag/02WE" target="_blank" title="https://stacks.math.columbia.edu/tag/02WE">https://stacks.math.columbia.edu/tag/02WE</a> most of these have an equivalent for rings</p>

<a name="137114408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114408">Kenny Lau (Nov 03 2018 at 14:01)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">map</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span> <span class="n">M</span> <span class="err">⊗</span> <span class="n">N</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">P</span> <span class="err">⊗</span> <span class="n">Q</span> <span class="o">:=</span>
<span class="n">lift</span> <span class="err">$</span> <span class="n">comp₁</span> <span class="o">(</span><span class="n">comp₂</span> <span class="o">(</span><span class="n">mk</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="n">g</span><span class="o">)</span> <span class="n">f</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">map_tmul</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span><span class="err">ₗ</span> <span class="n">Q</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">map</span> <span class="n">f</span> <span class="n">g</span> <span class="o">(</span><span class="n">m</span> <span class="err">⊗ₜ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">m</span> <span class="err">⊗ₜ</span> <span class="n">g</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">rfl</span>
</pre></div>


<p>how on earth is this <code>rfl</code></p>

<a name="137114472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114472">Mario Carneiro (Nov 03 2018 at 14:02)</a>:</h4>
<p>of course it is, it's a quotient</p>

<a name="137114480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114480">Kenny Lau (Nov 03 2018 at 14:03)</a>:</h4>
<p>well then why isn't this <code>rfl</code>:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">lift</span><span class="bp">.</span><span class="n">tmul</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">lift</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="err">⊗ₜ</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
</pre></div>

<a name="137114580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114580" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114580">Kenny Lau (Nov 03 2018 at 14:06)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">lift</span><span class="bp">.</span><span class="n">tmul</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">lift</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="err">⊗ₜ</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="n">zero_add</span> <span class="bp">_</span>
</pre></div>

<a name="137114583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114583" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114583">Kenny Lau (Nov 03 2018 at 14:06)</a>:</h4>
<p>I guess that's why</p>

<a name="137114587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114587" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114587">Mario Carneiro (Nov 03 2018 at 14:06)</a>:</h4>
<p>where'd that come from?</p>

<a name="137114639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114639" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114639">Kenny Lau (Nov 03 2018 at 14:08)</a>:</h4>
<p>the free group</p>

<a name="137114640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114640" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114640">Chris Hughes (Nov 03 2018 at 14:08)</a>:</h4>
<blockquote>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">lift</span><span class="bp">.</span><span class="n">tmul</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">lift</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="err">⊗ₜ</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="n">zero_add</span> <span class="bp">_</span>
</pre></div>


</blockquote>
<p>I love proofs like this.</p>

<a name="137114643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114643" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114643">Mario Carneiro (Nov 03 2018 at 14:08)</a>:</h4>
<p><code>free_abelian_group.lift</code> also isn't <code>rfl</code></p>

<a name="137114655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114655" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114655">Kenny Lau (Nov 03 2018 at 14:09)</a>:</h4>
<p>right</p>

<a name="137114656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114656">Kenny Lau (Nov 03 2018 at 14:09)</a>:</h4>
<p>it's zero_add as well</p>

<a name="137114700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114700" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114700">Mario Carneiro (Nov 03 2018 at 14:10)</a>:</h4>
<p>but why? It's built out of pieces that are rfl</p>

<a name="137114702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114702">Mario Carneiro (Nov 03 2018 at 14:10)</a>:</h4>
<p>is it <code>free_group.to_group</code>?</p>

<a name="137114716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114716" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114716">Mario Carneiro (Nov 03 2018 at 14:11)</a>:</h4>
<p>ah yes</p>

<a name="137114756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114756" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114756">Mario Carneiro (Nov 03 2018 at 14:12)</a>:</h4>
<div class="codehilite"><pre><span></span>def to_group.aux : list (α × bool) → β :=
λ L, list.prod $ L.map $ λ x, cond x.2 (f x.1) (f x.1)⁻¹

def to_group : free_group α → β :=
quot.lift (to_group.aux f) $ λ L₁ L₂ H, red.step.to_group H
</pre></div>

<a name="137114760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114760" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114760">Mario Carneiro (Nov 03 2018 at 14:12)</a>:</h4>
<div class="codehilite"><pre><span></span>@[simp] lemma to_group.of {x} : to_group f (of x) = f x :=
one_mul _
</pre></div>

<a name="137114810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114810">Kenny Lau (Nov 03 2018 at 14:14)</a>:</h4>
<p>so it's all in <code>list.prod</code></p>

<a name="137114879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114879" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114879">Kenny Lau (Nov 03 2018 at 14:17)</a>:</h4>
<p>under which semantics is <code>by simp; simp only [linear_equiv.apply_symm_apply]</code> supposed to work where <code>by simp [linear_equiv.apply_symm_apply]</code> fails?</p>

<a name="137114881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114881" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114881">Mario Carneiro (Nov 03 2018 at 14:17)</a>:</h4>
<p>lol, now this has got me thinking about rewriting <code>free_group</code> again</p>

<a name="137114931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114931" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114931">Mario Carneiro (Nov 03 2018 at 14:19)</a>:</h4>
<p>one way to get the right defeqs here is to have the actual definition of <code>free_group</code> be the quotient of expressions in the language of groups with the group laws, and then prove that this is isomorphic to lists</p>

<a name="137114932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114932" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114932">Kenny Lau (Nov 03 2018 at 14:19)</a>:</h4>
<p>and how would one implement "expressions"?</p>

<a name="137114933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114933" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114933">Mario Carneiro (Nov 03 2018 at 14:19)</a>:</h4>
<p>expressions in the language of groups means trees</p>

<a name="137114935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114935" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114935">Mario Carneiro (Nov 03 2018 at 14:19)</a>:</h4>
<p>you just have a symbol for one and inv and mul</p>

<a name="137114977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114977" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114977">Mario Carneiro (Nov 03 2018 at 14:20)</a>:</h4>
<p>and the basis elements</p>

<a name="137114979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114979" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114979">Mario Carneiro (Nov 03 2018 at 14:20)</a>:</h4>
<p>and you get trees</p>

<a name="137114980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114980" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114980">Kenny Lau (Nov 03 2018 at 14:20)</a>:</h4>
<p>and what do you mean by tree?</p>

<a name="137114987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114987" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114987">Mario Carneiro (Nov 03 2018 at 14:20)</a>:</h4>
<div class="codehilite"><pre><span></span>inductive group_expr (A) : Type
| one : group_expr
| inv : group_expr -&gt; group_expr
| mul : group_expr -&gt; group_expr -&gt; group_expr
</pre></div>

<a name="137114999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137114999" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137114999">Kenny Lau (Nov 03 2018 at 14:21)</a>:</h4>
<p>aha</p>

<a name="137115007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115007">Kenny Lau (Nov 03 2018 at 14:21)</a>:</h4>
<p>how would that help?</p>

<a name="137115008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115008">Mario Carneiro (Nov 03 2018 at 14:21)</a>:</h4>
<p>if you define this as  an inductive, and define the relations as a quotient, you will get really nice defeq</p>

<a name="137115051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115051" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115051">Mario Carneiro (Nov 03 2018 at 14:22)</a>:</h4>
<p><code>lift (x * y) = lift x * lift y</code>, <code>lift 1 = 1</code>, <code>lift x = f x</code></p>

<a name="137115052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115052" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115052">Kenny Lau (Nov 03 2018 at 14:22)</a>:</h4>
<p>I don't see how this is different from redefining <code>list.prod</code> so that <code>list.prod [f]</code> is definitionally equivalent to <code>f</code>?</p>

<a name="137115054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115054">Kenny Lau (Nov 03 2018 at 14:22)</a>:</h4>
<p>oh</p>

<a name="137115056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115056">Kenny Lau (Nov 03 2018 at 14:22)</a>:</h4>
<p>fair enough</p>

<a name="137115068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115068">Johan Commelin (Nov 03 2018 at 14:23)</a>:</h4>
<blockquote>
<p>one way to get the right defeqs here is to have the actual definition of <code>free_group</code> be the quotient of expressions in the language of groups with the group laws, and then prove that this is isomorphic to lists</p>
</blockquote>
<p>Wait... in the other thread you said we shouldn't focus on getting all the right defeqs... <span class="emoji emoji-2639" title="sad">:sad:</span></p>

<a name="137115069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115069">Mario Carneiro (Nov 03 2018 at 14:23)</a>:</h4>
<p>lol</p>

<a name="137115071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115071">Mario Carneiro (Nov 03 2018 at 14:23)</a>:</h4>
<p>sometimes it matters</p>

<a name="137115081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115081" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115081">Mario Carneiro (Nov 03 2018 at 14:24)</a>:</h4>
<p>The reason quotient types exist is because of defeqs</p>

<a name="137115116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115116">Mario Carneiro (Nov 03 2018 at 14:24)</a>:</h4>
<p>otherwise we would just use sets of sets</p>

<a name="137115127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115127" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115127">Johan Commelin (Nov 03 2018 at 14:25)</a>:</h4>
<p>/me doesn't follow... noob alert...</p>

<a name="137115130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115130" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115130">Mario Carneiro (Nov 03 2018 at 14:25)</a>:</h4>
<p>there is no way to build quotient types like lean's without an axiom</p>

<a name="137115169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115169" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115169">Mario Carneiro (Nov 03 2018 at 14:26)</a>:</h4>
<p>we can get something provably isomorphic, but it won't have the defeq on lift</p>

<a name="137115173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115173">Johan Commelin (Nov 03 2018 at 14:26)</a>:</h4>
<p>I probably haven't experience the pain of working without lean's quotient types... what is wrong with sets of sets?</p>

<a name="137115182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115182" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115182">Mario Carneiro (Nov 03 2018 at 14:27)</a>:</h4>
<p>It allows you to define functions that have a certain behavior by definition on the basis elements</p>

<a name="137115224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115224" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115224">Mario Carneiro (Nov 03 2018 at 14:28)</a>:</h4>
<p>You can live without defeq, in set theory they do this</p>

<a name="137115225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115225" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115225">Kenny Lau (Nov 03 2018 at 14:28)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> so, are you going to do it, or do you intend me to do it? :P</p>

<a name="137115226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115226" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115226">Mario Carneiro (Nov 03 2018 at 14:28)</a>:</h4>
<p>but it is nice to have for computational purposes</p>

<a name="137115235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115235">Mario Carneiro (Nov 03 2018 at 14:29)</a>:</h4>
<p>I think I have enough major projects to do :) Like Johan says, it's not essential</p>

<a name="137115237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115237" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115237">Kenny Lau (Nov 03 2018 at 14:29)</a>:</h4>
<p>ok</p>

<a name="137115239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115239">Mario Carneiro (Nov 03 2018 at 14:29)</a>:</h4>
<p>but if it interests you, feel free</p>

<a name="137115242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115242" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115242">Johan Commelin (Nov 03 2018 at 14:30)</a>:</h4>
<p>I encourage both of you to first get this merged into mathlib before embarking on new projects...</p>

<a name="137115287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115287">Johan Commelin (Nov 03 2018 at 14:30)</a>:</h4>
<p>(or expanding the scope of this refactor)</p>

<a name="137115306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115306" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115306">Kenny Lau (Nov 03 2018 at 14:31)</a>:</h4>
<p>ok I pushed the tensor product</p>

<a name="137115308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115308" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115308">Kenny Lau (Nov 03 2018 at 14:31)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> should we PR it now?</p>

<a name="137115350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115350" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115350">Mario Carneiro (Nov 03 2018 at 14:32)</a>:</h4>
<p>sure, that will give it more exposure</p>

<a name="137115356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115356" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115356">Kenny Lau (Nov 03 2018 at 14:33)</a>:</h4>
<p>more exposure to what?</p>

<a name="137115365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115365" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115365">Mario Carneiro (Nov 03 2018 at 14:33)</a>:</h4>
<p>people with ideas</p>

<a name="137115406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115406" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115406">Mario Carneiro (Nov 03 2018 at 14:34)</a>:</h4>
<p>or who like to read about new things on github</p>

<a name="137115409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115409" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115409">Mario Carneiro (Nov 03 2018 at 14:34)</a>:</h4>
<p>obviously I'm already aware of this PR, and I will merge it when ready</p>

<a name="137115420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115420">Kenny Lau (Nov 03 2018 at 14:35)</a>:</h4>
<p>and when is it ready?</p>

<a name="137115514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115514" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115514">Mario Carneiro (Nov 03 2018 at 14:38)</a>:</h4>
<p>when I am satisfied with all the changes? It was unfinished when I last reviewed it</p>

<a name="137115519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137115519" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137115519">Mario Carneiro (Nov 03 2018 at 14:39)</a>:</h4>
<p>thank you for fixing the bugs, but some things still take time</p>

<a name="137120657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137120657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137120657">Patrick Massot (Nov 03 2018 at 16:57)</a>:</h4>
<p>Thank you very much <span class="user-mention" data-user-id="110064">@Kenny Lau</span> for the documentation effort (and help with actual Lean)! Should we already copy that to <a href="https://github.com/leanprover/mathlib/blob/master/docs/theories/linear_algebra.md" target="_blank" title="https://github.com/leanprover/mathlib/blob/master/docs/theories/linear_algebra.md">docs/theories/linear_algebra</a> or could it still change?</p>

<a name="137120659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137120659" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137120659">Kenny Lau (Nov 03 2018 at 16:58)</a>:</h4>
<p>It could still change</p>

<a name="137120699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137120699" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137120699">Patrick Massot (Nov 03 2018 at 16:58)</a>:</h4>
<p>Ok. It would be very useful if you could update it when it will stabilize, so that we'll be able to incorporate it to the docs</p>

<a name="137130652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137130652" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137130652">Kenny Lau (Nov 03 2018 at 22:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> ok I pushed the refactored <code>free_group.lean</code></p>

<a name="137130654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137130654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137130654">Kenny Lau (Nov 03 2018 at 22:11)</a>:</h4>
<p>(it won't build now; I'll fix the errors if you like the new <code>free_group</code>)</p>

<a name="137131106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137131106" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137131106">Kenny Lau (Nov 03 2018 at 22:27)</a>:</h4>
<p>also, I don't understand why it is ok that <code>linear_map</code> doesn't take the ring as an argument</p>

<a name="137131918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137131918" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137131918">Kenny Lau (Nov 03 2018 at 22:57)</a>:</h4>
<p>ok I put the free group in <a href="https://github.com/leanprover-community/mathlib/tree/module-with-free-group" target="_blank" title="https://github.com/leanprover-community/mathlib/tree/module-with-free-group">a new branch</a> and resetted the PR'ed branch</p>

<a name="137166041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137166041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137166041">Kevin Buzzard (Nov 04 2018 at 18:21)</a>:</h4>
<p>So I thought I'd try and get the hang of modules in Lean. Is this construction somewhere in the module branch:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">S</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">f</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">HM</span> <span class="o">:</span> <span class="n">module</span> <span class="n">S</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>?</p>

<a name="137166228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137166228" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137166228">Kevin Buzzard (Nov 04 2018 at 18:27)</a>:</h4>
<p>Idly trying to prove it myself:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">S</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">f</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">HM</span> <span class="o">:</span> <span class="n">module</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul_add</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">add_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">zero_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">smul_zero</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="o">}</span>
<span class="c">/-</span><span class="cm"></span>

<span class="cm">failed to synthesize type class instance for</span>
<span class="cm">R S : Type,</span>
<span class="cm">_inst_1 : comm_ring R,</span>
<span class="cm">_inst_2 : comm_ring S,</span>
<span class="cm">f : R → S,</span>
<span class="cm">_inst_3 : is_ring_hom f,</span>
<span class="cm">M : Type,</span>
<span class="cm">_inst_4 : add_comm_group M,</span>
<span class="cm">HM : module S M</span>
<span class="cm">⊢ has_scalar R M</span>

<span class="cm">-/</span>
</pre></div>

<a name="137166337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137166337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137166337">Chris Hughes (Nov 04 2018 at 18:30)</a>:</h4>
<p>It's a new structure. Don't you just have to define a <code>has_scalar</code> instance first?</p>

<a name="137166359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137166359" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137166359">Kevin Buzzard (Nov 04 2018 at 18:31)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">instance</span> <span class="n">has_scalar_of_ring_hom</span> <span class="o">(</span><span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">S</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">f</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">has_scalar</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
<span class="n">has_scalar</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">m</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">r</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span>
<span class="o">}</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">S</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">f</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">HM</span> <span class="o">:</span> <span class="n">module</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul_add</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">add_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">zero_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">smul_zero</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="o">}</span>
<span class="c1">-- maximum class-instance resolution depth has been reached</span>
</pre></div>


<p>My question is whether this is already in the module refactoring, which I think was to a certain extent inspired by the fact that this used to be hard to do</p>

<a name="137166407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137166407" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137166407">Chris Hughes (Nov 04 2018 at 18:33)</a>:</h4>
<p>I don't think type class inference knows how to infer <code>f</code>. Try making the first things a def, and then giving <code>to_has_scalar</code> or whatever explicitly. Thinking about it, I don't think the second thing can be an instance with the current setup either.</p>

<a name="137166579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137166579" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137166579">Kevin Buzzard (Nov 04 2018 at 18:39)</a>:</h4>
<p>Oh this is exactly one of those situations where I don't know how to put something into the type class inference machine because I'm in term mode.</p>

<a name="137166582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137166582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137166582">Chris Hughes (Nov 04 2018 at 18:39)</a>:</h4>
<p><code>by haveI := _; exact _</code></p>

<a name="137166634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137166634" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137166634">Kevin Buzzard (Nov 04 2018 at 18:40)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">def</span> <span class="n">has_scalar_of_ring_hom</span> <span class="o">(</span><span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">S</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">f</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">has_scalar</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
<span class="n">has_scalar</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">m</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">r</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span>
<span class="o">}</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">S</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">f</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">HM</span> <span class="o">:</span> <span class="n">module</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
  <span class="k">begin</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">has_scalar_of_ring_hom</span> <span class="n">R</span> <span class="n">S</span> <span class="n">f</span> <span class="n">M</span><span class="o">,</span>
  <span class="n">exact</span>
<span class="o">{</span> <span class="n">smul_add</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">add_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">zero_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">smul_zero</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="137166635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137166635" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137166635">Kevin Buzzard (Nov 04 2018 at 18:40)</a>:</h4>
<p>no errors :D</p>

<a name="137166642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137166642" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137166642">Kevin Buzzard (Nov 04 2018 at 18:40)</a>:</h4>
<p>so I have to go into tactic mode to put something into the type class inference machine?</p>

<a name="137166648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137166648" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137166648">Chris Hughes (Nov 04 2018 at 18:41)</a>:</h4>
<p>I think so.</p>

<a name="137166690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137166690" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137166690">Chris Hughes (Nov 04 2018 at 18:42)</a>:</h4>
<p>This should also work I think.</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">S</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">f</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">HM</span> <span class="o">:</span> <span class="n">module</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_has_scalar</span> <span class="o">:=</span> <span class="n">has_scalar_of_ring_hom</span> <span class="n">R</span> <span class="n">S</span> <span class="n">f</span> <span class="n">M</span><span class="o">,</span>
  <span class="n">smul_add</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">add_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">zero_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">smul_zero</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="137166812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137166812" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137166812">Kevin Buzzard (Nov 04 2018 at 18:46)</a>:</h4>
<p>Now I have problems with two smuls. <span class="user-mention" data-user-id="110064">@Kenny Lau</span> Is this done already? I don't want to waste my time if it's already there, but this is exactly what I have always needed for Hilbert basis.</p>

<a name="137166821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137166821" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137166821">Chris Hughes (Nov 04 2018 at 18:47)</a>:</h4>
<p>I would wait until after module refactorign</p>

<a name="137166822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137166822" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137166822">Kenny Lau (Nov 04 2018 at 18:47)</a>:</h4>
<p>the right thing to do is just say smul := sorry, right</p>

<a name="137166823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137166823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137166823">Kenny Lau (Nov 04 2018 at 18:47)</a>:</h4>
<p>no, this hasn’t been done</p>

<a name="137166867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137166867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137166867">Kevin Buzzard (Nov 04 2018 at 18:48)</a>:</h4>
<p>I thought module refactoring had happened</p>

<a name="137166871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137166871" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137166871">Kenny Lau (Nov 04 2018 at 18:48)</a>:</h4>
<p>you should also read my summary of the changes, this is mentioned there</p>

<a name="137166872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137166872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137166872">Kenny Lau (Nov 04 2018 at 18:48)</a>:</h4>
<p>and also you should use module.of_core</p>

<a name="137166873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137166873" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137166873">Kenny Lau (Nov 04 2018 at 18:48)</a>:</h4>
<p>and also you should use module.of_core</p>

<a name="137166874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137166874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137166874">Kevin Buzzard (Nov 04 2018 at 18:48)</a>:</h4>
<p>I thought I had read your summary of the changes :-/</p>

<a name="137166884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137166884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137166884">Kevin Buzzard (Nov 04 2018 at 18:49)</a>:</h4>
<p>Chris your version is better:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">S</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">f</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">HM</span> <span class="o">:</span> <span class="n">module</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_has_scalar</span> <span class="o">:=</span> <span class="n">has_scalar_of_ring_hom</span> <span class="n">R</span> <span class="n">S</span> <span class="n">f</span> <span class="n">M</span><span class="o">,</span>
  <span class="n">smul_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span><span class="n">smul_add</span> <span class="o">(</span><span class="n">f</span> <span class="n">r</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="c1">-- works</span>
  <span class="n">add_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">zero_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">smul_zero</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="o">}</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">S</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">f</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">HM</span> <span class="o">:</span> <span class="n">module</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">has_scalar_of_ring_hom</span> <span class="n">R</span> <span class="n">S</span> <span class="n">f</span> <span class="n">M</span><span class="bp">;</span>
  <span class="n">exact</span>
<span class="o">{</span> <span class="n">smul_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">smul_add</span> <span class="o">(</span><span class="n">f</span> <span class="n">r</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="c1">-- fails</span>
  <span class="n">add_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">zero_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">smul_zero</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="o">}</span>
</pre></div>

<a name="137167005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137167005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137167005">Kevin Buzzard (Nov 04 2018 at 18:53)</a>:</h4>
<p>I see. I think Kenny is pointing out that by "The idiom for making an instance module α β (after proving that β is an abelian group) is module.of_core" he means the strong statement that end users should actually never make modules directly. Is that right Kenny? I still need an instance of <code>module R M</code> though -- how do I get it?</p>

<a name="137167057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137167057" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137167057">Kevin Buzzard (Nov 04 2018 at 18:55)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">S</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">f</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">HM</span> <span class="o">:</span> <span class="n">module</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">module</span><span class="bp">.</span><span class="n">of_core</span> <span class="o">{</span>
    <span class="n">smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
    <span class="n">smul_add</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
    <span class="n">add_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
    <span class="n">mul_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
    <span class="n">one_smul</span> <span class="o">:=</span> <span class="n">sorry</span>
  <span class="o">}</span>
</pre></div>


<p>Maybe I'm on the right lines now</p>

<a name="137167070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137167070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137167070">Kenny Lau (Nov 04 2018 at 18:55)</a>:</h4>
<p>right</p>

<a name="137167310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137167310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137167310">Kevin Buzzard (Nov 04 2018 at 19:02)</a>:</h4>
<div class="codehilite"><pre><span></span>    <span class="n">add_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">s</span> <span class="n">m</span><span class="o">,</span> <span class="c1">-- (is_ring_hom.map_add f).symm ▸ (add_smul (f r) (f s) m), -- stupid triangle never works for me</span>
      <span class="k">begin</span> <span class="k">show</span> <span class="n">f</span> <span class="o">(</span><span class="n">r</span> <span class="bp">+</span> <span class="n">s</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">r</span> <span class="err">•</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">s</span> <span class="err">•</span> <span class="n">m</span><span class="o">,</span> <span class="n">rw</span> <span class="n">is_ring_hom</span><span class="bp">.</span><span class="n">map_add</span> <span class="n">f</span><span class="o">,</span> <span class="n">exact</span> <span class="n">add_smul</span> <span class="o">(</span><span class="n">f</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="n">m</span><span class="o">,</span><span class="kn">end</span><span class="o">,</span>
</pre></div>

<a name="137167371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137167371" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137167371">Kenny Lau (Nov 04 2018 at 19:04)</a>:</h4>
<p>i think you are missing two arguments</p>

<a name="137167450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137167450" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137167450">Kevin Buzzard (Nov 04 2018 at 19:06)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">S</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">f</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">HM</span> <span class="o">:</span> <span class="n">module</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">module</span><span class="bp">.</span><span class="n">of_core</span> <span class="o">{</span>
    <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">m</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">r</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span><span class="o">,</span>
    <span class="n">smul_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="n">smul_add</span> <span class="err">$</span> <span class="n">f</span> <span class="n">r</span><span class="o">,</span>
    <span class="n">add_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">s</span> <span class="n">m</span><span class="o">,</span> <span class="c1">-- (is_ring_hom.map_add f).symm ▸ (add_smul (f r) (f s) m), -- stupid triangle never works for me</span>
      <span class="k">begin</span> <span class="k">show</span> <span class="n">f</span> <span class="o">(</span><span class="n">r</span> <span class="bp">+</span> <span class="n">s</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">r</span> <span class="err">•</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">s</span> <span class="err">•</span> <span class="n">m</span><span class="o">,</span> <span class="n">rw</span> <span class="n">is_ring_hom</span><span class="bp">.</span><span class="n">map_add</span> <span class="n">f</span><span class="o">,</span> <span class="n">exact</span> <span class="n">add_smul</span> <span class="o">(</span><span class="n">f</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="n">m</span><span class="o">,</span><span class="kn">end</span><span class="o">,</span>
    <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">s</span> <span class="n">m</span><span class="o">,</span> <span class="k">begin</span> <span class="k">show</span> <span class="n">f</span> <span class="o">(</span><span class="n">r</span> <span class="bp">*</span> <span class="n">s</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">r</span> <span class="err">•</span> <span class="o">(</span><span class="n">f</span> <span class="n">s</span> <span class="err">•</span> <span class="n">m</span><span class="o">),</span> <span class="n">rw</span> <span class="n">is_ring_hom</span><span class="bp">.</span><span class="n">map_mul</span> <span class="n">f</span><span class="o">,</span> <span class="n">exact</span> <span class="n">mul_smul</span> <span class="o">(</span><span class="n">f</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="n">m</span><span class="o">,</span><span class="kn">end</span><span class="o">,</span>
    <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="k">begin</span> <span class="k">show</span> <span class="n">f</span> <span class="mi">1</span> <span class="err">•</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m</span><span class="o">,</span> <span class="n">rw</span> <span class="n">is_ring_hom</span><span class="bp">.</span><span class="n">map_one</span> <span class="n">f</span><span class="o">,</span> <span class="n">exact</span> <span class="n">one_smul</span> <span class="n">m</span><span class="o">,</span> <span class="kn">end</span>
  <span class="o">}</span>
</pre></div>


<p>Still haven't lost my touch ;-) [ugh]</p>

<a name="137167457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137167457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137167457">Kevin Buzzard (Nov 04 2018 at 19:07)</a>:</h4>
<p>well so far I got 0% of the way through proving Hilbert basis, but at least I learnt not to use <code>module</code></p>

<a name="137167736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137167736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137167736">Kevin Buzzard (Nov 04 2018 at 19:16)</a>:</h4>
<p>Does this completely fundamental fact have a name?</p>
<p>Current version:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">instance</span> <span class="n">module_of_module_of_ring_hom</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">S</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ring_hom</span> <span class="n">f</span><span class="o">]</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">HM</span> <span class="o">:</span> <span class="n">module</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">module</span><span class="bp">.</span><span class="n">of_core</span> <span class="o">{</span>
    <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">m</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">r</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span><span class="o">,</span>
    <span class="n">smul_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="n">smul_add</span> <span class="err">$</span> <span class="n">f</span> <span class="n">r</span><span class="o">,</span>
    <span class="n">add_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">s</span> <span class="n">m</span><span class="o">,</span> <span class="c1">-- (@is_ring_hom.map_add _ _ _ _ f _ r s) ▸ (add_smul (f r) (f s) m), -- stupid triangle never works for me</span>
      <span class="k">begin</span> <span class="k">show</span> <span class="n">f</span> <span class="o">(</span><span class="n">r</span> <span class="bp">+</span> <span class="n">s</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">r</span> <span class="err">•</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">s</span> <span class="err">•</span> <span class="n">m</span><span class="o">,</span> <span class="n">rw</span> <span class="n">is_ring_hom</span><span class="bp">.</span><span class="n">map_add</span> <span class="n">f</span><span class="o">,</span> <span class="n">exact</span> <span class="n">add_smul</span> <span class="o">(</span><span class="n">f</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="n">m</span><span class="o">,</span><span class="kn">end</span><span class="o">,</span>
    <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">s</span> <span class="n">m</span><span class="o">,</span> <span class="k">begin</span> <span class="k">show</span> <span class="n">f</span> <span class="o">(</span><span class="n">r</span> <span class="bp">*</span> <span class="n">s</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">r</span> <span class="err">•</span> <span class="o">(</span><span class="n">f</span> <span class="n">s</span> <span class="err">•</span> <span class="n">m</span><span class="o">),</span> <span class="n">rw</span> <span class="n">is_ring_hom</span><span class="bp">.</span><span class="n">map_mul</span> <span class="n">f</span><span class="o">,</span> <span class="n">exact</span> <span class="n">mul_smul</span> <span class="o">(</span><span class="n">f</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="n">m</span><span class="o">,</span><span class="kn">end</span><span class="o">,</span>
    <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="k">begin</span> <span class="k">show</span> <span class="n">f</span> <span class="mi">1</span> <span class="err">•</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m</span><span class="o">,</span> <span class="n">rw</span> <span class="n">is_ring_hom</span><span class="bp">.</span><span class="n">map_one</span> <span class="n">f</span><span class="o">,</span> <span class="n">exact</span> <span class="n">one_smul</span> <span class="n">m</span><span class="o">,</span> <span class="kn">end</span>
  <span class="o">}</span>
</pre></div>

<a name="137167788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137167788" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137167788">Kevin Buzzard (Nov 04 2018 at 19:18)</a>:</h4>
<p>rw doesn't do unfolding (i.e. if I tell it <code>rw H</code> with <code>H : X = Y</code> and <code>X</code> isn't directly in view, it won't start unfolding things in an attempt to find <code>X</code>, even if something immediately unfolds to give <code>X</code>). Is the same true for the stupid triangle?</p>

<a name="137167790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137167790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137167790">Chris Hughes (Nov 04 2018 at 19:18)</a>:</h4>
<p>Yes. What about <code>erw</code></p>

<a name="137167798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137167798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137167798">Kevin Buzzard (Nov 04 2018 at 19:19)</a>:</h4>
<p>I still seem to need the <code>show</code> for <code>add_smul</code>.</p>

<a name="137167925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137167925" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137167925">Kevin Buzzard (Nov 04 2018 at 19:22)</a>:</h4>
<p><code>    add_smul := λ r s m, (((@is_ring_hom.map_add _ _ _ _ f _ r s).symm ▸ (add_smul (f r) (f s) m)) :  f (r + s) • m = f r • m + f s • m),</code></p>

<a name="137167926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137167926" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137167926">Kevin Buzzard (Nov 04 2018 at 19:22)</a>:</h4>
<p>longer than the tactic proof ;-)</p>

<a name="137167940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137167940" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137167940">Johan Commelin (Nov 04 2018 at 19:23)</a>:</h4>
<p>It ought to be <code>by tidy</code>.</p>

<a name="137167986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137167986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137167986">Kevin Buzzard (Nov 04 2018 at 19:24)</a>:</h4>
<p>does <code>tidy</code> know to try a theorem called <code>add_smul</code> when proving something called <code>add_smul</code>?</p>

<a name="137167991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137167991" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137167991">Johan Commelin (Nov 04 2018 at 19:24)</a>:</h4>
<p>Only if it is a simp-lemma</p>

<a name="137168005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137168005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137168005">Johan Commelin (Nov 04 2018 at 19:25)</a>:</h4>
<p>But maybe, once backwords reasoning is merged, this could realistically done by <code>tidy</code>.</p>

<a name="137168971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137168971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137168971">Kevin Buzzard (Nov 04 2018 at 19:58)</a>:</h4>
<p>Will this instance ever trigger?</p>

<a name="137170222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137170222" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137170222">Chris Hughes (Nov 04 2018 at 20:37)</a>:</h4>
<p>I doubt it. It will have to find a ring hom out of nowhere.</p>

<a name="137170360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137170360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137170360">Kenny Lau (Nov 04 2018 at 20:41)</a>:</h4>
<p>maybe we should make ring_hom just like linear_map</p>

<a name="137171588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/137171588" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#137171588">David Michael Roberts (Nov 04 2018 at 21:16)</a>:</h4>
<blockquote>
<p>is Mod(R) a CCC?</p>
</blockquote>
<p>No, because the monoidal structure is not cartesian. What you want is <a href="https://ncatlab.org/nlab/show/closed+monoidal+category" target="_blank" title="https://ncatlab.org/nlab/show/closed+monoidal+category">https://ncatlab.org/nlab/show/closed+monoidal+category</a></p>

<a name="145302840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/145302840" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#145302840">Kenny Lau (Nov 05 2018 at 06:21)</a>:</h4>
<p>(deleted)</p>

<a name="145302841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/145302841" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#145302841">Kenny Lau (Nov 05 2018 at 06:21)</a>:</h4>
<p>(deleted)</p>

<a name="145303310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/145303310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#145303310">Mario Carneiro (Nov 05 2018 at 06:35)</a>:</h4>
<p>okay, my other obligations are done, so I'm working on finishing the refactoring tonight</p>

<a name="145303430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/145303430" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#145303430">Kenny Lau (Nov 05 2018 at 06:39)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">polynomial</span>

<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">,</span> <span class="n">priority</span> <span class="mi">1</span><span class="o">]</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kn">theorem</span> <span class="n">leading_term_aux</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">nonzero_comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">Hle</span> <span class="o">:</span> <span class="n">nat_degree</span> <span class="n">f</span> <span class="bp">≤</span> <span class="n">nat_degree</span> <span class="n">g</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Hf</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">Hg</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">Hh</span> <span class="o">:</span> <span class="n">leading_coeff</span> <span class="n">f</span> <span class="bp">+</span> <span class="n">leading_coeff</span> <span class="n">g</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
<span class="n">leading_coeff</span> <span class="o">(</span><span class="n">f</span> <span class="bp">*</span> <span class="n">X</span> <span class="err">^</span> <span class="o">(</span><span class="n">nat_degree</span> <span class="n">g</span> <span class="bp">-</span> <span class="n">nat_degree</span> <span class="n">f</span><span class="o">)</span> <span class="bp">+</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="n">leading_coeff</span> <span class="n">f</span> <span class="bp">+</span> <span class="n">leading_coeff</span> <span class="n">g</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="n">def</span> <span class="n">ideal</span><span class="bp">.</span><span class="n">leading_coeff</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">nonzero_comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">ideal</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">))</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="n">leading_coeff</span> <span class="err">&#39;&#39;</span> <span class="n">I</span><span class="o">,</span>
  <span class="n">zero</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">I</span><span class="bp">.</span><span class="n">zero_mem</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">hf1</span><span class="o">,</span> <span class="n">hf2</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">hg1</span><span class="o">,</span> <span class="n">hg2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">sorry</span><span class="c">/-</span><span class="cm">begin</span>
<span class="cm">    by_cases h0 : a + b = 0, rw h0, exact ⟨0, I.zero_mem, rfl⟩,</span>
<span class="cm">    by_cases hf : f = 0, rw [← hf2, ← hg2, hf, leading_coeff_zero, zero_add], exact ⟨g, hg1, rfl⟩,</span>
<span class="cm">    by_cases hg : g = 0, rw [← hf2, ← hg2, hg, leading_coeff_zero, add_zero], exact ⟨f, hf1, rfl⟩,</span>
<span class="cm">    cases le_total (nat_degree f) (nat_degree g) with hd hd, -- can&#39;t get WLOG to work</span>
<span class="cm">    { refine ⟨f * X ^ (nat_degree g - nat_degree f) + g,</span>
<span class="cm">        I.add_mem (I.mul_mem_right hf1) hg1, _⟩,</span>
<span class="cm">      have := leading_term_aux hd hf hg (by rwa [hf2, hg2]),</span>
<span class="cm">      rwa [hf2, hg2] at this },</span>
<span class="cm">    { refine ⟨g * X ^ (nat_degree g - nat_degree f) + f,</span>
<span class="cm">        I.add_mem (I.mul_mem_right hg1) hf1, _⟩,</span>
<span class="cm">      have := leading_term_aux hd hg hf (by rwa [hf2, hg2, add_comm]),</span>
<span class="cm">      rwa [hf2, hg2] at this }</span>
<span class="cm">  end-/</span><span class="o">,</span>
  <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">c</span> <span class="n">a</span> <span class="bp">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">hf1</span><span class="o">,</span> <span class="n">hf2</span><span class="bp">⟩</span><span class="o">,</span> <span class="k">begin</span>
    <span class="n">by_cases</span> <span class="n">hcr</span> <span class="o">:</span> <span class="n">c</span> <span class="err">•</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">rw</span> <span class="n">hcr</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">I</span><span class="bp">.</span><span class="n">zero_mem</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">refine</span> <span class="bp">⟨</span><span class="n">C</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">f</span><span class="o">,</span> <span class="n">I</span><span class="bp">.</span><span class="n">mul_mem_left</span> <span class="n">hf1</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">leading_coeff</span> <span class="o">(</span><span class="n">C</span> <span class="n">c</span><span class="o">)</span> <span class="bp">*</span> <span class="n">leading_coeff</span> <span class="n">f</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rwa</span> <span class="o">[</span><span class="n">leading_coeff_C</span><span class="o">,</span> <span class="n">hf2</span><span class="o">,</span> <span class="err">←</span> <span class="n">smul_eq_mul</span><span class="o">]</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">leading_coeff_mul&#39;</span> <span class="n">this</span><span class="o">,</span> <span class="n">leading_coeff_C</span><span class="o">,</span> <span class="n">hf2</span><span class="o">,</span> <span class="n">smul_eq_mul</span><span class="o">]</span>
  <span class="kn">end</span> <span class="o">}</span>
</pre></div>

<a name="145303431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/145303431" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#145303431">Kenny Lau (Nov 05 2018 at 06:39)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> why does this time out?</p>

<a name="145303491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/145303491" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#145303491">Mario Carneiro (Nov 05 2018 at 06:41)</a>:</h4>
<p>polynomials have had problems with long elaboration in the past</p>

<a name="145303494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/145303494" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#145303494">Mario Carneiro (Nov 05 2018 at 06:41)</a>:</h4>
<p>check that it isn't doing any crazy typeclass searches?</p>

<a name="145303620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/145303620" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#145303620">Kenny Lau (Nov 05 2018 at 06:45)</a>:</h4>
<p>it's searching for <code>has_one nat</code> and <code>has_add nat</code> like a billion times</p>

<a name="145303719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/145303719" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#145303719">Mario Carneiro (Nov 05 2018 at 06:48)</a>:</h4>
<p>still profiling (slow business, of course) but it looks like the second block takes much longer than the first</p>

<a name="145303725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/145303725" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#145303725">Kenny Lau (Nov 05 2018 at 06:48)</a>:</h4>
<p>oh, thanks</p>

<a name="145303733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/145303733" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#145303733">Kenny Lau (Nov 05 2018 at 06:49)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> should I push what I have in my kmb_hilbert_basis?</p>

<a name="145303748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/145303748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#145303748">Mario Carneiro (Nov 05 2018 at 06:49)</a>:</h4>
<p>it takes 3.5 seconds with the sorry in, which is bad but not that bad so I guess you are worried about the commented out bit</p>

<a name="145303805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/145303805" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#145303805">Kenny Lau (Nov 05 2018 at 06:51)</a>:</h4>
<p>but why does <code>polynomial</code> have long elaboration time?</p>

<a name="145304062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/145304062" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#145304062">Mario Carneiro (Nov 05 2018 at 06:59)</a>:</h4>
<p>If I replace the last <code>rwa</code> in the second block with <code>rw</code>, the final state is:</p>
<div class="codehilite"><pre><span></span>...
this : leading_coeff (g * X ^ (nat_degree f - nat_degree g) + f) = b + a
⊢ leading_coeff (g * X ^ (nat_degree g - nat_degree f) + f) = a + b
</pre></div>


<p>I'm not sure how assumption is supposed to close that</p>

<a name="145304145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/145304145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#145304145">Kenny Lau (Nov 05 2018 at 07:00)</a>:</h4>
<p>ah</p>

<a name="145304160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/145304160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#145304160">Mario Carneiro (Nov 05 2018 at 07:01)</a>:</h4>
<p>it's probably taking forever unfolding all the things to see if those are actually the same</p>

<a name="145304269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/145304269" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#145304269">Kenny Lau (Nov 05 2018 at 07:04)</a>:</h4>
<p>should I add two submodules together?</p>

<a name="145304491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/145304491" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#145304491">Kenny Lau (Nov 05 2018 at 07:11)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">module</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="kn">instance</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">has_add&#39;</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span><span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">N₁</span> <span class="n">N₂</span><span class="o">,</span> <span class="o">{</span>
  <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">z</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">N₁</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="err">∈</span> <span class="n">N₂</span><span class="o">),</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">},</span>
  <span class="n">zero</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">N₁</span><span class="bp">.</span><span class="n">zero_mem</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">N₂</span><span class="bp">.</span><span class="n">zero_mem</span><span class="o">,</span> <span class="n">add_zero</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="n">add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z₁</span> <span class="n">z₂</span> <span class="bp">⟨</span><span class="n">x₁</span><span class="o">,</span> <span class="n">hx₁</span><span class="o">,</span> <span class="n">y₁</span><span class="o">,</span> <span class="n">hy₁</span><span class="o">,</span> <span class="n">hz₁</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">x₂</span><span class="o">,</span> <span class="n">hx₂</span><span class="o">,</span> <span class="n">y₂</span><span class="o">,</span> <span class="n">hy₂</span><span class="o">,</span> <span class="n">hz₂</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="bp">⟨</span><span class="n">x₁</span> <span class="bp">+</span> <span class="n">x₂</span><span class="o">,</span> <span class="n">N₁</span><span class="bp">.</span><span class="n">add_mem</span> <span class="n">hx₁</span> <span class="n">hx₂</span><span class="o">,</span> <span class="n">y₁</span> <span class="bp">+</span> <span class="n">y₂</span><span class="o">,</span> <span class="n">N₂</span><span class="bp">.</span><span class="n">add_mem</span> <span class="n">hy₁</span> <span class="n">hy₂</span><span class="o">,</span>
    <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">hz₁</span><span class="o">,</span> <span class="err">←</span> <span class="n">hz₂</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">,</span> <span class="n">add_left_comm</span> <span class="n">x₂</span><span class="o">,</span> <span class="err">←</span> <span class="n">add_assoc</span><span class="o">]</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">c</span> <span class="n">z</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">hz</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="bp">⟨</span><span class="n">c</span> <span class="err">•</span> <span class="n">x</span><span class="o">,</span> <span class="n">N₁</span><span class="bp">.</span><span class="n">smul_mem</span> <span class="n">c</span> <span class="n">hx</span><span class="o">,</span> <span class="n">c</span> <span class="err">•</span> <span class="n">y</span><span class="o">,</span> <span class="n">N₂</span><span class="bp">.</span><span class="n">smul_mem</span> <span class="n">c</span> <span class="n">hy</span><span class="o">,</span>
    <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">hz</span><span class="o">,</span> <span class="n">smul_add</span><span class="o">]</span><span class="bp">⟩</span> <span class="o">}</span><span class="bp">⟩</span>
</pre></div>

<a name="145304533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/145304533" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#145304533">Mario Carneiro (Nov 05 2018 at 07:12)</a>:</h4>
<p>isn't this <code>\sup</code>?</p>

<a name="145304534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/145304534" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#145304534">Kenny Lau (Nov 05 2018 at 07:12)</a>:</h4>
<p>oh</p>

<a name="145304535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/145304535" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#145304535">Kenny Lau (Nov 05 2018 at 07:12)</a>:</h4>
<p>lol</p>

<a name="145304565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/145304565" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#145304565">Mario Carneiro (Nov 05 2018 at 07:13)</a>:</h4>
<p>I realize that ring theorists prefer the notations <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>+</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A + B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord mathit">A</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>∩</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\cap B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span><span class="mbin">∩</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>∨</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\vee B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span><span class="mbin">∨</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>∧</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\wedge B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span><span class="mbin">∧</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>, but I think we should go for more notational uniformity</p>

<a name="146784108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146784108" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146784108">Kenny Lau (Nov 05 2018 at 09:12)</a>:</h4>
<p>oh, <code>coeff_is_linear</code> uses <code>is_linear_map</code>, should I refactor that? <span class="user-mention" data-user-id="110049">@Mario Carneiro</span></p>

<a name="146784560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146784560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146784560">Kenny Lau (Nov 05 2018 at 09:25)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">map_mk</span> <span class="o">(</span><span class="n">I</span> <span class="n">J</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">I</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="n">mk</span> <span class="n">I</span> <span class="err">&#39;&#39;</span> <span class="n">J</span><span class="o">,</span>
  <span class="n">zero</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">J</span><span class="bp">.</span><span class="n">zero_mem</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">add</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rintro</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩;</span>
    <span class="n">exact</span> <span class="bp">⟨</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">,</span> <span class="n">J</span><span class="bp">.</span><span class="n">add_mem</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">smul</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">c</span><span class="bp">⟩</span> <span class="bp">_</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩;</span>
    <span class="n">exact</span> <span class="bp">⟨</span><span class="n">c</span> <span class="bp">*</span> <span class="n">x</span><span class="o">,</span> <span class="n">J</span><span class="bp">.</span><span class="n">mul_mem_left</span> <span class="n">hx</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="o">}</span>
</pre></div>


<p>I think we can generalize this <span class="user-mention" data-user-id="110049">@Mario Carneiro</span></p>

<a name="146784575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146784575" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146784575">Mario Carneiro (Nov 05 2018 at 09:25)</a>:</h4>
<p>to what?</p>

<a name="146784617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146784617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146784617">Mario Carneiro (Nov 05 2018 at 09:26)</a>:</h4>
<p>yes on <code>coeff</code> btw, you may need a second function though</p>

<a name="146785589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146785589" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146785589">Kenny Lau (Nov 05 2018 at 09:50)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> and how far away are we from the refactoring?</p>

<a name="146785630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146785630" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146785630">Mario Carneiro (Nov 05 2018 at 09:52)</a>:</h4>
<p>plan is to finish it today; I am currently rejiggering some stuff with <code>is_unit</code> and <code>nonunits</code> prompted by some of Rob's applications</p>

<a name="146786349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146786349" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146786349">Kenny Lau (Nov 05 2018 at 10:07)</a>:</h4>
<p>are you working on a separate branch or a private repo or something? i.e. should I just push to that branch?</p>

<a name="146786408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146786408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146786408">Mario Carneiro (Nov 05 2018 at 10:08)</a>:</h4>
<p>I'm working locally, feel free to keep committing to the <code>module</code> branch and I'll merge when I push</p>

<a name="146786420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146786420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146786420">Kenny Lau (Nov 05 2018 at 10:09)</a>:</h4>
<p>do you want to push your work to the community branches?</p>

<a name="146786436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146786436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146786436">Kevin Buzzard (Nov 05 2018 at 10:09)</a>:</h4>
<p>Kenny and I are just chatting on Skype</p>

<a name="146786437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146786437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146786437">Kevin Buzzard (Nov 05 2018 at 10:10)</a>:</h4>
<p>For Hilbert basis</p>

<a name="146786489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146786489" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146786489">Kevin Buzzard (Nov 05 2018 at 10:10)</a>:</h4>
<p>one perhaps needs that there's some inclusion of lattices -- if R -&gt; S is a ring hom and M is an S-module</p>

<a name="146786501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146786501" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146786501">Kevin Buzzard (Nov 05 2018 at 10:11)</a>:</h4>
<p>then there's an order preserving injection from the lattice of sub-S-modules to the lattice of sub-R-modules</p>

<a name="146786568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146786568" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146786568">Mario Carneiro (Nov 05 2018 at 10:12)</a>:</h4>
<p>okay, it's broken tho</p>

<a name="146786582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146786582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146786582">Kevin Buzzard (Nov 05 2018 at 10:12)</a>:</h4>
<p>A sub-R-module is just a sub-f(R)-module where f(R) is the subring of S</p>

<a name="146786605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146786605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146786605">Kevin Buzzard (Nov 05 2018 at 10:13)</a>:</h4>
<p>If R -&gt; S is an injection with M an S-module then there's an injection from the sub-S-modules to the sub-R-modules</p>

<a name="146786657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146786657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146786657">Kevin Buzzard (Nov 05 2018 at 10:14)</a>:</h4>
<p>If R -&gt; S is a surjection and M is an R-module then the submodule of M consisting of stuff which is annihiliated by the kernel of R-&gt;S is an S-module</p>

<a name="146786709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146786709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146786709">Kevin Buzzard (Nov 05 2018 at 10:15)</a>:</h4>
<p>and that way you get an injection from sub-S-modules to sub-R-modules</p>

<a name="146787850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146787850" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146787850">Kenny Lau (Nov 05 2018 at 10:40)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">polynomial</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variable</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">ideal</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">))</span>

<span class="n">def</span> <span class="n">ideal</span><span class="bp">.</span><span class="n">of_polynomial</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">@</span><span class="n">submodule</span><span class="bp">.</span><span class="n">carrier</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">ring</span><span class="bp">.</span><span class="n">to_module</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)),</span>
  <span class="n">zero</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span> <span class="n">add</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span> <span class="n">smul</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">ideal</span><span class="bp">.</span><span class="n">of_polynomial&#39;</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">(</span><span class="n">I</span><span class="bp">.</span><span class="n">carrier</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)),</span> <span class="c1">-- doesn&#39;t work</span>
  <span class="n">zero</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span> <span class="n">add</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span> <span class="n">smul</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="o">}</span>
</pre></div>


<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span></p>

<a name="146787867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146787867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146787867">Mario Carneiro (Nov 05 2018 at 10:41)</a>:</h4>
<p>it's probably guessing the wrong scalar ring here</p>

<a name="146787870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146787870" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146787870">Kevin Buzzard (Nov 05 2018 at 10:42)</a>:</h4>
<p>I thought it never had to guess anything nowadays?</p>

<a name="146787918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146787918" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146787918">Mario Carneiro (Nov 05 2018 at 10:42)</a>:</h4>
<p>that's the next thing on the list after the module refactor</p>

<a name="146787923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146787923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146787923">Kevin Buzzard (Nov 05 2018 at 10:42)</a>:</h4>
<p>There's a _list_??</p>

<a name="146787928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146787928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146787928">Johan Commelin (Nov 05 2018 at 10:42)</a>:</h4>
<p>I feel there is a need for module refactor 2.0 <span class="emoji emoji-1f923" title="rolling on the floor laughing">:rolling_on_the_floor_laughing:</span></p>

<a name="146787930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146787930" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146787930">Kevin Buzzard (Nov 05 2018 at 10:42)</a>:</h4>
<p>I never realised modules were so hard :-)</p>

<a name="146787987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146787987" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146787987">Kenny Lau (Nov 05 2018 at 10:44)</a>:</h4>
<p>yeah that's 'coz you're a mathematician</p>

<a name="146788414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146788414" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146788414">Mario Carneiro (Nov 05 2018 at 10:54)</a>:</h4>
<p>the list is my todo list, and it's on the list because people want modules to have multiple scalar rings</p>

<a name="146788582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146788582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146788582">Kevin Buzzard (Nov 05 2018 at 10:59)</a>:</h4>
<p>I am just trying to formalise various standard results in undergraduate algebra like Hilbert basis and reporting back on what mathematicians use</p>

<a name="146794422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146794422" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146794422">Mario Carneiro (Nov 05 2018 at 13:18)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> <span class="user-mention" data-user-id="110294">@Johannes Hölzl</span> The final draft of the module refactor is pushed</p>

<a name="146794432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146794432" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146794432">Kenny Lau (Nov 05 2018 at 13:18)</a>:</h4>
<p>so... coeff is linear?</p>

<a name="146794653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146794653" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146794653">Mario Carneiro (Nov 05 2018 at 13:23)</a>:</h4>
<p>it is now</p>

<a name="146794754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146794754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146794754">Kenny Lau (Nov 05 2018 at 13:25)</a>:</h4>
<p>thanks</p>

<a name="146794766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146794766" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146794766">Kevin Buzzard (Nov 05 2018 at 13:25)</a>:</h4>
<p>So how do I make an S-module into an R-module if I have a ring hom <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>:</mo><mi>R</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">f : R \to S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mrel">:</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span>?</p>

<a name="146794771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146794771" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146794771">Kevin Buzzard (Nov 05 2018 at 13:25)</a>:</h4>
<p>thanks too</p>

<a name="146794880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146794880" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146794880">Mario Carneiro (Nov 05 2018 at 13:28)</a>:</h4>
<p>Maybe there should be a way to put chosen ring homs in the typeclass infrastructure?</p>

<a name="146794939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146794939" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146794939">Mario Carneiro (Nov 05 2018 at 13:28)</a>:</h4>
<p>Otherwise you just have to introduce it locally every time</p>

<a name="146794957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146794957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146794957">Mario Carneiro (Nov 05 2018 at 13:29)</a>:</h4>
<p>I assume you aren't asking how to define the R-module structure, that's not difficult at all</p>

<a name="146795078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146795078" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146795078">Johan Commelin (Nov 05 2018 at 13:30)</a>:</h4>
<blockquote>
<p>Maybe there should be a way to put chosen ring homs in the typeclass infrastructure?</p>
</blockquote>
<p>I think we could also try using a structure <code>algebra</code>.</p>

<a name="146795319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146795319" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146795319">Kevin Buzzard (Nov 05 2018 at 13:34)</a>:</h4>
<blockquote>
<p>I assume you aren't asking how to define the R-module structure, that's not difficult at all</p>
</blockquote>
<p>Right -- I'm asking for the idiomatic way to do it.</p>

<a name="146796014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146796014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146796014">Johannes Hölzl (Nov 05 2018 at 13:46)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  why  is it now a mixing, i.e. why is the group structure not part of modules anymore?</p>

<a name="146796108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146796108" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146796108">Mario Carneiro (Nov 05 2018 at 13:48)</a>:</h4>
<p>Because the parent coercion <code>module R M =&gt; add_comm_group M</code> was causing much of the module typeclass issues</p>

<a name="146796123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146796123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146796123">Mario Carneiro (Nov 05 2018 at 13:49)</a>:</h4>
<p>plus if <code>R</code> becomes not an <code>out_param</code> then it won't even work</p>

<a name="146802129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146802129" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146802129">Johannes Hölzl (Nov 05 2018 at 15:17)</a>:</h4>
<p>the module PR looks very good to me</p>

<a name="146804978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146804978" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146804978">Johan Commelin (Nov 05 2018 at 15:59)</a>:</h4>
<p>It's merged <span class="emoji emoji-1f389" title="tada">:tada:</span> <span class="emoji emoji-1f44d" title="thumbs up">:thumbs_up:</span> <span class="emoji emoji-1f419" title="octopus">:octopus:</span></p>

<a name="146804983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/146804983" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#146804983">Johannes Hölzl (Nov 05 2018 at 15:59)</a>:</h4>
<p>COMMIT 1000</p>

<a name="157346031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/157346031" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#157346031">Neil Strickland (Feb 01 2019 at 11:18)</a>:</h4>
<p>Bases should <strong>definitely</strong> be maps or lists.  Some treatments of finite-dimensional linear algebra purport to use subsets, but they are almost always wrong if read literally, and would require fiddly side-conditions to make them right.  Also, to talk about the standard algorithms you need efficient translation between bases and matrices, which becomes very awkward if you use subsets.</p>

<a name="157346162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/157346162" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#157346162">Johan Commelin (Feb 01 2019 at 11:21)</a>:</h4>
<p>It isn't too hard to convert between a subset and a map. But maybe there should be a bit more API for this. Is there something specific that you are missing?</p>

<a name="157346171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/157346171" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#157346171">Johan Commelin (Feb 01 2019 at 11:21)</a>:</h4>
<p>Matrices are currently indexed by fintypes (not necessarily ordered).</p>

<a name="157346354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/157346354" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#157346354">Kenny Lau (Feb 01 2019 at 11:26)</a>:</h4>
<p>... is this related to the previous discussion?</p>

<a name="157346582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/module%20refactoring/near/157346582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/97723modulerefactoring.html#157346582">Neil Strickland (Feb 01 2019 at 11:30)</a>:</h4>
<p>I think not, sorry.  Zulip sometimes gets in a funny state where it shows me very old posts mixed in with new ones, and I was accidentally replying to one of those.  I am not quite sure what is going on with that.</p>


{% endraw %}
