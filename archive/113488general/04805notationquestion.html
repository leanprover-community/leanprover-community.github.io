---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/04805notationquestion.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/04805notationquestion.html">notation question</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="126173744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20question/near/126173744" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04805notationquestion.html#126173744">Kevin Buzzard (May 06 2018 at 11:30)</a>:</h4>
<p>The following might be impossible in Lean but I thought I'd ask. It's just an issue with notation.</p>

<a name="126173745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20question/near/126173745" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04805notationquestion.html#126173745">Kevin Buzzard (May 06 2018 at 11:30)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">S</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`</span><span class="err">♥</span><span class="bp">`</span> <span class="o">:</span> <span class="mi">50</span> <span class="o">:=</span> <span class="n">R</span>

<span class="kn">definition</span> <span class="n">euclidean₁</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">{{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">S</span><span class="o">}},</span> <span class="n">x</span> <span class="err">♥</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">♥</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">♥</span> <span class="n">z</span>
<span class="kn">definition</span> <span class="n">euclidean₂</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">S</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">{{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">S</span><span class="o">}},</span> <span class="n">R</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">R</span> <span class="n">x</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">R</span> <span class="n">y</span> <span class="n">z</span>
<span class="kn">definition</span> <span class="n">euclidean₃</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">S</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">{{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">S</span><span class="o">}},</span> <span class="n">x</span> <span class="err">♥</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">♥</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">♥</span> <span class="n">z</span>
</pre></div>

<a name="126173746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20question/near/126173746" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04805notationquestion.html#126173746">Kevin Buzzard (May 06 2018 at 11:30)</a>:</h4>
<p>(<code>\heartsuit</code> gives the heart, by the way)</p>

<a name="126173754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20question/near/126173754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04805notationquestion.html#126173754">Kevin Buzzard (May 06 2018 at 11:31)</a>:</h4>
<p>So mathematicians would normally _define_ a new relation with the infix notation, in contrast to functional programmers who want to define <code>R</code> first and then set up infix notation for it.</p>

<a name="126173755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20question/near/126173755" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04805notationquestion.html#126173755">Kevin Buzzard (May 06 2018 at 11:31)</a>:</h4>
<p>This has the following annoying-for-mathematicians consequence.</p>

<a name="126173794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20question/near/126173794" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04805notationquestion.html#126173794">Kevin Buzzard (May 06 2018 at 11:32)</a>:</h4>
<p>Definition 1 above is not so great because you can't see what you are defining -- it should say "euclidean1 heartsuit" or something.</p>

<a name="126173795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20question/near/126173795" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04805notationquestion.html#126173795">Kevin Buzzard (May 06 2018 at 11:32)</a>:</h4>
<p>Definition 2 is correct, but doesn't use the notation, so mathematicians are left wondering why we have <code>R x y</code> instead of <code>x R y</code> or <code>x heartsuit y</code></p>

<a name="126173796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20question/near/126173796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04805notationquestion.html#126173796">Kevin Buzzard (May 06 2018 at 11:32)</a>:</h4>
<p>(infix notation is more normal in mathematics than CS perhaps)</p>

<a name="126173804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20question/near/126173804" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04805notationquestion.html#126173804">Kevin Buzzard (May 06 2018 at 11:33)</a>:</h4>
<p>And definition 3 is wrong because the heart in the definition is unrelated to the R -- the heart is attached to the variable R and definition 3 introduces a new one.</p>

<a name="126173805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20question/near/126173805" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04805notationquestion.html#126173805">Kevin Buzzard (May 06 2018 at 11:33)</a>:</h4>
<p>My dream is</p>

<a name="126173806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20question/near/126173806" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04805notationquestion.html#126173806">Kevin Buzzard (May 06 2018 at 11:34)</a>:</h4>
<p><code>definition euclidean_dream (R) := ∀ {{x y z : S}}, x ♥ y → x ♥ z → y ♥ z </code></p>

<a name="126173843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20question/near/126173843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04805notationquestion.html#126173843">Kevin Buzzard (May 06 2018 at 11:34)</a>:</h4>
<p>but of course that doesn't even typecheck</p>

<a name="126173847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20question/near/126173847" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04805notationquestion.html#126173847">Kevin Buzzard (May 06 2018 at 11:34)</a>:</h4>
<p>Is there any way I can make my dream definition typecheck?</p>

<a name="126173848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20question/near/126173848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04805notationquestion.html#126173848">Kevin Buzzard (May 06 2018 at 11:34)</a>:</h4>
<p>Actually I guess my dream is the impossible:</p>

<a name="126173849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20question/near/126173849" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04805notationquestion.html#126173849">Kevin Buzzard (May 06 2018 at 11:34)</a>:</h4>
<p><code>definition euclidean_dream ♥ := ∀ {{x y z : S}}, x ♥ y → x ♥ z → y ♥ z </code></p>

<a name="126173896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20question/near/126173896" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04805notationquestion.html#126173896">Kevin Buzzard (May 06 2018 at 11:36)</a>:</h4>
<p>I don't mind a few incomprehensible lines with set-up beforehand, my question I guess is simply whether I can introduce a local variable in a definition and instantly have access to notation for it.</p>

<a name="126174227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20question/near/126174227" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04805notationquestion.html#126174227">Sebastian Ullrich (May 06 2018 at 11:51)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Something like this proposal? <a href="https://github.com/leanprover/lean/issues/1522#issuecomment-294872715" target="_blank" title="https://github.com/leanprover/lean/issues/1522#issuecomment-294872715">https://github.com/leanprover/lean/issues/1522#issuecomment-294872715</a></p>

<a name="126174466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20question/near/126174466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04805notationquestion.html#126174466">Kevin Buzzard (May 06 2018 at 12:01)</a>:</h4>
<p>Yes! I didn't mention it in my posts above but I did try to do this with the type class notation types (indeed I wrote <code>has_heart</code> :-) ) but I couldn't get that to work either because <code>definition blah (S : Type) (R : S -&gt; S -&gt; Prop) [has_heart S]</code> wouldn't attach the heart to R and I couldn't figure out how to make the attachment whilst keeping it all looking clean and uncluttered. I am currently thinking a lot about trying to write code which looks really clean to mathematicians, who we can think of here as people who know exactly what a transitive binary relation is but have no idea what a typeclass is and don't want to see clutter when they are actually doing or reading mathematics in Lean.</p>

<a name="126176900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20question/near/126176900" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04805notationquestion.html#126176900">Reid Barton (May 06 2018 at 13:44)</a>:</h4>
<p>In Haskell you can convert an infix operator to an ordinary (prefix) function by surrounding the operator in parentheses. You can also use this notation at a binding site.<br>
The hypothetical Lean equivalent would be</p>
<div class="codehilite"><pre><span></span><span class="kn">definition</span> <span class="n">euclidean</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">((</span><span class="err">♥</span><span class="o">)</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">S</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">{{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">S</span><span class="o">}},</span> <span class="n">x</span> <span class="err">♥</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">♥</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">♥</span> <span class="n">z</span>
</pre></div>

<a name="126178574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation%20question/near/126178574" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/04805notationquestion.html#126178574">Kevin Buzzard (May 06 2018 at 14:45)</a>:</h4>
<p>Lean would need to be told the associativity and left binding power, or at least default options for such things.</p>


{% endraw %}
