---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/22229tutorial.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html">tutorial</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="135155789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135155789" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135155789">Johan Commelin (Oct 04 2018 at 06:58)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> Would you mind pushing your demo to a new <code>tutorial</code> branch on community fork? Maybe as <code>docs/tutorial/demo.lean</code>.</p>

<a name="135155799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135155799" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135155799">Johan Commelin (Oct 04 2018 at 06:59)</a>:</h4>
<p>After that we could attempt answering Neil's questions in that branch as well.</p>

<a name="135155804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135155804" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135155804">Johan Commelin (Oct 04 2018 at 06:59)</a>:</h4>
<p>Q1 and Q2 have been done. They can easily be entered.</p>

<a name="135155874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135155874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135155874">Johan Commelin (Oct 04 2018 at 07:00)</a>:</h4>
<p>Q3 shouldn't be hard either. Q4 needs work. Q5 should be rather easy again.</p>

<a name="135155893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135155893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135155893">Johan Commelin (Oct 04 2018 at 07:01)</a>:</h4>
<p>The point is that we should write lots of comments in those files. So that people can actually learn a lot of Lean. Instead of learning only a tiny bit of maths (that they actually knew already).</p>

<a name="135155894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135155894" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135155894">Patrick Massot (Oct 04 2018 at 07:01)</a>:</h4>
<p>Ok, I'll do that</p>

<a name="135156024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135156024" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135156024">Bryan Gin-ge Chen (Oct 04 2018 at 07:04)</a>:</h4>
<p>If you're looking for help with this, I'd be happy to contribute. I think I should be able to do Q5.</p>

<a name="135156040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135156040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135156040">Johan Commelin (Oct 04 2018 at 07:05)</a>:</h4>
<p>Sure! Please contribute!</p>

<a name="135156234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135156234" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135156234">Johan Commelin (Oct 04 2018 at 07:10)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> Do you have time to do this before the talks start? Otherwise I can start the branch... and you can dump your demo later (-;</p>

<a name="135156333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135156333" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135156333">Patrick Massot (Oct 04 2018 at 07:13)</a>:</h4>
<p>depends on the RER train. I'm leaving my house, let's see when I'll arrive in Orsay</p>

<a name="135156338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135156338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135156338">Sean Leather (Oct 04 2018 at 07:13)</a>:</h4>
<p>I would recommend using a top-level <code>tutorial</code> directory instead of the subdirectory  under <code>docs</code>. First, it's more discoverable (easier to find). Second, I think many people expect <code>docs</code> to not be code, which could lead people to not look in there for code.</p>

<a name="135156397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135156397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135156397">Johan Commelin (Oct 04 2018 at 07:15)</a>:</h4>
<p>I'm fine with that. It depends on what the powers that be prefer (-; <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <span class="user-mention" data-user-id="110294">@Johannes Hölzl</span></p>

<a name="135156595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135156595" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135156595">Johannes Hölzl (Oct 04 2018 at 07:20)</a>:</h4>
<p>if we add tutorials, I would also prefer <code>tutorial</code> in the top level directory.</p>

<a name="135156651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135156651" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135156651">Johannes Hölzl (Oct 04 2018 at 07:20)</a>:</h4>
<p>But we could also have a separate repository in <code>leanprover-community</code> then its easier to contribute</p>

<a name="135156668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135156668" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135156668">Johan Commelin (Oct 04 2018 at 07:21)</a>:</h4>
<p>I think it is best to have this end up in mathlib. Because then we are forced to keep it working. Also: better discoverability</p>

<a name="135161048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135161048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135161048">Kevin Buzzard (Oct 04 2018 at 09:10)</a>:</h4>
<p>Stick it in the top level and it can be moved later</p>

<a name="135240591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135240591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135240591">Bryan Gin-ge Chen (Oct 05 2018 at 08:05)</a>:</h4>
<p>I've made some progress on Q5. Is someone (Patrick? Johan?) planning to make a branch in leanprover-community I can PR to?</p>

<a name="135240650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135240650" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135240650">Johan Commelin (Oct 05 2018 at 08:07)</a>:</h4>
<p>Sorry, I have to do some other stuff now. Please go ahead and create the branch</p>

<a name="135240799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135240799" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135240799">Patrick Massot (Oct 05 2018 at 08:10)</a>:</h4>
<p>I'll create the branch if you want</p>

<a name="135240813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135240813" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135240813">Bryan Gin-ge Chen (Oct 05 2018 at 08:11)</a>:</h4>
<p>Sure, that'd be great.</p>

<a name="135240831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135240831" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135240831">Patrick Massot (Oct 05 2018 at 08:11)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/tree/tutorials" target="_blank" title="https://github.com/leanprover-community/mathlib/tree/tutorials">https://github.com/leanprover-community/mathlib/tree/tutorials</a></p>

<a name="135240896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135240896" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135240896">Patrick Massot (Oct 05 2018 at 08:12)</a>:</h4>
<p>wait</p>

<a name="135240898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135240898" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135240898">Patrick Massot (Oct 05 2018 at 08:12)</a>:</h4>
<p>I messed up</p>

<a name="135240985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135240985" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135240985">Patrick Massot (Oct 05 2018 at 08:14)</a>:</h4>
<p>now it's ok</p>

<a name="135241326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135241326" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135241326">Patrick Massot (Oct 05 2018 at 08:23)</a>:</h4>
<p>Ok, I've pushed my demo file: <a href="https://github.com/leanprover-community/mathlib/commit/bf36dd1e66d373c53666ca4579649f767955ed42" target="_blank" title="https://github.com/leanprover-community/mathlib/commit/bf36dd1e66d373c53666ca4579649f767955ed42">https://github.com/leanprover-community/mathlib/commit/bf36dd1e66d373c53666ca4579649f767955ed42</a></p>

<a name="135241958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135241958" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135241958">Bryan Gin-ge Chen (Oct 05 2018 at 08:36)</a>:</h4>
<p>OK, I've PR'd my file for review <a href="https://github.com/leanprover-community/mathlib/pull/6" target="_blank" title="https://github.com/leanprover-community/mathlib/pull/6">here</a>.</p>

<a name="135242037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135242037" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135242037">Johan Commelin (Oct 05 2018 at 08:39)</a>:</h4>
<p>You don't have write access to the community fork?</p>

<a name="135242038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135242038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135242038">Bryan Gin-ge Chen (Oct 05 2018 at 08:39)</a>:</h4>
<p>Oh, I guess not.</p>

<a name="135242098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135242098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135242098">Johan Commelin (Oct 05 2018 at 08:40)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <span class="user-mention" data-user-id="110026">@Simon Hudon</span> can one of you fix this?</p>

<a name="135242854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135242854" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135242854">Simon Hudon (Oct 05 2018 at 08:57)</a>:</h4>
<p>Done</p>

<a name="135242861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135242861" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135242861">Simon Hudon (Oct 05 2018 at 08:58)</a>:</h4>
<p>And now, I'm off. Good day!</p>

<a name="135242909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135242909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135242909">Johan Commelin (Oct 05 2018 at 08:58)</a>:</h4>
<p>Sleep tight!</p>

<a name="135242942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135242942" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135242942">Simon Hudon (Oct 05 2018 at 08:59)</a>:</h4>
<p>Thanks :) <span class="emoji emoji-1f4a4" title="zzz">:zzz:</span></p>

<a name="135254193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135254193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135254193">Bryan Gin-ge Chen (Oct 05 2018 at 13:19)</a>:</h4>
<p>Thanks Simon!</p>

<a name="135254614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135254614" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135254614">Bryan Gin-ge Chen (Oct 05 2018 at 13:27)</a>:</h4>
<p>I've gone ahead and merged my PR. Here are two specific questions, and I would appreciate any other comments as well:</p>
<p>1) I'm not sure how to finish <a href="https://github.com/leanprover-community/mathlib/blob/tutorials/tutorials/partitions.lean#L96" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/tutorials/tutorials/partitions.lean#L96">this proof</a>.</p>
<p>2) The forward and backward directions in the <code>iff.intro</code> <a href="https://github.com/leanprover-community/mathlib/blob/4752d91c7e0781e275e6a14edafcbf1a73b8c8ae/tutorials/partitions.lean#L134" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/4752d91c7e0781e275e6a14edafcbf1a73b8c8ae/tutorials/partitions.lean#L134">here</a> are identical except that the roles of <code> s₁</code> and <code>s₂</code> are swapped. Is there a cleaner way to do this? I thought about using <code>wlog</code> but I couldn't figure out how to use it in this case.</p>

<a name="135259968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135259968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135259968">Kevin Buzzard (Oct 05 2018 at 15:00)</a>:</h4>
<blockquote>
<p>1) I'm not sure how to finish <a href="https://github.com/leanprover-community/mathlib/blob/tutorials/tutorials/partitions.lean#L96" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/tutorials/tutorials/partitions.lean#L96">this proof</a>.</p>
</blockquote>
<p>Oh I love these questions. Mathematicians don't even give them a second thought. You have two finite types with the same cardinality and and you want to conclude that some operation on the type which only depends on the cardinality (e.g. the cardinality of the number of partitions) is the same for each. This is stupidly hard to do in Lean and it's coming up more and more. The general problem is that if you have two types which are equivalent (i.e. you are given inverse bijections between the types and proofs that the maps are inverse to each other on both sides) then a mathematician instantly identifies the types, and any reasonable theorem or definition constructed with one has an obvious counterpart for the other. Now someone will explain that yeah in theory this can all be done with <code>traversable</code> or <code>transportable</code> or something, but I can't do this because I don't really understand what needs to be done. We've just missed <span class="user-mention" data-user-id="110026">@Simon Hudon</span> but he knows something about this sort of question. My guess is that you need to prove that if the cards are the same then there's an <code>equiv</code> (which might well be there), and then you want to prove that if <code>X equiv Y</code> then <code>partitions X equiv partitions Y</code> (which looks trivial but might involve some actual work) and then you want to prove that partitions X equiv partitions Y then the cards are the same, which might well be there.</p>

<a name="135260449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135260449" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135260449">Simon Hudon (Oct 05 2018 at 15:07)</a>:</h4>
<p>Thanks for cueing me in <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>! That is indeed a nice question!</p>

<a name="135260515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135260515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135260515">Bryan Gin-ge Chen (Oct 05 2018 at 15:08)</a>:</h4>
<blockquote>
<p>if the cards are the same then there's an equiv (which might well be there), </p>
</blockquote>
<p>Yeah, I was attempting to use <code>fintype.equiv_fin</code>for that but it gives me an equiv wrapped up in <code>trunc</code>... so I gave up and decided to ask for help.</p>

<a name="135261258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135261258" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135261258">Kevin Buzzard (Oct 05 2018 at 15:20)</a>:</h4>
<p>The example I ran into in around Feb/Mar time was that I had a complex of abelian groups <code>A -&gt; B -&gt; C</code> and an isomorphic (in the obvious sense) complex <code>A' -&gt; B' -&gt; C'</code> and wanted to deduce that these two complexes had isomorphic cohomology -- in fact I had several questions of this nature. I wanted the isomorphism to be explictly built for me by a tactic but in the end I don't think this ever happened.</p>

<a name="135261330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135261330" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135261330">Kevin Buzzard (Oct 05 2018 at 15:21)</a>:</h4>
<p>People ground out proofs very quickly -- "this is an isomorphism and this is an isomorphism so this map between kernels is an isomorphism, and now this map between images is an isomorphism, and..." but they really had to build them</p>

<a name="135261383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135261383" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135261383">Kevin Buzzard (Oct 05 2018 at 15:22)</a>:</h4>
<p>But I want proof by a tactic called <code>mathematical_intuition</code> or <code>transport_de_structure</code> or something</p>

<a name="135261600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135261600" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135261600">Kevin Buzzard (Oct 05 2018 at 15:25)</a>:</h4>
<p>and my understanding was that making a tactic would somehow involve having to go through a bunch of Lean theorems or definitions applying to abelian groups, and tagging them with an attribute which is a claim that this function some of whose inputs or outputs are abelian groups "naturally" descends to a function whose inputs and outputs are equivalence classes of abelian groups, where the equivalence is given by group isomorphism.</p>

<a name="135261654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135261654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135261654">Kevin Buzzard (Oct 05 2018 at 15:26)</a>:</h4>
<p>And I think the idea was that some of the attribute-tagging could be done automatically.</p>

<a name="135261659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135261659" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135261659">Simon Hudon (Oct 05 2018 at 15:26)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I did build some isomorphisms with a tactic but I got some push back because transport was seem as redundant with transfer and I didn't take it any further</p>

<a name="135261668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135261668" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135261668">Kevin Buzzard (Oct 05 2018 at 15:26)</a>:</h4>
<p><code>transfer</code>, that's it.</p>

<a name="135261673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135261673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135261673">Kevin Buzzard (Oct 05 2018 at 15:26)</a>:</h4>
<p>Thanks Simon.</p>

<a name="135261691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135261691" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135261691">Simon Hudon (Oct 05 2018 at 15:27)</a>:</h4>
<p><span class="emoji emoji-1f44d" title="+1">:+1:</span></p>

<a name="135261724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135261724" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135261724">Simon Hudon (Oct 05 2018 at 15:27)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> <code>trunc</code> should not deter you. You can unwrap it when you're proving a proposition.</p>

<a name="135261750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135261750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135261750">Simon Hudon (Oct 05 2018 at 15:28)</a>:</h4>
<p>It just states that the object exists in a non constructive way</p>

<a name="135261789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135261789" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135261789">Kevin Buzzard (Oct 05 2018 at 15:28)</a>:</h4>
<p>This is an important tactic for mathematicians and it isn't there. Bryan's question is a great example of an EIMHIL questions (easy in maths, hard in Lean). The exciting thing about this community is that several times in the past I have explicitly flagged things which were easy in maths but hard in Lean, and other members of the community like Simon, Mario and Johannes sometimes step up and make them easy in Lean. The <code>ring</code> tactic is a great example of this.</p>

<a name="135261791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135261791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135261791">Simon Hudon (Oct 05 2018 at 15:28)</a>:</h4>
<p>Look at <code>trunc.induction_on</code></p>

<a name="135261831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135261831" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135261831">Kevin Buzzard (Oct 05 2018 at 15:29)</a>:</h4>
<p>Simon, do you know if is there a relatively easy way to patch up the sorry completely?</p>

<a name="135261837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135261837" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135261837">Simon Hudon (Oct 05 2018 at 15:29)</a>:</h4>
<p>:D Glad to be helpful. I think Lean won't be as easy as math (!) but there certainly are a lot of low hanging fruits to make it a lot easier to use.</p>

<a name="135261924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135261924" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135261924">Kevin Buzzard (Oct 05 2018 at 15:30)</a>:</h4>
<p><span class="user-mention" data-user-id="110865">@Jeremy Avigad</span> I would be really interested to hear your opinion on what a mathematician <em>means</em> when they say that two objects are "canonically isomorphic".</p>

<a name="135261940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135261940" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135261940">Kevin Buzzard (Oct 05 2018 at 15:30)</a>:</h4>
<p>This is notion which is somehow still missing in my Lean experience.</p>

<a name="135261980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135261980" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135261980">Kevin Buzzard (Oct 05 2018 at 15:31)</a>:</h4>
<p>I contributed to some mathoverflow chat about this once</p>

<a name="135262053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135262053" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135262053">Kevin Buzzard (Oct 05 2018 at 15:32)</a>:</h4>
<p><a href="https://mathoverflow.net/questions/19644/what-is-the-definition-of-canonical/19663#19663" target="_blank" title="https://mathoverflow.net/questions/19644/what-is-the-definition-of-canonical/19663#19663">https://mathoverflow.net/questions/19644/what-is-the-definition-of-canonical/19663#19663</a></p>

<a name="135262059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135262059" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135262059">Simon Hudon (Oct 05 2018 at 15:32)</a>:</h4>
<blockquote>
<p>Simon, do you know if is there a relatively easy way to patch up the sorry completely?</p>
</blockquote>
<p>I'll look into it</p>

<a name="135262100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135262100" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135262100">Kevin Buzzard (Oct 05 2018 at 15:33)</a>:</h4>
<p>Oh I just wondered whether you knew immediately that this would be a relatively straightforward sorry to remove. Like when Patrick asks silly questions about subs on nats not working properly and I know I can prove every one because I just know how they work better than he does in some funny way.</p>

<a name="135262150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135262150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135262150">Kevin Buzzard (Oct 05 2018 at 15:34)</a>:</h4>
<p>I think he can do them too, but they just annoy him too much :-)</p>

<a name="135262174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135262174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135262174">Bryan Gin-ge Chen (Oct 05 2018 at 15:34)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> Ah, thanks! Up to now I've been getting away with just applying lemmas and not really thinking much about how things are actually set up using inductive types and such, but now I should probably turn my brain on.</p>

<a name="135262176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135262176" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135262176">Kevin Buzzard (Oct 05 2018 at 15:34)</a>:</h4>
<p>but I have no idea whether Bryan's sorry is easy to fill in or not. In some sense Neil Strickland is exhibiting a problem with doing mathematics in Lean here.</p>

<a name="135262251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135262251" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135262251">Kevin Buzzard (Oct 05 2018 at 15:36)</a>:</h4>
<p>And it's a problem I stumbled upon when doing schemes and so no doubt is looming when the perfectoid project gets really moving again</p>

<a name="135262278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135262278" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135262278">Kevin Buzzard (Oct 05 2018 at 15:36)</a>:</h4>
<p>We will need to be replacing complete topological rings with canonically isomorphic complete topological rings left right and centre.</p>

<a name="135262354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135262354" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135262354">Kevin Buzzard (Oct 05 2018 at 15:38)</a>:</h4>
<p>where by canonically isomorphic I mean an explicit <code>equiv</code> of morphisms in the appropriate category.</p>

<a name="135262623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135262623" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135262623">Simon Hudon (Oct 05 2018 at 15:43)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> It's a common experience I find. E. W. Dijkstra had a nice way to put it: just let the symbols do the work.</p>

<a name="135262725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135262725" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135262725">Simon Hudon (Oct 05 2018 at 15:44)</a>:</h4>
<p>It's taking me a little bit to boot up my brain but I have my coffee now so I should be able to understand a bit more. But Kevin had the right idea I think: you need a congruence lemma for <code>partition</code> with regards to <code>equiv</code></p>

<a name="135262743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135262743" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135262743">Simon Hudon (Oct 05 2018 at 15:45)</a>:</h4>
<p>For the rest, let's see where the symbols take us</p>

<a name="135264259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135264259" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135264259">Kevin Buzzard (Oct 05 2018 at 16:12)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> is that sorry above easy to fill in?</p>

<a name="135264261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135264261" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135264261">Bryan Gin-ge Chen (Oct 05 2018 at 16:12)</a>:</h4>
<p>OK, I think I have a rough idea of what to look at now.  It's rather hard to figure out how to use something new, e.g. <code>equiv</code> when there isn't a chapter of TPiL to fall back on. It doesn't help that core lean has <code>has_equiv</code> which is apparently just unrelated notation. At least mathlib itself provides plenty of example code to learn from. Anyways, hopefully these tutorials will help future users...</p>

<a name="135264271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135264271" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135264271">Kevin Buzzard (Oct 05 2018 at 16:12)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/tutorials/tutorials/partitions.lean#L96" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/tutorials/tutorials/partitions.lean#L96">https://github.com/leanprover-community/mathlib/blob/tutorials/tutorials/partitions.lean#L96</a></p>

<a name="135264295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135264295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135264295">Simon Hudon (Oct 05 2018 at 16:13)</a>:</h4>
<p>I'm almost done proving:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">card_eq_of_equiv</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s</span><span class="bp">.</span><span class="n">to_set</span> <span class="err">≃</span> <span class="n">t</span><span class="bp">.</span><span class="n">to_set</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">s</span><span class="bp">.</span><span class="n">card</span> <span class="bp">=</span> <span class="n">t</span><span class="bp">.</span><span class="n">card</span> <span class="o">:=</span>  <span class="bp">...</span>
</pre></div>


<p>if you want to wait a moment</p>

<a name="135264308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135264308" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135264308">Kevin Buzzard (Oct 05 2018 at 16:13)</a>:</h4>
<p><code>equiv X Y</code> is the best kind of bijection between two types <code>X</code> and <code>Y</code>.</p>

<a name="135264376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135264376" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135264376">Kevin Buzzard (Oct 05 2018 at 16:14)</a>:</h4>
<p>It's an explicit map from <code>X</code> to <code>Y</code> and an explicit inverse.</p>

<a name="135264419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135264419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135264419">Kevin Buzzard (Oct 05 2018 at 16:15)</a>:</h4>
<p>Just saying "there's a map and it's a bijection" is slightly less information in Lean, because they need the computer science version of the axiom of choice (getting data from proofs of existence), so <code>equiv</code> is the important one to focus on.</p>

<a name="135264426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135264426" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135264426">Bryan Gin-ge Chen (Oct 05 2018 at 16:15)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> Cool! I'm still digesting other code so you'll probably finish before I even get close to attempting my own version.</p>

<a name="135264431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135264431" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135264431">Kevin Buzzard (Oct 05 2018 at 16:15)</a>:</h4>
<p>The problem is that <code>equiv</code> is what mathematicians would think of as a canonical bijection between two sets.</p>

<a name="135264494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135264494" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135264494">Kevin Buzzard (Oct 05 2018 at 16:16)</a>:</h4>
<p>There are other equivs too -- group isomorphisms, topological space isomorphism etc.</p>

<a name="135264510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135264510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135264510">Kevin Buzzard (Oct 05 2018 at 16:17)</a>:</h4>
<p>And then there is a whole bunch of stuff defined on types or groups or whatever, which descends to the equivalence classes under these various equivalence relations.</p>

<a name="135264591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135264591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135264591">Kevin Buzzard (Oct 05 2018 at 16:18)</a>:</h4>
<p>And for mathematicians these are all "proof by obvious", so it's clear there's a tactic brewing. But we don't have that tactic yet.</p>

<a name="135264690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135264690" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135264690">Kevin Buzzard (Oct 05 2018 at 16:20)</a>:</h4>
<p>And without it, replacing a topological monoid with a canonically isomorphic topological monoid in a complex of topological monoids and then proving that the cohomology of the complex "hasn't changed" (when Lean actually can see that it _has_ changed in some sense) is going to be hard work I think.</p>

<a name="135264916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135264916" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135264916">Bryan Gin-ge Chen (Oct 05 2018 at 16:25)</a>:</h4>
<p>It's certainly eye-opening (in a good way, probably). I remember having vaguely similar feelings about all the calculus I thought I knew when I took analysis.</p>

<a name="135266320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135266320" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135266320">Simon Hudon (Oct 05 2018 at 16:56)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> The short answer to your question is: yes it's feasible. You need congruence of <code>partitions</code> with regards to <code>equiv</code> and congruence of <code>card</code> with regards to congruence as well. I'm completing the proof now if you want it. It you want to do it yourself, you can use these three hints:</p>
<p>1. prove congruence of partitions<br>
2. prove congruence of card<br>
3. use trunc.induction_on</p>

<a name="135266793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135266793" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135266793">Bryan Gin-ge Chen (Oct 05 2018 at 17:05)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> Great, thanks so much! Feel free to push your proofs into the tutorials branch if you'd like. I'll try to study them and add tutorial-style documentation later on.</p>

<a name="135266877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135266877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135266877">Kevin Buzzard (Oct 05 2018 at 17:07)</a>:</h4>
<blockquote>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> Great, thanks so much! Feel free to push your proofs into the tutorials branch if you'd like. I'll try to study them and add tutorial-style documentation later on.</p>
</blockquote>
<p>This should not be being documented. This should be being hidden by tactics, no?</p>

<a name="135266939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135266939" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135266939">Kevin Buzzard (Oct 05 2018 at 17:08)</a>:</h4>
<p>"We now do a big song and dance to replace an object with a canonically isomorphic object". I'm sure the mathematicians would be fascinated :-)</p>

<a name="135266952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135266952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135266952">Kevin Buzzard (Oct 05 2018 at 17:08)</a>:</h4>
<p>I think there's something missing here.</p>

<a name="135266989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135266989" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135266989">Kevin Buzzard (Oct 05 2018 at 17:09)</a>:</h4>
<p>It's rw for data somehow</p>

<a name="135267068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135267068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135267068">Kevin Buzzard (Oct 05 2018 at 17:10)</a>:</h4>
<p>We want a rw that eats equivs, not equalities and iffs, and works for data in situations where we only care about the answer up to canonical isomorphism.</p>

<a name="135267175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135267175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135267175">Simon Hudon (Oct 05 2018 at 17:12)</a>:</h4>
<p>That would be nice. It involves proving congruence about a ton of functions though. The nice thing about <code>=</code> is that every function preserves it.</p>

<a name="135267222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135267222" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135267222">Simon Hudon (Oct 05 2018 at 17:13)</a>:</h4>
<p>Such a tactic as you're describing is doable. We only need to decide how high it needs to be on the priority list</p>

<a name="135267239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135267239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135267239">Kevin Buzzard (Oct 05 2018 at 17:13)</a>:</h4>
<p>I think we've had this discussion before. Wasn't there some hope that by proving some lemmas about the basic constructors in Lean one could then go on and get a machine to generate all the congruence lemmas automatically?</p>

<a name="135267426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135267426" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135267426">Kevin Buzzard (Oct 05 2018 at 17:16)</a>:</h4>
<p>Can the <code>transfer</code> tactic be turned into this mega-rw tactic? Very often in mathematics people only care about the answer up to isomorphism or perhaps a well-defined notion of canonical isomorphism (maybe it's part of the story that the object is unique up to unique isomorphism, for example).</p>

<a name="135267545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135267545" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135267545">Kevin Buzzard (Oct 05 2018 at 17:18)</a>:</h4>
<p>we want to be able to rewrite isomorphic perfectoid spaces. Is Lean up to that?</p>

<a name="135267731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135267731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135267731">Simon Hudon (Oct 05 2018 at 17:22)</a>:</h4>
<p>I remember building group isomorphism from their underlying type isomorphism but I don't remember the rest of the discussion that you're referring to.</p>

<a name="135267823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135267823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135267823">Simon Hudon (Oct 05 2018 at 17:23)</a>:</h4>
<p>But in my libraries, I have some code to construct an isomorphism from an arbitrary type to sums and pairs. With Jeremy, we're talking about adding support for reasoning about W-types which should complete the picture to building isomorphism to canonical type representations</p>

<a name="135267946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135267946" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135267946">Simon Hudon (Oct 05 2018 at 17:25)</a>:</h4>
<p>Maybe that's what you're looking for?</p>

<a name="135268845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135268845" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135268845">Kevin Buzzard (Oct 05 2018 at 17:37)</a>:</h4>
<p>I'm looking for magic</p>

<a name="135268851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135268851" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135268851">Kevin Buzzard (Oct 05 2018 at 17:37)</a>:</h4>
<p><code>example (X Y : Type) (f : Type → Type) (h : equiv X Y) : equiv (f X) (f Y) := by rw h</code></p>

<a name="135268880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135268880" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135268880">Kevin Buzzard (Oct 05 2018 at 17:37)</a>:</h4>
<p>Mario sometimes tells me that this isn't always true, but I'm not sure I've ever seen a mathematical example of it going wrong.</p>

<a name="135268942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135268942" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135268942">Kevin Buzzard (Oct 05 2018 at 17:38)</a>:</h4>
<p>Here <code>equiv</code> could mean an <code>equiv</code> of structures, and then f is somehow known to preserve all the structure.</p>

<a name="135268989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135268989" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135268989">Kevin Buzzard (Oct 05 2018 at 17:39)</a>:</h4>
<p>Is that magic Simon?</p>

<a name="135269044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135269044" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135269044">Kevin Buzzard (Oct 05 2018 at 17:40)</a>:</h4>
<p>This time round I have a far more mature understanding of what I think is missing.</p>

<a name="135269222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135269222" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135269222">Simon Hudon (Oct 05 2018 at 17:43)</a>:</h4>
<p>What we probably need is a type class to tell us that <code>f</code> preserves <code>equiv</code>. Then <code>iso_rw h</code> (a tactic we want to build) would know how to build the proof. As it is, <code>rw</code> builds its proofs using <code>congr_arg</code> and <code>congr_fun</code> which needs no assumptions about <code>f</code>. We need basically the same tools for <code>equiv</code>.</p>

<a name="135269351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135269351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135269351">Kevin Buzzard (Oct 05 2018 at 17:45)</a>:</h4>
<p>It would be interesting to find out when this is going to bite the perfectoid project and how badly it will bite it. With schemes it bit us when we were doing structure sheaves. Here we only have structure presheaves but who knows.</p>

<a name="135269402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135269402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135269402">Kevin Buzzard (Oct 05 2018 at 17:46)</a>:</h4>
<p>In the schemes project I ended up writing some really weird code.</p>

<a name="135269745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135269745" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135269745">Kevin Buzzard (Oct 05 2018 at 17:51)</a>:</h4>
<p><a href="https://github.com/kbuzzard/lean-stacks-project/blob/53bea440dc519a1f6d023cbecc2dfe270499bbbf/src/tag01HR.lean#L210" target="_blank" title="https://github.com/kbuzzard/lean-stacks-project/blob/53bea440dc519a1f6d023cbecc2dfe270499bbbf/src/tag01HR.lean#L210">https://github.com/kbuzzard/lean-stacks-project/blob/53bea440dc519a1f6d023cbecc2dfe270499bbbf/src/tag01HR.lean#L210</a></p>

<a name="135269818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135269818" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135269818">Kevin Buzzard (Oct 05 2018 at 17:52)</a>:</h4>
<p>Over 350 (admittedly very inelegant and much commented) lines of code, to prove something which de Jong dismisses with one throwaway comment.</p>

<a name="135269955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135269955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135269955">Kevin Buzzard (Oct 05 2018 at 17:55)</a>:</h4>
<p>"Thus we may apply Algebra, Lemma 10.23.1 to the module <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">M_f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span></span></span></span> over <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">R_f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span></span></span></span> and the elements <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>g</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">g_1,\ldots,g_n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mpunct">,</span><span class="minner">…</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>." Note that Chris had already proved the lemma. The issue was applying it.</p>

<a name="135270021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135270021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135270021">Kevin Buzzard (Oct 05 2018 at 17:56)</a>:</h4>
<p>because <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>f</mi><mo>]</mo><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>g</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">R[1/f][1/g]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mclose">]</span></span></span></span> was only canonically isomorphic to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>f</mi><mi>g</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">R[1/fg]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mclose">]</span></span></span></span></p>

<a name="135284021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135284021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135284021">Scott Morrison (Oct 05 2018 at 21:48)</a>:</h4>
<blockquote>
<p>"We now do a big song and dance to replace an object with a canonically isomorphic object". I'm sure the mathematicians would be fascinated :-)</p>
</blockquote>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>, have you seen <span class="user-mention" data-user-id="130272">@David Michael Roberts</span> attempt to summarise the latest disagreement between Mochizuki and Scholze? &lt;<a href="https://thehighergeometer.files.wordpress.com/2018/09/mochizuki_final1.pdf" target="_blank" title="https://thehighergeometer.files.wordpress.com/2018/09/mochizuki_final1.pdf">https://thehighergeometer.files.wordpress.com/2018/09/mochizuki_final1.pdf</a>&gt;. It's very much about whether such replacements were valid or not.</p>

<a name="135291222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135291222" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135291222">Kevin Buzzard (Oct 06 2018 at 00:41)</a>:</h4>
<p>Wow I had not seen that. Thanks.</p>

<a name="135298733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135298733" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135298733">Bryan Gin-ge Chen (Oct 06 2018 at 04:49)</a>:</h4>
<p>Is there an easy proof of this (is it secretly in mathlib)? I did this the hard way with <code>ext</code> and lots of digging back and forth through exists statements:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">embedding_of_finset</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="err">↪</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span> <span class="err">↪</span> <span class="n">finset</span> <span class="n">β</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">S</span><span class="o">,</span> <span class="n">S</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span>
  <span class="n">unfold</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">a₁</span> <span class="n">a₂</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">ext</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span> <span class="err">⊢</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">H</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hex</span> <span class="o">:=</span> <span class="o">(</span><span class="n">h</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">mp</span> <span class="o">(</span><span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">x</span> <span class="bp">⟨</span><span class="n">H</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">),</span>
    <span class="n">exact</span> <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">hex</span> <span class="o">(</span><span class="k">by</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">f</span><span class="bp">.</span><span class="mi">2</span> <span class="n">hy</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">this</span> <span class="bp">▸</span> <span class="n">hy</span><span class="bp">.</span><span class="mi">1</span> <span class="o">})</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">H</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hex</span> <span class="o">:=</span> <span class="o">(</span><span class="n">h</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">(</span><span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">x</span> <span class="bp">⟨</span><span class="n">H</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">),</span>
    <span class="n">exact</span> <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">hex</span> <span class="o">(</span><span class="k">by</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">f</span><span class="bp">.</span><span class="mi">2</span> <span class="n">hy</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">this</span> <span class="bp">▸</span> <span class="n">hy</span><span class="bp">.</span><span class="mi">1</span> <span class="o">})</span> <span class="o">}</span> <span class="o">}</span><span class="bp">⟩</span>
</pre></div>

<a name="135299119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135299119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135299119">Johan Commelin (Oct 06 2018 at 05:05)</a>:</h4>
<blockquote>
<blockquote>
<p>"We now do a big song and dance to replace an object with a canonically isomorphic object". I'm sure the mathematicians would be fascinated :-)</p>
</blockquote>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>, have you seen <span class="user-mention" data-user-id="130272">@David Michael Roberts</span> attempt to summarise the latest disagreement between Mochizuki and Scholze? &lt;<a href="https://thehighergeometer.files.wordpress.com/2018/09/mochizuki_final1.pdf" target="_blank" title="https://thehighergeometer.files.wordpress.com/2018/09/mochizuki_final1.pdf">https://thehighergeometer.files.wordpress.com/2018/09/mochizuki_final1.pdf</a>&gt;. It's very much about whether such replacements were valid or not.</p>
</blockquote>
<p><span class="user-mention" data-user-id="130272">@David Michael Roberts</span> Thanks for writing these!</p>

<a name="135299259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135299259" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135299259">Mario Carneiro (Oct 06 2018 at 05:10)</a>:</h4>
<p>oops... I was too focused on the image properties and forgot about the fact that the function is injective</p>

<a name="135299510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135299510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135299510">Simon Hudon (Oct 06 2018 at 05:22)</a>:</h4>
<p>I pushed something like that to <code>tutorial</code> and called it <code>map'</code></p>

<a name="135299600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135299600" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135299600">Simon Hudon (Oct 06 2018 at 05:24)</a>:</h4>
<p>Also, I finished the proof of <code>card_partitions_eq_card_partitions_fin</code> in the partition tutorial. It needed much more work than I thought</p>

<a name="135299601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135299601" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135299601">Bryan Gin-ge Chen (Oct 06 2018 at 05:24)</a>:</h4>
<p>Ah, perfect! I was so engrossed in my attempt that I missed your commit.</p>

<a name="135299610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135299610" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135299610">Simon Hudon (Oct 06 2018 at 05:25)</a>:</h4>
<p>The big changes that I made was using <code>finset.sup</code> in the formulation of partition instead of using <code>multiset</code>s which required a few lemmas in <code>finset</code></p>

<a name="135300028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135300028" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135300028">Bryan Gin-ge Chen (Oct 06 2018 at 05:40)</a>:</h4>
<p>Very nice! Using <code>sup</code> is much cleaner than the hack I was using with multiset.</p>
<p><a href="https://gist.github.com/bryangingechen/4ba169f7db65711a07643cf213039049#file-partitions-lean-L282" target="_blank" title="https://gist.github.com/bryangingechen/4ba169f7db65711a07643cf213039049#file-partitions-lean-L282">Here's what I had</a>. Now that I've looked at what you did, I see there's still a ton of stuff needed to fill in the sorry at line 292. In particular I hadn't even started on something like <code>partitions_congr</code> yet and that was definitely also necessary.</p>

<a name="135300233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135300233" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135300233">David Michael Roberts (Oct 06 2018 at 05:48)</a>:</h4>
<blockquote>
<blockquote>
<blockquote>
<p>"We now do a big song and dance to replace an object with a canonically isomorphic object". I'm sure the mathematicians would be fascinated :-)</p>
</blockquote>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>, have you seen <span class="user-mention" data-user-id="130272">@David Michael Roberts</span> attempt to summarise the latest disagreement between Mochizuki and Scholze? &lt;<a href="https://thehighergeometer.files.wordpress.com/2018/09/mochizuki_final1.pdf" target="_blank" title="https://thehighergeometer.files.wordpress.com/2018/09/mochizuki_final1.pdf">https://thehighergeometer.files.wordpress.com/2018/09/mochizuki_final1.pdf</a>&gt;. It's very much about whether such replacements were valid or not.</p>
</blockquote>
<p><span class="user-mention" data-user-id="130272">@David Michael Roberts</span> Thanks for writing these!</p>
</blockquote>
<p>You're welcome!</p>

<a name="135300977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135300977" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135300977">Bryan Gin-ge Chen (Oct 06 2018 at 06:16)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> Just a heads-up, I'm rebuilding tutorial and I think your changes to <code>ext</code> have broken the proofs of various things in category_theory and holor.</p>

<a name="135300987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135300987" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135300987">Simon Hudon (Oct 06 2018 at 06:17)</a>:</h4>
<p>Sorry about that. You can revert them for now.</p>

<a name="135301074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135301074" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135301074">Simon Hudon (Oct 06 2018 at 06:20)</a>:</h4>
<p>For the last <code>sorry</code>, do you need the lattice to be different from the lattice on finite sets?</p>

<a name="135301119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135301119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135301119">Simon Hudon (Oct 06 2018 at 06:22)</a>:</h4>
<p>Ok, I see your definition of subset. I'll pick it up tomorrow if you haven't managed to solve it</p>

<a name="135301126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135301126" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135301126">Bryan Gin-ge Chen (Oct 06 2018 at 06:23)</a>:</h4>
<p>Yeah, I was thinking of implementing as a bonus <a href="https://en.wikipedia.org/wiki/Partition_of_a_set#Refinement_of_partitions" target="_blank" title="https://en.wikipedia.org/wiki/Partition_of_a_set#Refinement_of_partitions">the lattice structure described here</a>.</p>

<a name="135301169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135301169" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135301169">Simon Hudon (Oct 06 2018 at 06:25)</a>:</h4>
<p>Ah! I see! You can somehow decrease a partition by taking one of its parts and splitting it, right?</p>

<a name="135301174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135301174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135301174">Bryan Gin-ge Chen (Oct 06 2018 at 06:25)</a>:</h4>
<p>Exactly.</p>

<a name="135301305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135301305" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135301305">Bryan Gin-ge Chen (Oct 06 2018 at 06:30)</a>:</h4>
<p>I think I could muddle my way through that eventually, though you're definitely welcome to work on it if you want to. I'd also appreciate comments on the other proofs / tutorial text that I've added if you've had a chance to look at them.</p>

<a name="135301647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135301647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135301647">Mario Carneiro (Oct 06 2018 at 06:45)</a>:</h4>
<p>If you use equivalence relations instead of partitions, this follows from the fact that equivalence relations have a Moore structure (they are closed under arbitrary intersection), so they have a complete lattice structure</p>

<a name="135301756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135301756" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135301756">Johan Commelin (Oct 06 2018 at 06:49)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> <a href="https://github.com/leanprover-community/mathlib/blob/tutorials/tutorials/partitions.lean#L109" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/tutorials/tutorials/partitions.lean#L109">https://github.com/leanprover-community/mathlib/blob/tutorials/tutorials/partitions.lean#L109</a> Couldn't you just compare the <code>multiset.join</code> to the <code>multiset</code> that underlies our <code>finset</code>?</p>

<a name="135301989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135301989" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135301989">Johan Commelin (Oct 06 2018 at 06:58)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> Consider adding an example to <a href="https://github.com/leanprover-community/mathlib/blob/tutorials/tutorials/partitions.lean#L193" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/tutorials/tutorials/partitions.lean#L193">https://github.com/leanprover-community/mathlib/blob/tutorials/tutorials/partitions.lean#L193</a> where the issue is multiplicity &gt; 1.</p>

<a name="135302186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135302186" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135302186">Bryan Gin-ge Chen (Oct 06 2018 at 07:06)</a>:</h4>
<blockquote>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> <a href="https://github.com/leanprover-community/mathlib/blob/tutorials/tutorials/partitions.lean#L109" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/tutorials/tutorials/partitions.lean#L109">https://github.com/leanprover-community/mathlib/blob/tutorials/tutorials/partitions.lean#L109</a> Couldn't you just compare the <code>multiset.join</code> to the <code>multiset</code> that underlies our <code>finset</code>?</p>
</blockquote>
<p>Thanks for pointing this out. In fact, Simon has created a better solution for this using <code>sup</code> which is used in <code>partition_of_disjoint_union</code> right below. I'll edit...</p>
<p>I've added this example:</p>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">eval</span> <span class="o">(</span><span class="n">is_partition</span> <span class="o">({{</span><span class="mi">0</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">}}</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">4</span><span class="o">)))</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="c1">-- ff</span>
</pre></div>

<a name="135302235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135302235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135302235">Mario Carneiro (Oct 06 2018 at 07:08)</a>:</h4>
<p>I think this file could stand to be generalized quite a bit. I would want to see partitions defined as equivalence relations, forget the finiteness constraint, and forget the finset representatives</p>

<a name="135302244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135302244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135302244">Mario Carneiro (Oct 06 2018 at 07:08)</a>:</h4>
<p>Then, given this, you can define the Bell numbers by a recurrence (so they compute fast), and prove that the number of partitions on a finite set is a bell number</p>

<a name="135302257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135302257" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135302257">Mario Carneiro (Oct 06 2018 at 07:09)</a>:</h4>
<p>At the same time, you can define an efficiently computable finset representation of a partition by recursion rather than filtering the universe</p>

<a name="135302304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135302304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135302304">Mario Carneiro (Oct 06 2018 at 07:10)</a>:</h4>
<p>this both proves the recursion scheme for calculating its size, and also gives an efficiently computable partition function on finset</p>

<a name="135302314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135302314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135302314">Bryan Gin-ge Chen (Oct 06 2018 at 07:11)</a>:</h4>
<p>That sounds cool. Is there a good place to read about this approach?</p>

<a name="135302320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135302320" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135302320">Mario Carneiro (Oct 06 2018 at 07:11)</a>:</h4>
<p>not particularly... basically finsets are bad for proving stuff when you don't need finiteness explicitly</p>

<a name="135302360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135302360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135302360">Mario Carneiro (Oct 06 2018 at 07:12)</a>:</h4>
<p>you should use sets instead</p>

<a name="135302363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135302363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135302363">Mario Carneiro (Oct 06 2018 at 07:12)</a>:</h4>
<p>especially since "partition" generalizes so nicely to the infinite case</p>

<a name="135302371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135302371" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135302371">Mario Carneiro (Oct 06 2018 at 07:13)</a>:</h4>
<p>If you need more details about some part about that let me know</p>

<a name="135302418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135302418" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135302418">Mario Carneiro (Oct 06 2018 at 07:14)</a>:</h4>
<p>It would be nice to have the <a href="https://en.wikipedia.org/wiki/Bell_triangle" target="_blank" title="https://en.wikipedia.org/wiki/Bell_triangle">Bell triangle</a> used for calculating and defining the bell numbers</p>

<a name="135302637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135302637" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135302637">Johan Commelin (Oct 06 2018 at 07:23)</a>:</h4>
<p>I guess Lean automatically memoizes computations? If I define <code>A n k = A (n-1) k + A n (k - 1)</code>, and I ask it to compute <code>A 10 5</code>, does that lead to combinatorial explosion? Or will it efficiently remember the terms it computed?</p>

<a name="135302638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135302638" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135302638">Johan Commelin (Oct 06 2018 at 07:23)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> Do you know this?</p>

<a name="135302991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135302991" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135302991">Mario Carneiro (Oct 06 2018 at 07:36)</a>:</h4>
<p>Just for fun:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">bell_aux₁</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="n">list</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="n">list</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">n</span> <span class="bp">::</span> <span class="n">l</span><span class="o">)</span>

<span class="n">def</span> <span class="n">bell_triangle</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">list</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="n">list</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">[]</span> <span class="o">:=</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="o">[])</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">(</span><span class="n">m</span> <span class="bp">::</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="k">let</span> <span class="n">n&#39;</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="k">in</span> <span class="n">bell_aux₁</span> <span class="n">n&#39;</span> <span class="o">(</span><span class="n">bell_triangle</span> <span class="n">n&#39;</span> <span class="n">l</span><span class="o">)</span>

<span class="n">def</span> <span class="n">bell_aux</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="n">list</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="o">:=</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">[])</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="k">let</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">bell_aux</span> <span class="n">k</span> <span class="k">in</span> <span class="n">bell_aux₁</span> <span class="n">n</span> <span class="o">(</span><span class="n">bell_triangle</span> <span class="n">n</span> <span class="n">l</span><span class="o">)</span>

<span class="n">def</span> <span class="n">bell</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">bell_aux</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>

<span class="bp">#</span><span class="kn">eval</span> <span class="n">list</span><span class="bp">.</span><span class="n">map</span> <span class="n">bell</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">range</span> <span class="mi">20</span><span class="o">)</span>
</pre></div>

<a name="135303001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135303001" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135303001">Mario Carneiro (Oct 06 2018 at 07:37)</a>:</h4>
<p>lean does not memoize things unless you tell it to. This is one of the major shortcomings of lean 3</p>

<a name="135303250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135303250" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135303250">Bryan Gin-ge Chen (Oct 06 2018 at 07:47)</a>:</h4>
<p>Is the efficient partition function on finset that you had in mind one based on the "Combinatorial Interpretation" in the Bell triangle wiki page?</p>

<a name="135303251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135303251" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135303251">Johan Commelin (Oct 06 2018 at 07:47)</a>:</h4>
<p>Do we have a <code>memoize</code> monad that automagically does that for you?</p>

<a name="135303295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135303295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135303295">Mario Carneiro (Oct 06 2018 at 07:48)</a>:</h4>
<p>I PR'd one to core back in the day, rejected</p>

<a name="135303301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135303301" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135303301">Mario Carneiro (Oct 06 2018 at 07:49)</a>:</h4>
<p>To do it in pure lean requires explicit maintenance of the accumulator data, in this case the <code>list nat</code> that forms the lines of the triangle as we progress</p>

<a name="135303345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135303345" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135303345">Johan Commelin (Oct 06 2018 at 07:50)</a>:</h4>
<p>Right, but a pure Lean version might already be nice.</p>

<a name="135303346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135303346" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135303346">Mario Carneiro (Oct 06 2018 at 07:50)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> Yes. That description of how to count partitions is exactly what you need to write a partition generating algorithm that obviously has length B_n</p>

<a name="135303357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135303357" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135303357">Mario Carneiro (Oct 06 2018 at 07:51)</a>:</h4>
<p>Lean can't figure out your accumulator data for you, at least not effectively</p>

<a name="135303361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135303361" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135303361">Mario Carneiro (Oct 06 2018 at 07:51)</a>:</h4>
<p>For example it's not completely obvious that you can calculate fibonacci numbers with a two number sliding window</p>

<a name="135303406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135303406" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135303406">Johan Commelin (Oct 06 2018 at 07:53)</a>:</h4>
<p>I was thinking about a naive cache that would just remember all Fibonacci numbers. Don't bother about two number sliding windows. Or am I missing something?</p>

<a name="135303459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135303459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135303459">Mario Carneiro (Oct 06 2018 at 07:55)</a>:</h4>
<p>Well, yes that can be done, indeed that's how lean used to work</p>

<a name="135303498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135303498" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135303498">Mario Carneiro (Oct 06 2018 at 07:56)</a>:</h4>
<p>Leo decided that this causes unpredictable performance characteristics (since it depends on how the equation compiler compiles your code)</p>

<a name="135303500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135303500" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135303500">Mario Carneiro (Oct 06 2018 at 07:56)</a>:</h4>
<p>so now it just follows what you tell it, and if you use a bad algorithm then it's your fault</p>

<a name="135318182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135318182" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135318182">Bryan Gin-ge Chen (Oct 06 2018 at 16:48)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> I've just pushed a commit that moves the more general lemmas you wrote in <code>partitions</code> to more appropriate places in <code>data.finset</code>, <code>data.fintype</code> and <code>data.equiv.basic</code>. Also, one of the <code>tactic.tfae</code> tests still fails, even after I reverted the <code>tactic.ext</code> change.</p>
<p>For now I think I'll leave the tutorial partitions file alone and see if I can make some progress working on Mario's idea in another file. If that turns out well that we can then decide whether we want to completely replace what we've done or perhaps include both approaches.</p>

<a name="135327337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135327337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135327337">Simon Hudon (Oct 06 2018 at 22:01)</a>:</h4>
<p>The <code>tfae</code> problem is separate. Maybe we should just remove it from master while I fix it</p>

<a name="135333218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135333218" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135333218">Bryan Gin-ge Chen (Oct 07 2018 at 01:37)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I'm stuck on something dumb:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">lattice</span>

<span class="kn">open</span> <span class="n">function</span>

<span class="kn">variable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="c">/-</span><span class="cm"> We define a partition as a family of sets associated to an equivalence relation on a set -/</span>

<span class="kn">structure</span> <span class="n">partition</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">blocks</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">empty_not_mem_blocks</span> <span class="o">:</span> <span class="n">blocks</span><span class="o">)</span>
<span class="o">(</span><span class="n">blocks_partition</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">blocks</span> <span class="bp">∧</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">b</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">b&#39;</span> <span class="err">∈</span> <span class="n">blocks</span><span class="o">,</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">b&#39;</span> <span class="bp">→</span> <span class="n">a</span> <span class="err">∉</span> <span class="n">b&#39;</span><span class="o">)</span>

<span class="n">def</span> <span class="n">coe_of_setoid</span> <span class="o">[</span><span class="n">setoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">blocks</span> <span class="o">:=</span> <span class="o">{</span><span class="n">t</span> <span class="bp">|</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">s₁</span> <span class="n">s₂</span><span class="o">),</span> <span class="n">s₁</span> <span class="err">∈</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">s₂</span> <span class="err">∈</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">s₁</span> <span class="bp">≈</span> <span class="n">s₂</span> <span class="o">},</span>
  <span class="n">empty_not_mem_blocks</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">blocks_partition</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="o">}</span>
</pre></div>


<p>I can't seem to prove that the empty set isn't contained in <code>blocks</code>. I also tried <code>blocks :=  {t | ∃ a, s ∈ t → a ≈ s}</code> without success.</p>

<a name="135333262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135333262" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135333262">Mario Carneiro (Oct 07 2018 at 01:39)</a>:</h4>
<p><code>blocks := {t | ∃ a, {b | a ≈ b} = t}</code></p>

<a name="135333265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135333265" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135333265">Mario Carneiro (Oct 07 2018 at 01:39)</a>:</h4>
<p>You can also write this as the range of a function</p>

<a name="135333318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135333318" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135333318">Mario Carneiro (Oct 07 2018 at 01:41)</a>:</h4>
<blockquote>
<p><code>blocks :=  {t | ∃ a, s ∈ t → a ≈ s}</code></p>
</blockquote>
<p>This gives the set of subsets of some equivalence class</p>
<blockquote>
<p><code>blocks := {t | ∀ (s₁ s₂), s₁ ∈ t → s₂ ∈ t → s₁ ≈ s₂ }</code></p>
</blockquote>
<p>This gives the set of unions of equivalence classes</p>

<a name="135333360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135333360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135333360">Mario Carneiro (Oct 07 2018 at 01:42)</a>:</h4>
<blockquote>
<p><code>(empty_not_mem_blocks : blocks)</code></p>
</blockquote>
<p>The type on this isn't quite right...</p>

<a name="135333367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135333367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135333367">Mario Carneiro (Oct 07 2018 at 01:43)</a>:</h4>
<p>But I don't think you should think much about this definition of partition. As far as possible you should just use equivalence relations</p>

<a name="135333410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135333410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135333410">Bryan Gin-ge Chen (Oct 07 2018 at 01:44)</a>:</h4>
<p>Ah, thanks! I need to be more careful...</p>
<p>I do have <code>(empty_not_mem_blocks : ∅ ∉ blocks)</code>. I think I accidentally deleted it when I was  writing my previous message.</p>

<a name="135333420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135333420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135333420">Mario Carneiro (Oct 07 2018 at 01:45)</a>:</h4>
<p>I would hope to be able to use <code>quot</code> to talk about equivalence classes, rather than sets</p>

<a name="135333422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135333422" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135333422">Mario Carneiro (Oct 07 2018 at 01:45)</a>:</h4>
<p>but that doesn't fit in this definition of partition</p>

<a name="135333519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135333519" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135333519">Bryan Gin-ge Chen (Oct 07 2018 at 01:49)</a>:</h4>
<p>OK, so I should just try to define poset / lattice instances on <code>setoid α</code>.</p>

<a name="135333682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135333682" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135333682">Mario Carneiro (Oct 07 2018 at 01:55)</a>:</h4>
<p>yes, that should work</p>

<a name="135335317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135335317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135335317">Bryan Gin-ge Chen (Oct 07 2018 at 02:56)</a>:</h4>
<p>This works:</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="o">:</span> <span class="n">has_subset</span> <span class="o">(</span><span class="n">setoid</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">r₁</span> <span class="n">r₂</span><span class="o">,</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="k">let</span> <span class="n">r1</span> <span class="o">:=</span> <span class="n">r₁</span><span class="bp">.</span><span class="n">r</span> <span class="k">in</span> <span class="k">let</span> <span class="n">r2</span> <span class="o">:=</span> <span class="n">r₂</span><span class="bp">.</span><span class="n">r</span> <span class="k">in</span> <span class="o">{</span><span class="n">b</span> <span class="bp">|</span> <span class="n">r1</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="err">⊆</span> <span class="o">{</span><span class="n">b</span> <span class="bp">|</span> <span class="n">r2</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span><span class="bp">⟩</span>
</pre></div>


<p>This fails:</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">a22</span> <span class="o">:</span> <span class="n">has_subset</span> <span class="o">(</span><span class="n">setoid</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">r₁</span> <span class="n">r₂</span><span class="o">,</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="o">{</span><span class="n">b</span> <span class="bp">|</span> <span class="n">r₁</span><span class="bp">.</span><span class="n">r</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="err">⊆</span> <span class="o">{</span><span class="n">b</span> <span class="bp">|</span> <span class="n">r₂</span><span class="bp">.</span><span class="n">r</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span><span class="bp">⟩</span>
<span class="c">/-</span><span class="cm"> invalid field notation, function &#39;setoid.r&#39; does not have explicit argument with type (setoid ...) -/</span>
</pre></div>


<p>Anyone know why?</p>

<a name="135336689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135336689" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135336689">Bryan Gin-ge Chen (Oct 07 2018 at 03:47)</a>:</h4>
<p>Usually the <code>simp</code> proves these equalities between structures, but not this time:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">setoid_eq_iff_r_eq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">r₁</span> <span class="n">r₂</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">α</span><span class="o">},</span> <span class="n">r₁</span> <span class="bp">=</span> <span class="n">r₂</span> <span class="bp">↔</span> <span class="n">r₁</span><span class="bp">.</span><span class="n">r</span> <span class="bp">=</span> <span class="n">r₂</span><span class="bp">.</span><span class="n">r</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">r1</span><span class="o">,</span> <span class="n">e1</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">r2</span><span class="o">,</span> <span class="n">e2</span><span class="bp">⟩</span>
<span class="o">:=</span> <span class="k">begin</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>


<p>What's the right way to do this? I don't know how to project out what I want from the equality <code>r₁ = r₂</code> between setoid structures.</p>

<a name="135337108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135337108" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135337108">Simon Hudon (Oct 07 2018 at 04:02)</a>:</h4>
<p>You can use <code>cases</code> on <code>r1</code>, <code>r2</code>, split the equivalence and use <code>cases</code> on the equality assumption in both cases.</p>

<a name="135337309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135337309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135337309">Bryan Gin-ge Chen (Oct 07 2018 at 04:10)</a>:</h4>
<p>Thanks. Did you mean something like this?</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">eq_iff_r_eq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">r₁</span> <span class="n">r₂</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">α</span><span class="o">},</span> <span class="n">r₁</span> <span class="bp">=</span> <span class="n">r₂</span> <span class="bp">↔</span> <span class="n">r₁</span><span class="bp">.</span><span class="n">r</span> <span class="bp">=</span> <span class="n">r₂</span><span class="bp">.</span><span class="n">r</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">r1</span><span class="o">,</span> <span class="n">e1</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">r2</span><span class="o">,</span> <span class="n">e2</span><span class="bp">⟩</span>
<span class="o">:=</span> <span class="k">begin</span>
  <span class="n">intros</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span>  <span class="o">}</span>
<span class="kn">end</span>
</pre></div>


<p>I'm getting a rather unhelpful error: <code>cases tactic failed, unexpected failure when introducing auxiliary equatilies</code>.</p>

<a name="135337320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135337320" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135337320">Simon Hudon (Oct 07 2018 at 04:11)</a>:</h4>
<p>That's odd. Try <code>injection h</code>, maybe that'll work</p>

<a name="135337464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135337464" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135337464">Bryan Gin-ge Chen (Oct 07 2018 at 04:17)</a>:</h4>
<p>Yep, that worked. I don't know how to use <code>cases</code> in the second case though, since now the equality between structures is now in the goal.</p>

<a name="135337504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135337504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135337504">Simon Hudon (Oct 07 2018 at 04:18)</a>:</h4>
<p>you can do <code>subst h</code></p>

<a name="135337558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135337558" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135337558">Bryan Gin-ge Chen (Oct 07 2018 at 04:21)</a>:</h4>
<p><code>intro h, subst h</code> gives this error:</p>
<div class="codehilite"><pre><span></span><span class="n">subst</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="kn">hypothesis</span> <span class="err">&#39;</span><span class="n">h&#39;</span> <span class="n">is</span> <span class="n">not</span> <span class="n">of</span> <span class="n">the</span> <span class="n">form</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">t</span><span class="o">)</span> <span class="n">or</span> <span class="o">(</span><span class="n">t</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">eq_iff_r_eq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">r₁</span> <span class="n">r₂</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">α</span><span class="o">},</span> <span class="n">r₁</span> <span class="bp">=</span> <span class="n">r₂</span> <span class="bp">↔</span> <span class="bp">@</span><span class="n">r</span> <span class="n">α</span> <span class="n">r₁</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">r</span> <span class="n">α</span> <span class="n">r₂</span><span class="o">,</span>
<span class="n">r1</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">e1</span> <span class="o">:</span> <span class="bp">@</span><span class="n">equivalence</span> <span class="n">α</span> <span class="n">r1</span><span class="o">,</span>
<span class="n">r2</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">e2</span> <span class="o">:</span> <span class="bp">@</span><span class="n">equivalence</span> <span class="n">α</span> <span class="n">r2</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="bp">@</span><span class="n">r</span> <span class="n">α</span> <span class="o">(</span><span class="bp">@</span><span class="n">mk</span> <span class="n">α</span> <span class="n">r1</span> <span class="n">e1</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">r</span> <span class="n">α</span> <span class="o">(</span><span class="bp">@</span><span class="n">mk</span> <span class="n">α</span> <span class="n">r2</span> <span class="n">e2</span><span class="o">)</span>
<span class="err">⊢</span> <span class="bp">@</span><span class="n">mk</span> <span class="n">α</span> <span class="n">r1</span> <span class="n">e1</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">mk</span> <span class="n">α</span> <span class="n">r2</span> <span class="n">e2</span>
</pre></div>

<a name="135337605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135337605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135337605">Simon Hudon (Oct 07 2018 at 04:22)</a>:</h4>
<p>What if you do <code>dsimp at h</code> first?</p>

<a name="135337610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135337610" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135337610">Bryan Gin-ge Chen (Oct 07 2018 at 04:22)</a>:</h4>
<p>Ah, perfect! Thanks so much!</p>

<a name="135337663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135337663" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135337663">Simon Hudon (Oct 07 2018 at 04:24)</a>:</h4>
<p><span class="emoji emoji-1f44d" title="+1">:+1:</span></p>

<a name="135340678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135340678" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135340678">Bryan Gin-ge Chen (Oct 07 2018 at 06:20)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/tutorials/order/partitions.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/tutorials/order/partitions.lean">Here's</a> the WIP complete lattice instance on setoids. I've completed the poset stuff and inf, top, bot but not much else, so a lot of the theorems are just broken skeletons from e.g. data.set.basic.</p>
<p>Is there a clean way of defining the sup / union / join operation? This boils down to something like two elements a z are equivalent in the transitive closure of r1 and r2 if there exists a finite chain of equivalences r1 a b, r2 b c, r1 c d, ... , r_ y z.</p>

<a name="135340789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135340789" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135340789">Simon Hudon (Oct 07 2018 at 06:25)</a>:</h4>
<p>Aren't the relations in the setoid equivalences? They should be already transitive, symmetric and reflexive. sup and inf of <code>f : a -&gt; b -&gt; b -&gt; Prop</code> should be <code>λ x y, ∃ i, f i x y</code> and <code>λ x y, ∀ i, f i x y</code> respectively</p>

<a name="135340915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135340915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135340915">Mario Carneiro (Oct 07 2018 at 06:29)</a>:</h4>
<p>Note that <code>eqv_gen</code> will allow you to take the "span" of an arbitrary relation, so you can just union up a bunch of things and take the span for the supremum</p>

<a name="135341333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135341333" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135341333">Simon Hudon (Oct 07 2018 at 06:44)</a>:</h4>
<p>What's the span of a relation?</p>

<a name="135341672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135341672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135341672">Bryan Gin-ge Chen (Oct 07 2018 at 06:58)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> I'm not sure I understand. I guess your <code>f</code> is a family of equivalence relations indexed by <code>a</code>? I think your inf agrees with <a href="https://github.com/leanprover-community/mathlib/blob/tutorials/order/partitions.lean#L87" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/tutorials/order/partitions.lean#L87">what I have</a>, but I don't think your sup is the correct one. Consider the following two equivalence relations r1 and r2 on the nats, the equivalence classes of r1 are {0,1}, {2,3}, {4,5}, ... and the equivalence classes of r2 are {0}, {1,2}, {3,4}, {5,6}, ....  The sup of r1 and r2 has only one equivalence class equal to nat, so in particular 0 is equivalent to 1000, but you need a very long chain of r1 and r2 relations to witness it.</p>

<a name="135341680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135341680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135341680">Mario Carneiro (Oct 07 2018 at 06:59)</a>:</h4>
<p><code>eqv_gen</code> is the equivalence closure of a relation, this is what Bryan wants</p>

<a name="135341740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135341740" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135341740">Mario Carneiro (Oct 07 2018 at 07:01)</a>:</h4>
<p>Because equivalence relations are closed under arbitrary intersection, you can construct a generic "span" function that gets the smallest equivalence relation including some specified relation, and <code>eqv_gen</code> is this</p>

<a name="135341836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135341836" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135341836">Bryan Gin-ge Chen (Oct 07 2018 at 07:05)</a>:</h4>
<p>Thanks Mario! <code>eqv_gen</code> looks promising. It will probably take me some time to figure out how to use it though.</p>

<a name="135341919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135341919" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135341919">Mario Carneiro (Oct 07 2018 at 07:08)</a>:</h4>
<p>In your case I think you want to take the <code>eqv_gen</code> of Simon's relation <code>λ x y, ∃ i, f i x y</code></p>

<a name="135342114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135342114" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135342114">Bryan Gin-ge Chen (Oct 07 2018 at 07:16)</a>:</h4>
<p>OK great, I think I'm starting to get it. I think I would have never found this definition on my own.</p>

<a name="135342177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135342177" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135342177">Mario Carneiro (Oct 07 2018 at 07:19)</a>:</h4>
<p>Note that it's not required to use that definition, and indeed there is a more "abstract nonsense" definition that makes the proof obligations easier. Define the intersection of an arbitrary indexed family of equivalence relations using Simon's definition; it is straightforward to show this is an equivalence relation. From this, you can define every other element of the complete lattice structure, the inf, the sup, the Sup, the top and bot</p>

<a name="135342226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135342226" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135342226">Simon Hudon (Oct 07 2018 at 07:20)</a>:</h4>
<p>Do you use "abstract nonsense" interchangeably with category theory?</p>

<a name="135342301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135342301" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135342301">Mario Carneiro (Oct 07 2018 at 07:23)</a>:</h4>
<p>in this case it's lattice theory</p>

<a name="135342337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135342337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135342337">Mario Carneiro (Oct 07 2018 at 07:24)</a>:</h4>
<p>but I guess posets are categories, so sure</p>

<a name="135342344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135342344" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135342344">Bryan Gin-ge Chen (Oct 07 2018 at 07:25)</a>:</h4>
<p>So I see that the intersection works, but how do I get the union from it? Would I have to define it using the finite chains of relations manually?</p>

<a name="135342950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135342950" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135342950">Simon Hudon (Oct 07 2018 at 07:46)</a>:</h4>
<p>I haven't looked at that function too closely but I think you could take the union as I defined it and take its transitive, symmetric, reflexive closure</p>

<a name="135342951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135342951" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135342951">Simon Hudon (Oct 07 2018 at 07:46)</a>:</h4>
<p>Does that make sense?</p>

<a name="135342999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135342999" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135342999">Kevin Buzzard (Oct 07 2018 at 07:48)</a>:</h4>
<blockquote>
<p>Do you use "abstract nonsense" interchangeably with category theory?</p>
</blockquote>
<p>This is the most common usage of the phrase "abstract nonsense" when you see it in the mathematical literature, but the category theory in question can range from a simple diagram chase to the adjoint functor theorem and possibly beyond.</p>

<a name="135343827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135343827" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135343827">Mario Carneiro (Oct 07 2018 at 08:20)</a>:</h4>
<p>You don't need to take any reflexive symmetric closures with the approach I suggested</p>

<a name="135343837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135343837" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135343837">Mario Carneiro (Oct 07 2018 at 08:20)</a>:</h4>
<p>Given an intersection construction, you can define the supremum as the intersection of all equivalence classes containing the inputs</p>

<a name="135343843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135343843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135343843">Patrick Massot (Oct 07 2018 at 08:21)</a>:</h4>
<p>(deleted)</p>

<a name="135343905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135343905" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135343905">Simon Hudon (Oct 07 2018 at 08:24)</a>:</h4>
<p>But what about the union?</p>

<a name="135343945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135343945" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135343945">Mario Carneiro (Oct 07 2018 at 08:24)</a>:</h4>
<p>that is the union</p>

<a name="135343949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135343949" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135343949">Mario Carneiro (Oct 07 2018 at 08:24)</a>:</h4>
<p>i.e. <code>a \sqcup b = Inf {s | a &lt;= s /\ b &lt;= s}</code></p>

<a name="135343955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135343955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135343955">Mario Carneiro (Oct 07 2018 at 08:25)</a>:</h4>
<p>similarly for arbitrary union</p>

<a name="135343958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135343958" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135343958">Bryan Gin-ge Chen (Oct 07 2018 at 08:25)</a>:</h4>
<blockquote>
<p>Given an intersection construction, you can define the supremum as the intersection of all equivalence classes containing the inputs</p>
</blockquote>
<p>Typo here? Should the supremum be defined in terms of the union of [...]</p>

<a name="135343962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135343962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135343962">Mario Carneiro (Oct 07 2018 at 08:25)</a>:</h4>
<p>no</p>

<a name="135343971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135343971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135343971">Mario Carneiro (Oct 07 2018 at 08:25)</a>:</h4>
<p>Think of it as an approximation of the union "from above"</p>

<a name="135344018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135344018" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135344018">Bryan Gin-ge Chen (Oct 07 2018 at 08:26)</a>:</h4>
<p>Ah, OK.</p>

<a name="135344019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135344019" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135344019">Mario Carneiro (Oct 07 2018 at 08:26)</a>:</h4>
<p>the union is the LEAST upper bound, so you can just take the infimum of upper bounds</p>

<a name="135344079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135344079" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135344079">Kenny Lau (Oct 07 2018 at 08:28)</a>:</h4>
<p>are there any <code>sorry</code> that I can fill?</p>

<a name="135344146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135344146" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135344146">Bryan Gin-ge Chen (Oct 07 2018 at 08:31)</a>:</h4>
<p>Feel free to consider any broken proof in my files as a sorry. I'm not actively working on it at the moment.</p>

<a name="135344231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135344231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135344231">Kenny Lau (Oct 07 2018 at 08:34)</a>:</h4>
<p>do I need to compile for 1 hour to find out which proof is broken?</p>

<a name="135344301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135344301" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135344301">Bryan Gin-ge Chen (Oct 07 2018 at 08:37)</a>:</h4>
<p>Ah, OK. Well <code>inter_subset_right</code>, <code>inter_subset_left</code>, <code>subset_inter</code> are broken but the statements should be right. You can just delete their proofs and fill them in. Let me see if there are others.</p>

<a name="135344303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135344303" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135344303">Kenny Lau (Oct 07 2018 at 08:37)</a>:</h4>
<p>again, I need to compile for 1 hour to build this branch</p>

<a name="135344306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135344306" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135344306">Kenny Lau (Oct 07 2018 at 08:37)</a>:</h4>
<p>so I don't really know what I can do</p>

<a name="135344308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135344308" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135344308">Kenny Lau (Oct 07 2018 at 08:37)</a>:</h4>
<p>how do other people work on this branch?</p>

<a name="135344350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135344350" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135344350">Kenny Lau (Oct 07 2018 at 08:38)</a>:</h4>
<p>how does <span class="user-mention" data-user-id="110026">@Simon Hudon</span> work on this branch?</p>

<a name="135344402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135344402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135344402">Bryan Gin-ge Chen (Oct 07 2018 at 08:40)</a>:</h4>
<p>I guess we've all got faster computers? It takes my computer about 10 minutes to compile mathlib.</p>

<a name="135344423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135344423" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135344423">Kenny Lau (Oct 07 2018 at 08:41)</a>:</h4>
<p>do you have 24 threads?</p>

<a name="135344477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135344477" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135344477">Bryan Gin-ge Chen (Oct 07 2018 at 08:43)</a>:</h4>
<p>The Activity monitor says lean is using 14 right now. I just started another build after switching branches. Let's see how long it takes.</p>

<a name="135344480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135344480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135344480">Kenny Lau (Oct 07 2018 at 08:43)</a>:</h4>
<p>can't you see how many threads you have?</p>

<a name="135344635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135344635" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135344635">Kenny Lau (Oct 07 2018 at 08:48)</a>:</h4>
<p><a href="/user_uploads/3121/8KeKjpR28C3y92LYg_XEHFbR/2018-10-07.png" target="_blank" title="2018-10-07.png">2018-10-07.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/8KeKjpR28C3y92LYg_XEHFbR/2018-10-07.png" target="_blank" title="2018-10-07.png"><img src="/user_uploads/3121/8KeKjpR28C3y92LYg_XEHFbR/2018-10-07.png"></a></div>

<a name="135344636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135344636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135344636">Bryan Gin-ge Chen (Oct 07 2018 at 08:48)</a>:</h4>
<p>Do you mean threads across all processes? It's something like 1800 threads and 360 processes. I'm on a 6 core macbook pro.</p>

<a name="135344642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135344642" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135344642">Kenny Lau (Oct 07 2018 at 08:49)</a>:</h4>
<p>I have 2 cores and 4 threads</p>

<a name="135344643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135344643" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135344643">Kenny Lau (Oct 07 2018 at 08:49)</a>:</h4>
<p>I'm on a windows surface</p>

<a name="135344780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135344780" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135344780">Bryan Gin-ge Chen (Oct 07 2018 at 08:54)</a>:</h4>
<p>That's really amazing. I'm sure the surface has its advantages. </p>
<p>Oh yeah, you can now bind a key to toggle the infoview live updating in the VS code extension, in case you want to pause the tactic state while lean is busy. It's <code>lean.infoview.toggleUpdating</code> in the keyboard shortcuts.</p>

<a name="135344793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135344793" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135344793">Bryan Gin-ge Chen (Oct 07 2018 at 08:55)</a>:</h4>
<p>This branch seems to be all kinds of screwed up. There's something wrong in <code>data.finset</code> that I have to look at.</p>

<a name="135344845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135344845" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135344845">Kenny Lau (Oct 07 2018 at 08:57)</a>:</h4>
<blockquote>
<p>That's really amazing. I'm sure the surface has its advantages. </p>
</blockquote>
<p>I guess it isn't designed to build lean</p>

<a name="135345229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135345229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135345229">Mario Carneiro (Oct 07 2018 at 09:11)</a>:</h4>
<p>Yes, an ultrabook is not intended for heavy workstation programming</p>

<a name="135345608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135345608" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135345608">Bryan Gin-ge Chen (Oct 07 2018 at 09:25)</a>:</h4>
<p>tutorial should now build properly. <code>order.partitions</code> is also filled out with sorries, so it should be more clear what's missing.</p>

<a name="135359879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135359879" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135359879">Bryan Gin-ge Chen (Oct 07 2018 at 17:32)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/tutorials/order/partitions.lean#L68" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/tutorials/order/partitions.lean#L68">Here's my definition for union using <code>eqv_gen</code></a> (is this right?).  Now this is what I need to show <code>union_subset</code> (forgive any typos introduced by my manual prettifying...):</p>
<div class="codehilite"><pre><span></span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">r₁</span> <span class="n">r₂</span> <span class="n">r₃</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">α</span><span class="o">,</span>
<span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="n">r1</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="bp">@</span><span class="n">eqv_gen</span> <span class="n">α</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">s₁</span> <span class="n">s₂</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">@</span><span class="n">r</span> <span class="n">α</span> <span class="n">r₁</span> <span class="n">s₁</span> <span class="n">s₂</span> <span class="bp">∨</span> <span class="bp">@</span><span class="n">r</span> <span class="n">α</span> <span class="n">r₂</span> <span class="n">s₁</span> <span class="n">s₂</span><span class="o">),</span>
<span class="n">r2</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">r</span> <span class="n">α</span> <span class="n">r₃</span><span class="o">,</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="n">a_1</span> <span class="o">:</span> <span class="n">r1</span> <span class="n">a</span> <span class="n">x</span><span class="o">,</span>
<span class="n">h23</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">@</span><span class="n">r</span> <span class="n">α</span> <span class="n">r₂</span> <span class="n">a</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">r2</span> <span class="n">a</span> <span class="n">y</span><span class="o">,</span>
<span class="n">h13</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">@</span><span class="n">r</span> <span class="n">α</span> <span class="n">r₁</span> <span class="n">a</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">r2</span> <span class="n">a</span> <span class="n">y</span>
<span class="err">⊢</span> <span class="n">r2</span> <span class="n">a</span> <span class="n">x</span>
</pre></div>


<p>Here's a very informal argument: <code>a_1</code> tells us that there's some finite chain of r₁  and r₂ equivalences between a and x, and and we then repeatedly apply h13 and h23 to each of the links of that chain to win. How do I do this?</p>

<a name="135365476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135365476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135365476">Kevin Buzzard (Oct 07 2018 at 20:56)</a>:</h4>
<p>I have only half-been paying attention to this thread (and indeed Zulip) but I have a little time before bed. You're trying to prove that if r,s,t are three equivalence relations on a set, and both s and t are subsets of r, then the equivalence relation generated by s and t is a subset of r, right? Do you have that if x is a random relation contained in an equivalence relation r then the equivalence relation generated by x is also contained in r? It's trivial from this, right?</p>

<a name="135365488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135365488" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135365488">Kevin Buzzard (Oct 07 2018 at 20:57)</a>:</h4>
<p>I'm asking if we have the universal property of "equivalence relation generated by".</p>

<a name="135365545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135365545" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135365545">Kenny Lau (Oct 07 2018 at 20:59)</a>:</h4>
<p>you mean <code>rec_on</code></p>

<a name="135365546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135365546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135365546">Kevin Buzzard (Oct 07 2018 at 20:59)</a>:</h4>
<p>This would be trivial if you knew that the equivalence relation generated by an arbitrary relation was equal to the intersection of all the equivalence relations containing this relation. Sorry I'm late to the party; there's a lot of other noise in this thread too.</p>

<a name="135365653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135365653" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135365653">Bryan Gin-ge Chen (Oct 07 2018 at 21:02)</a>:</h4>
<p>I think I can do what I want with <a href="https://github.com/leanprover/mathlib/blob/57194fa57e76721a517d6969ee88a6007f0722b3/logic/relation.lean#L367" target="_blank" title="https://github.com/leanprover/mathlib/blob/57194fa57e76721a517d6969ee88a6007f0722b3/logic/relation.lean#L367"><code>relation.eqv_gen_mono</code></a>. That might be the same thing that you're saying.</p>

<a name="135365655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135365655" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135365655">Kevin Buzzard (Oct 07 2018 at 21:02)</a>:</h4>
<p>Kenny you're right</p>

<a name="135365667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135365667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135365667">Kevin Buzzard (Oct 07 2018 at 21:03)</a>:</h4>
<p>Is the question "how do I fill in the sorry here: <a href="https://github.com/leanprover-community/mathlib/blob/1030f5324363a9213cf4b68f834fad0d124b8a13/order/partitions.lean#L110" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/1030f5324363a9213cf4b68f834fad0d124b8a13/order/partitions.lean#L110">https://github.com/leanprover-community/mathlib/blob/1030f5324363a9213cf4b68f834fad0d124b8a13/order/partitions.lean#L110</a> "?</p>

<a name="135365716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135365716" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135365716">Kevin Buzzard (Oct 07 2018 at 21:04)</a>:</h4>
<p>If so, I am suggesting that you first prove that for an arbitrary relation x and an equiv reln r, x is a subset of r iff the equiv reln generated by x is a subset of r</p>

<a name="135365717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135365717" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135365717">Kevin Buzzard (Oct 07 2018 at 21:04)</a>:</h4>
<p>and then the union thing is a triviality</p>

<a name="135365728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135365728" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135365728">Kevin Buzzard (Oct 07 2018 at 21:05)</a>:</h4>
<p>and Kenny is suggesting that that the universal property of the relation is just the recursor</p>

<a name="135365730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135365730" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135365730">Kevin Buzzard (Oct 07 2018 at 21:05)</a>:</h4>
<p>so this should be hopefully straightforward.</p>

<a name="135365733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135365733" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135365733">Kevin Buzzard (Oct 07 2018 at 21:05)</a>:</h4>
<p>Do you want me to try or am I answering the wrong question <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> ?</p>

<a name="135365828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135365828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135365828">Bryan Gin-ge Chen (Oct 07 2018 at 21:09)</a>:</h4>
<p>Yes, that was the question. I think I've solved it just now though:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">union_subset</span> <span class="o">{</span><span class="n">r₁</span> <span class="n">r₂</span> <span class="n">r₃</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h13</span> <span class="o">:</span> <span class="n">r₁</span> <span class="err">⊆</span> <span class="n">r₃</span><span class="o">)</span> <span class="o">(</span><span class="n">h23</span> <span class="o">:</span> <span class="n">r₂</span> <span class="err">⊆</span> <span class="n">r₃</span><span class="o">)</span> <span class="o">:</span> <span class="n">r₁</span> <span class="err">∪</span> <span class="n">r₂</span> <span class="err">⊆</span> <span class="n">r₃</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">subset_def</span><span class="o">]</span> <span class="n">at</span> <span class="n">h13</span> <span class="n">h23</span> <span class="err">⊢</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set</span><span class="bp">.</span><span class="n">subset_def</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_set_of_eq</span><span class="o">]</span> <span class="n">at</span> <span class="n">h13</span> <span class="n">h23</span> <span class="err">⊢</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">union_def</span><span class="o">,</span> <span class="n">rel_union</span><span class="o">],</span>
  <span class="n">intros</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hor</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">x</span><span class="o">,</span> <span class="bp">@</span><span class="n">r</span> <span class="n">α</span> <span class="n">r₁</span> <span class="n">a</span> <span class="n">x</span> <span class="bp">∨</span> <span class="bp">@</span><span class="n">r</span> <span class="n">α</span> <span class="n">r₂</span> <span class="n">a</span> <span class="n">x</span> <span class="bp">→</span> <span class="bp">@</span><span class="n">r</span> <span class="n">α</span> <span class="n">r₃</span> <span class="n">a</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">a</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h</span> <span class="o">(</span><span class="n">h13</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">h23</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">H</span> <span class="o">:=</span> <span class="n">relation</span><span class="bp">.</span><span class="n">eqv_gen_mono</span> <span class="n">hor</span> <span class="n">a_1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">@</span><span class="n">relation</span><span class="bp">.</span><span class="n">eqv_gen_iff_of_equivalence</span> <span class="bp">_</span> <span class="n">r₃</span><span class="bp">.</span><span class="n">r</span> <span class="n">a</span> <span class="n">x</span> <span class="n">r₃</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="n">H</span>
<span class="kn">end</span>
</pre></div>

<a name="135365891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135365891" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135365891">Bryan Gin-ge Chen (Oct 07 2018 at 21:11)</a>:</h4>
<p>I think <code>relation.eqv_gen_mono</code> is this property you are describing. And it does appear to me to be proved in the way you guys are suggesting. Thanks for the explanation though, without it, I was probably just going to go on not really understanding what was happening under the hood here!</p>

<a name="135366475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366475" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366475">Kevin Buzzard (Oct 07 2018 at 21:31)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> why did this come out so horrible:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">sub_of_gen_sub</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">@</span><span class="n">setoid</span><span class="bp">.</span><span class="n">r</span> <span class="bp">_</span> <span class="n">s</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="o">(</span><span class="n">eqv_gen</span> <span class="n">x</span><span class="o">)</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">@</span><span class="n">setoid</span><span class="bp">.</span><span class="n">r</span> <span class="bp">_</span> <span class="n">s</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">H2</span><span class="o">,</span> <span class="n">eqv_gen</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">H2</span> <span class="n">H</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">setoid</span><span class="bp">.</span><span class="n">iseqv</span> <span class="n">α</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">_</span> <span class="n">H3</span><span class="o">,</span> <span class="o">(</span><span class="bp">@</span><span class="n">setoid</span><span class="bp">.</span><span class="n">iseqv</span> <span class="n">α</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span> <span class="n">H3</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">H4</span> <span class="n">H5</span><span class="o">,(</span><span class="bp">@</span><span class="n">setoid</span><span class="bp">.</span><span class="n">iseqv</span> <span class="n">α</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span> <span class="n">H4</span> <span class="n">H5</span><span class="o">)</span>
</pre></div>

<a name="135366478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366478" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366478">Kevin Buzzard (Oct 07 2018 at 21:31)</a>:</h4>
<p>Oh it's because I should be using a typeclass</p>

<a name="135366479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366479">Kenny Lau (Oct 07 2018 at 21:31)</a>:</h4>
<p>what do you mean by terrible?</p>

<a name="135366480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366480">Kenny Lau (Oct 07 2018 at 21:31)</a>:</h4>
<p>oh</p>

<a name="135366518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366518" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366518">Kevin Buzzard (Oct 07 2018 at 21:32)</a>:</h4>
<p>I didn't use typeclasses because I could see I'd have two equiv relns on alpha</p>

<a name="135366530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366530">Kenny Lau (Oct 07 2018 at 21:32)</a>:</h4>
<p>well it's a lemma</p>

<a name="135366531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366531">Kenny Lau (Oct 07 2018 at 21:32)</a>:</h4>
<p>the typeclass is local</p>

<a name="135366578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366578" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366578">Kenny Lau (Oct 07 2018 at 21:34)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">sub_of_gen_sub</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">setoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">≈</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="o">(</span><span class="n">eqv_gen</span> <span class="n">x</span><span class="o">)</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">≈</span> <span class="n">b</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">H2</span><span class="o">,</span> <span class="n">eqv_gen</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">H2</span> <span class="n">H</span>
  <span class="n">setoid</span><span class="bp">.</span><span class="n">refl</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">setoid</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">setoid</span><span class="bp">.</span><span class="n">trans</span><span class="o">)</span>
</pre></div>

<a name="135366588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366588" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366588">Kevin Buzzard (Oct 07 2018 at 21:34)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> it's not mono, this is a slightly longer way around isn't it? Mono says if x sub y then the equiv reln gen by x is a subset of the equiv reln generated by y. To get the universal property from that you also need that the equiv reln generated by an equiv reln is itself, which is another lemma</p>

<a name="135366590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366590" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366590">Kenny Lau (Oct 07 2018 at 21:34)</a>:</h4>
<p>inb4 <em>galois insertion</em></p>

<a name="135366594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366594" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366594">Kevin Buzzard (Oct 07 2018 at 21:35)</a>:</h4>
<p>rofl</p>

<a name="135366599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366599" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366599">Kevin Buzzard (Oct 07 2018 at 21:35)</a>:</h4>
<p>I can quite believe it.</p>

<a name="135366600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366600" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366600">Bryan Gin-ge Chen (Oct 07 2018 at 21:35)</a>:</h4>
<p>Right, you can see I had to use <code>relation.eqv_gen_iff_of_equivalence</code>.</p>

<a name="135366601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366601" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366601">Kevin Buzzard (Oct 07 2018 at 21:35)</a>:</h4>
<p>although it might be a coinsertion</p>

<a name="135366602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366602" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366602">Kevin Buzzard (Oct 07 2018 at 21:36)</a>:</h4>
<p>With <code>sub_of_gen_sub</code> (which is a relatively straightforward consequence of the recursor) the proof is simpler.</p>

<a name="135366644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366644" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366644">Kevin Buzzard (Oct 07 2018 at 21:36)</a>:</h4>
<p>The lemma reduces you to checking that if X and Y are subsets of Z then so is X union Y, which will be in the library</p>

<a name="135366692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366692" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366692">Kenny Lau (Oct 07 2018 at 21:38)</a>:</h4>
<p>I don't really understand</p>

<a name="135366694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366694" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366694">Kevin Buzzard (Oct 07 2018 at 21:38)</a>:</h4>
<p>It wouldn't surprise me if <code>sub_of_gen_sub</code> is already in the library, perhaps under a better name.</p>

<a name="135366695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366695" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366695">Kenny Lau (Oct 07 2018 at 21:38)</a>:</h4>
<p>this is just the preimage of the canonical embedding from the set of equivalence relations on A to P(A x A)</p>

<a name="135366698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366698">Kevin Buzzard (Oct 07 2018 at 21:38)</a>:</h4>
<p>yes</p>

<a name="135366704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366704" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366704">Kevin Buzzard (Oct 07 2018 at 21:39)</a>:</h4>
<p>Bryan is using subset notation in exactly this way</p>

<a name="135366705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366705" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366705">Kenny Lau (Oct 07 2018 at 21:39)</a>:</h4>
<p>but he's not proving things this way</p>

<a name="135366706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366706">Bryan Gin-ge Chen (Oct 07 2018 at 21:39)</a>:</h4>
<p>I did a search for <code>eqv_gen</code> in mathlib and it only showed up in <code>logic.relation</code> and Kenny's free group file.</p>

<a name="135366750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366750">Kevin Buzzard (Oct 07 2018 at 21:40)</a>:</h4>
<p>Kenny I'm sure both Bryan and I would be interested if you were to blow his code out of the water using a more high-powered way of thinking about this question.</p>

<a name="135366765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366765">Kenny Lau (Oct 07 2018 at 21:41)</a>:</h4>
<p>blow his code out of the water?</p>

<a name="135366766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366766" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366766">Kevin Buzzard (Oct 07 2018 at 21:41)</a>:</h4>
<p>Bryan, do you know what a Galois insertion is?</p>

<a name="135366782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366782">Bryan Gin-ge Chen (Oct 07 2018 at 21:42)</a>:</h4>
<p>I'm about to have dinner, so I'll push what I have. Feel free to make arbitrary changes if you're willing to deal with the compile times.</p>
<p>I was just about to ask whether I ought to know about Galois (co)insertions...</p>

<a name="135366814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366814" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366814">Kevin Buzzard (Oct 07 2018 at 21:42)</a>:</h4>
<p>So the idea is that the construction sending a random relation to an equivalence relation is an adjoint to the forgetful functor sending an equivalence relation to the underlying relation</p>

<a name="135366817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366817">Kenny Lau (Oct 07 2018 at 21:42)</a>:</h4>
<blockquote>
<p>Kenny I'm sure both Bryan and I would be interested if you were to blow his code out of the water using a more high-powered way of thinking about this question.</p>
</blockquote>
<p>I still don't know what the question is</p>

<a name="135366820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366820" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366820">Kevin Buzzard (Oct 07 2018 at 21:42)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/1030f5324363a9213cf4b68f834fad0d124b8a13/order/partitions.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/1030f5324363a9213cf4b68f834fad0d124b8a13/order/partitions.lean">https://github.com/leanprover-community/mathlib/blob/1030f5324363a9213cf4b68f834fad0d124b8a13/order/partitions.lean</a></p>

<a name="135366822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366822" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366822">Kevin Buzzard (Oct 07 2018 at 21:43)</a>:</h4>
<p>Prove all the lemmas there but in a much better way</p>

<a name="135366825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366825" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366825">Kevin Buzzard (Oct 07 2018 at 21:43)</a>:</h4>
<p>That's the question</p>

<a name="135366826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366826" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366826">Kevin Buzzard (Oct 07 2018 at 21:43)</a>:</h4>
<p>I think</p>

<a name="135366884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366884">Kevin Buzzard (Oct 07 2018 at 21:44)</a>:</h4>
<p>But the point is that you have something else here too -- these aren't just a pair of adjoint functors, because these are on posets (ordered by inclusion) and not just categories.</p>

<a name="135366890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366890" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366890">Kenny Lau (Oct 07 2018 at 21:44)</a>:</h4>
<p>well give me an hour to compile the mathlib first...</p>

<a name="135366891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366891" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366891">Kenny Lau (Oct 07 2018 at 21:44)</a>:</h4>
<p>I've changed some of the files</p>

<a name="135366893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366893">Kevin Buzzard (Oct 07 2018 at 21:44)</a>:</h4>
<p>So there's a special name for this situation, called a Galois insertion.</p>

<a name="135366901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366901" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366901">Kenny Lau (Oct 07 2018 at 21:45)</a>:</h4>
<p>so every time I change some files I need to spend one hour compiling the files</p>

<a name="135366903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366903">Kevin Buzzard (Oct 07 2018 at 21:45)</a>:</h4>
<p>And there's a bunch of lemmas proved about Galois insertions which might make these sorts of arguments easier.</p>

<a name="135366910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366910" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366910">Kenny Lau (Oct 07 2018 at 21:45)</a>:</h4>
<p>and in this hour my CPU will be fully used</p>

<a name="135366914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366914" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366914">Kenny Lau (Oct 07 2018 at 21:45)</a>:</h4>
<p>and the computer will be mostly unusable</p>

<a name="135366917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366917">Kevin Buzzard (Oct 07 2018 at 21:45)</a>:</h4>
<p>Kenny if you are only working on one branch which isn't master</p>

<a name="135366920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366920" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366920">Kevin Buzzard (Oct 07 2018 at 21:45)</a>:</h4>
<p>then you should just commit the olean files to master :P</p>

<a name="135366924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366924" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366924">Kevin Buzzard (Oct 07 2018 at 21:45)</a>:</h4>
<p>then whenever you checkout master again, the olean files will reappear</p>

<a name="135366967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366967" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366967">Patrick Massot (Oct 07 2018 at 21:46)</a>:</h4>
<p>Kenny and Kevin, you should pay attention to what Simon is writing in the nextdoor thread</p>

<a name="135366974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366974" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366974">Kevin Buzzard (Oct 07 2018 at 21:47)</a>:</h4>
<p>Kenny should -- I can compile mathlib in 10 minutes and I never fiddle with it anyway ;-)</p>

<a name="135366981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135366981" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135366981">Kevin Buzzard (Oct 07 2018 at 21:47)</a>:</h4>
<p>well...hardly ever</p>

<a name="135367165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135367165" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135367165">Kenny Lau (Oct 07 2018 at 21:53)</a>:</h4>
<p>do all of you have like 30 cores?</p>

<a name="135368008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135368008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135368008">Bryan Gin-ge Chen (Oct 07 2018 at 22:23)</a>:</h4>
<blockquote>
<p>And there's a bunch of lemmas proved about Galois insertions which might make these sorts of arguments easier.</p>
</blockquote>
<p>Are these lemmas in mathlib? There doesn't seem to be anything named <code>galois*</code>.</p>

<a name="135368009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135368009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135368009">Kenny Lau (Oct 07 2018 at 22:23)</a>:</h4>
<p><code>galois.*</code>?</p>

<a name="135368011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135368011" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135368011">Bryan Gin-ge Chen (Oct 07 2018 at 22:23)</a>:</h4>
<p>Oh oops, I was trying to search  the community fork.</p>

<a name="135368163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135368163" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135368163">Bryan Gin-ge Chen (Oct 07 2018 at 22:28)</a>:</h4>
<p>I remember reading about Galois connections whenever I learned about covering spaces. I don't remember insertions and coinsertions but the lean file seems clear enough.</p>

<a name="135369030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369030">Bryan Gin-ge Chen (Oct 07 2018 at 22:57)</a>:</h4>
<p>OK, I see the point now! The smart way to do all of this is to just use <code>lift_complete_lattice</code> on the complete lattice instance on subsets. Presumably that's what Kenny is up to now that an hour has passed. :)</p>

<a name="135369082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369082" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369082">Kenny Lau (Oct 07 2018 at 22:59)</a>:</h4>
<p>oh well I proved this</p>

<a name="135369083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369083" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369083">Kenny Lau (Oct 07 2018 at 22:59)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">order</span><span class="bp">.</span><span class="n">complete_lattice</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span>

<span class="kn">open</span> <span class="n">lattice</span>

<span class="kn">instance</span> <span class="n">bounded_lattice</span><span class="bp">.</span><span class="n">of_fintype_inhabited_lattice</span>
  <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">lattice</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">bounded_lattice</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">top</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">fold</span> <span class="o">(</span><span class="err">⊔</span><span class="o">)</span> <span class="o">(</span><span class="n">default</span> <span class="n">α</span><span class="o">)</span> <span class="n">id</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="o">,</span>
  <span class="n">le_top</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">finset</span><span class="bp">.</span><span class="n">fold</span> <span class="o">(</span><span class="err">⊔</span><span class="o">)</span> <span class="o">(</span><span class="n">default</span> <span class="n">α</span><span class="o">)</span> <span class="n">id</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="o">,</span>
      <span class="k">from</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">this</span> <span class="n">x</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_univ</span> <span class="n">x</span><span class="o">),</span>
    <span class="n">generalize</span> <span class="o">:</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="bp">=</span> <span class="n">U</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">U</span> <span class="k">with</span> <span class="n">U</span> <span class="n">hu1</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">U</span> <span class="kn">using</span> <span class="n">quot</span><span class="bp">.</span><span class="n">ind</span> <span class="k">with</span> <span class="n">L</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">L</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">ih</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">false</span><span class="bp">.</span><span class="n">elim</span> <span class="o">},</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">hx</span> <span class="k">with</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">hx</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">le_sup_left</span> <span class="o">},</span>
    <span class="n">transitivity</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">ih</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">nodup_of_nodup_cons</span> <span class="n">hu1</span><span class="o">)</span> <span class="n">x</span> <span class="n">hx</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">le_sup_right</span> <span class="o">}</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">bot</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">fold</span> <span class="o">(</span><span class="err">⊓</span><span class="o">)</span> <span class="o">(</span><span class="n">default</span> <span class="n">α</span><span class="o">)</span> <span class="n">id</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="o">,</span>
  <span class="n">bot_le</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">fold</span> <span class="o">(</span><span class="err">⊓</span><span class="o">)</span> <span class="o">(</span><span class="n">default</span> <span class="n">α</span><span class="o">)</span> <span class="n">id</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">,</span>
      <span class="k">from</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">this</span> <span class="n">x</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_univ</span> <span class="n">x</span><span class="o">),</span>
    <span class="n">generalize</span> <span class="o">:</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="bp">=</span> <span class="n">U</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">U</span> <span class="k">with</span> <span class="n">U</span> <span class="n">hu1</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">U</span> <span class="kn">using</span> <span class="n">quot</span><span class="bp">.</span><span class="n">ind</span> <span class="k">with</span> <span class="n">L</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">L</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">ih</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">false</span><span class="bp">.</span><span class="n">elim</span> <span class="o">},</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">hx</span> <span class="k">with</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">hx</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">inf_le_left</span> <span class="o">},</span>
    <span class="n">transitivity</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">inf_le_right</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">ih</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">nodup_of_nodup_cons</span> <span class="n">hu1</span><span class="o">)</span> <span class="n">x</span> <span class="n">hx</span> <span class="o">}</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="bp">..</span> <span class="o">(</span><span class="n">infer_instance</span> <span class="o">:</span> <span class="n">lattice</span> <span class="n">α</span><span class="o">)</span> <span class="o">}</span>
</pre></div>

<a name="135369135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369135" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369135">Kenny Lau (Oct 07 2018 at 23:00)</a>:</h4>
<p>and realized that proving it is a complete lattice is impossible</p>

<a name="135369151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369151" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369151">Bryan Gin-ge Chen (Oct 07 2018 at 23:01)</a>:</h4>
<p>Oh are you working on <code>tutorial/partitions.lean</code> or <code>order/partitions.lean</code>?</p>

<a name="135369193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369193">Kenny Lau (Oct 07 2018 at 23:02)</a>:</h4>
<p>what is the difference?</p>

<a name="135369199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369199">Bryan Gin-ge Chen (Oct 07 2018 at 23:03)</a>:</h4>
<p><code>tutorial/partitions.lean</code> was my first try on finite sets. Mario told me I should do stuff with general sets and then specialize, so I made <code>order/partitions.lean</code>.</p>

<a name="135369238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369238" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369238">Bryan Gin-ge Chen (Oct 07 2018 at 23:04)</a>:</h4>
<p>Is the issue with finite partitions that <code>Sup</code> and <code>Inf</code> need to use <code>set</code>?</p>

<a name="135369296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369296">Kenny Lau (Oct 07 2018 at 23:07)</a>:</h4>
<p>I think we should have an instance of <code>\Pi [fintype \a], bounded_lattice (finset \a)</code></p>

<a name="135369504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369504">Kenny Lau (Oct 07 2018 at 23:14)</a>:</h4>
<blockquote>
<p>Is the issue with finite partitions that <code>Sup</code> and <code>Inf</code> need to use <code>set</code>?</p>
</blockquote>
<p>yes</p>

<a name="135369556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369556">Bryan Gin-ge Chen (Oct 07 2018 at 23:16)</a>:</h4>
<p>That's unfortunate. There should be a version of <code>complete_lattice</code> that works for finsets. Is that what your instance above does?</p>

<a name="135369571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369571">Kenny Lau (Oct 07 2018 at 23:17)</a>:</h4>
<p>no, that's <code>bounded_lattice</code></p>

<a name="135369573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369573" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369573">Kenny Lau (Oct 07 2018 at 23:17)</a>:</h4>
<p>I don't think you can prove <code>complete_lattice</code>.</p>

<a name="135369687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369687" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369687">Bryan Gin-ge Chen (Oct 07 2018 at 23:21)</a>:</h4>
<p>Partitions of finite sets have a complete lattice structure just as much as partitions of arbitrary sets do, so we should add <code>complete_lattice_finset</code>.</p>

<a name="135369731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369731">Kenny Lau (Oct 07 2018 at 23:22)</a>:</h4>
<p>I don't think so.</p>

<a name="135369738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369738">Jeremy Avigad (Oct 07 2018 at 23:23)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I am sorry to be slow to respond to your ping, but I have thought about it and I don't have any great insights here. I don't think the notion of a canonical isomorphism is a sharp concept, and your post gives as good a working definition as any. It would be nice to have automation the finds/constructs them for you.</p>

<a name="135369842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369842" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369842">Bryan Gin-ge Chen (Oct 07 2018 at 23:26)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> Why not?</p>

<a name="135369846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369846" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369846">Kenny Lau (Oct 07 2018 at 23:26)</a>:</h4>
<p>because given an arbitrary set of partitions I don't see how you can find its supremum.</p>

<a name="135369850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369850" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369850">Kenny Lau (Oct 07 2018 at 23:27)</a>:</h4>
<p>let's just say our set is A = {0,1}</p>

<a name="135369856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369856" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369856">Kenny Lau (Oct 07 2018 at 23:27)</a>:</h4>
<p>I give you a set S of partitions of A</p>

<a name="135369857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369857" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369857">Kenny Lau (Oct 07 2018 at 23:27)</a>:</h4>
<p>how do you find the supremum of S?</p>

<a name="135369902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369902">Kenny Lau (Oct 07 2018 at 23:28)</a>:</h4>
<p>let's say S is {{{0},{1}}} if Goldbach conjecture is true and and {} otherwise.</p>

<a name="135369979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369979" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369979">Bryan Gin-ge Chen (Oct 07 2018 at 23:30)</a>:</h4>
<p>OK, but for finite partitions I only care about finsets of partitions which can't be that gross, right?</p>

<a name="135369992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135369992" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135369992">Kenny Lau (Oct 07 2018 at 23:31)</a>:</h4>
<p>but if you want to have a <code>complete_lattice</code> instance then you need to find the supremum for arbitrary sets</p>

<a name="135370045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135370045" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135370045">Bryan Gin-ge Chen (Oct 07 2018 at 23:32)</a>:</h4>
<p>So you're saying that there's not even <code>complete_lattice</code> on <code>setoid</code>, as I was aiming to prove in <code>order/partitions.lean</code>...</p>

<a name="135370047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135370047" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135370047">Kenny Lau (Oct 07 2018 at 23:32)</a>:</h4>
<p>you can always make a <code>noncomputable def</code> :)</p>

<a name="135370048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135370048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135370048">Kenny Lau (Oct 07 2018 at 23:32)</a>:</h4>
<p>(don't make it an instance!)</p>

<a name="135370296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135370296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135370296">Bryan Gin-ge Chen (Oct 07 2018 at 23:40)</a>:</h4>
<p>I think I'm starting to get it. Do you happen to know which part of the galois insertion between the partial order on equivalence relations and that on subsets of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>×</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha \times \alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.0037em;">α</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.0037em;">α</span></span></span></span> is noncomputable?</p>

<a name="135370318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135370318" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135370318">Bryan Gin-ge Chen (Oct 07 2018 at 23:41)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> What do you think about having a <code>complete_lattice_finset</code>?</p>

<a name="135370319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135370319" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135370319">Kenny Lau (Oct 07 2018 at 23:41)</a>:</h4>
<p>none of the parts</p>

<a name="135371718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135371718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135371718">Mario Carneiro (Oct 08 2018 at 00:22)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> <code>Sup</code> and <code>Inf</code> are inherently noncomputable, just from their types: <code>set A -&gt; A</code></p>

<a name="135371721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135371721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135371721">Mario Carneiro (Oct 08 2018 at 00:22)</a>:</h4>
<p>This means that they take in no data and produce data</p>

<a name="135371723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135371723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135371723">Kenny Lau (Oct 08 2018 at 00:23)</a>:</h4>
<p>well <code>set (set A) -&gt; set A</code> is computable though</p>

<a name="135371731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135371731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135371731">Mario Carneiro (Oct 08 2018 at 00:23)</a>:</h4>
<p>pointlessly so</p>

<a name="135371734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135371734" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135371734">Mario Carneiro (Oct 08 2018 at 00:23)</a>:</h4>
<p>you can computabilize any definition of that type</p>

<a name="135371738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135371738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135371738">Kenny Lau (Oct 08 2018 at 00:23)</a>:</h4>
<p>aha</p>

<a name="135371739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135371739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135371739">Kenny Lau (Oct 08 2018 at 00:23)</a>:</h4>
<p>thanks</p>

<a name="135448580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135448580" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135448580">Johan Commelin (Oct 09 2018 at 06:53)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Do you know if Neil got Lean working in the end?</p>

<a name="135448584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135448584" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135448584">Johan Commelin (Oct 09 2018 at 06:53)</a>:</h4>
<p><span class="user-mention" data-user-id="130308">@Neil Strickland</span> Aah, you're on this Zulip. Can you confirm?</p>

<a name="135448697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135448697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135448697">Johan Commelin (Oct 09 2018 at 06:56)</a>:</h4>
<p>I'm looking at the first "challenge", namely: prove <code>2 + 2 = 4</code>. Your goal with this challenge is</p>
<blockquote>
<p>Key points: basic boilerplate at the top of the file, basic grammar of stating and proving, how to interact with the proof assistant.</p>
</blockquote>
<p>But in Lean you won't learn that from <code>2 + 2 = 4</code>. In idiomatic Lean, a file dedicated to that lemma would contain 1 line:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">two_add_two</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">4</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>


<p>No imports, no boiler plate, no interactions, no nothing.</p>

<a name="135448700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135448700" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135448700">Scott Morrison (Oct 09 2018 at 06:56)</a>:</h4>
<p>I'm not really sure what state we left him in. At Dagstuhl he definitely had a working copy on the laptop he had with him, but that might not still be the case.</p>

<a name="135448712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135448712" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135448712">Johan Commelin (Oct 09 2018 at 06:57)</a>:</h4>
<p>I think the "Key points" deserve to be in a dedicated tutorial file. But I'm not sure if <code>2 + 2 = 4</code> is the right "goal" of that file.</p>

<a name="135448758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135448758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135448758">Scott Morrison (Oct 09 2018 at 06:58)</a>:</h4>
<p>Well -- even that file teaches you a few things: the lemma keyword, colon, colon-equals. You could also explain the red and green underlines, and the fact that the absence of these shows Lean approves. (Or ... is just not even running...)</p>

<a name="135450223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135450223" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135450223">Tobias Grosser (Oct 09 2018 at 07:38)</a>:</h4>
<p>(deleted)</p>

<a name="135450243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135450243" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135450243">Tobias Grosser (Oct 09 2018 at 07:39)</a>:</h4>
<blockquote>
<p>do all of you have like 30 cores?</p>
</blockquote>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> , any reason you don't compile on a proper server?</p>

<a name="135450297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135450297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135450297">Tobias Grosser (Oct 09 2018 at 07:40)</a>:</h4>
<p>If you don't have one available, I suggest you get an account at the GCC compile farm: "<a href="https://cfarm.tetaneutral.net" target="_blank" title="https://cfarm.tetaneutral.net">https://cfarm.tetaneutral.net</a>"</p>

<a name="135450314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135450314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135450314">Tobias Grosser (Oct 09 2018 at 07:41)</a>:</h4>
<p>They give accounts to open source contributors and have some servers that are commonly not too busy</p>

<a name="135450320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135450320" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135450320">Tobias Grosser (Oct 09 2018 at 07:41)</a>:</h4>
<p>gcc20   22, 443 Dual Xeon   x86_64  Intel(R) Xeon(R) CPU X5670 @ 2.93GHz    2 CPU<br>
12 cores 24 threads 24105 MB    825.0 GB    Debian 7.11 wheezy<br>
3.2.0-4-amd64   1090 days   INRIA Rocquencourt  France</p>

<a name="135450325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135450325" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135450325">Tobias Grosser (Oct 09 2018 at 07:41)</a>:</h4>
<p>Is mostly idle today.</p>

<a name="135450381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135450381" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135450381">Tobias Grosser (Oct 09 2018 at 07:42)</a>:</h4>
<p>If you can get lean compiled on powerpc hardware you can run on IBM Power8 with 160 CPUs</p>

<a name="135450385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135450385" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135450385">Tobias Grosser (Oct 09 2018 at 07:43)</a>:</h4>
<p>It's also at 99% idle ATM.</p>

<a name="135450516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135450516" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135450516">Mario Carneiro (Oct 09 2018 at 07:46)</a>:</h4>
<p>I've never heard of this option</p>

<a name="135450564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135450564" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135450564">Mario Carneiro (Oct 09 2018 at 07:46)</a>:</h4>
<p>Maybe there is a possibility we can set up Jenkins on it as an alternative to Travis?</p>

<a name="135450973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135450973" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135450973">Johan Commelin (Oct 09 2018 at 07:57)</a>:</h4>
<p>Here is what I just pushed for Challenge 1.<br>
<a href="https://github.com/leanprover-community/mathlib/blob/tutorials/tutorials/two_add_two.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/tutorials/tutorials/two_add_two.lean">https://github.com/leanprover-community/mathlib/blob/tutorials/tutorials/two_add_two.lean</a></p>

<a name="135451044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135451044" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135451044">Johan Commelin (Oct 09 2018 at 07:58)</a>:</h4>
<p>I didn't do any tactics yet. So that should be done in Challenge 2 "Infinitude of primes".</p>

<a name="135451447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135451447" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135451447">Johan Commelin (Oct 09 2018 at 08:07)</a>:</h4>
<p><span class="user-mention" data-user-id="130308">@Neil Strickland</span> Would you mind adding a link to <a href="https://github.com/leanprover-community/mathlib/tree/tutorials/tutorials" target="_blank" title="https://github.com/leanprover-community/mathlib/tree/tutorials/tutorials">https://github.com/leanprover-community/mathlib/tree/tutorials/tutorials</a> in you post on MO? Or is it ok with you if we edit the post while writing tutorials on the 5 challenges that you suggested?</p>

<a name="135451645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135451645" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135451645">Johan Commelin (Oct 09 2018 at 08:11)</a>:</h4>
<p>General question <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> should we leave active <code>#eval</code> and <code>#print</code> statements in these tutorials? Or should they be commented out, so that they don't spam ordinary mathlib-builds. I suppose it is easy enough for the user to uncomment them.</p>

<a name="135451694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135451694" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135451694">Mario Carneiro (Oct 09 2018 at 08:12)</a>:</h4>
<p>I'm not sure mathlib is the best place for them</p>

<a name="135451700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135451700" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135451700">Johan Commelin (Oct 09 2018 at 08:12)</a>:</h4>
<p>them what?</p>

<a name="135451706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135451706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135451706">Mario Carneiro (Oct 09 2018 at 08:13)</a>:</h4>
<p>the tutorials</p>

<a name="135451713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135451713" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135451713">Johan Commelin (Oct 09 2018 at 08:13)</a>:</h4>
<p>I think it is</p>

<a name="135451716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135451716" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135451716">Mario Carneiro (Oct 09 2018 at 08:13)</a>:</h4>
<p>Especially if it is an interactive walkthrough</p>

<a name="135451717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135451717" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135451717">Johan Commelin (Oct 09 2018 at 08:13)</a>:</h4>
<p>Because it forces us to make sure they compile</p>

<a name="135451773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135451773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135451773">Mario Carneiro (Oct 09 2018 at 08:14)</a>:</h4>
<p>I don't know, I mean TPIL has code snippets and they only break occasionally, and it is reported and fixed</p>

<a name="135451785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135451785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135451785">Mario Carneiro (Oct 09 2018 at 08:15)</a>:</h4>
<p>It's not like they are going to be based on really complicated things</p>

<a name="135451801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135451801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135451801">Johan Commelin (Oct 09 2018 at 08:15)</a>:</h4>
<blockquote>
<p>It's not like they are going to be based on really complicated things</p>
</blockquote>
<p>One of the challenges is on nilpotent ideals... it would break helplessly by your module refactor.</p>

<a name="135451848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135451848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135451848">Mario Carneiro (Oct 09 2018 at 08:16)</a>:</h4>
<p>They could just as easily be in a separate project. Even better, if a user downloads the tutorial project depending on mathlib then they are already in the right place to do work of their own</p>

<a name="135451861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135451861" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135451861">Kenny Lau (Oct 09 2018 at 08:16)</a>:</h4>
<blockquote>
<p>One of the challenges is on nilpotent ideals... it would break helplessly by your module refactor.</p>
</blockquote>
<p>what do you mean?</p>

<a name="135451871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135451871" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135451871">Mario Carneiro (Oct 09 2018 at 08:16)</a>:</h4>
<p>I'm not saying they never change, but they won't change often</p>

<a name="135451884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135451884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135451884">Johan Commelin (Oct 09 2018 at 08:17)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> <a href="https://mathoverflow.net/a/311159/21815" target="_blank" title="https://mathoverflow.net/a/311159/21815">https://mathoverflow.net/a/311159/21815</a></p>

<a name="135451939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135451939" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135451939">Kenny Lau (Oct 09 2018 at 08:18)</a>:</h4>
<p>yes?</p>

<a name="135451954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135451954" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135451954">Johan Commelin (Oct 09 2018 at 08:18)</a>:</h4>
<p>That's homework for us (-;</p>

<a name="135454675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135454675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135454675">Scott Morrison (Oct 09 2018 at 09:19)</a>:</h4>
<p>I'd be pretty happy to see tutorials embedded in mathlib for now. Anything to avoid useful stuff bit-rotting away. :-)</p>

<a name="135455291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135455291" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135455291">Sean Leather (Oct 09 2018 at 09:31)</a>:</h4>
<p>I agree that tutorials should go into in mathlib. I think that, as long as the plan is to keep mathlib monolithic (which seems to be working out for the most part), it should include tutorials. A reasonable alternative is to build a tutorial repository during mathlib's CI test phase.</p>

<a name="135455714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135455714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135455714">Mario Carneiro (Oct 09 2018 at 09:39)</a>:</h4>
<p>I still think it is a good idea to have a "scratch" repo that newbies can get to have a working setup in vscode with mathlib already hooked in, since this is the recommended use</p>

<a name="135455740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135455740" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135455740">Johan Commelin (Oct 09 2018 at 09:39)</a>:</h4>
<p>What do you mean with "recommended use"?</p>

<a name="135455751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135455751" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135455751">Mario Carneiro (Oct 09 2018 at 09:39)</a>:</h4>
<p>I mean this is the way third parties use mathlib</p>

<a name="135455802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135455802" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135455802">Mario Carneiro (Oct 09 2018 at 09:40)</a>:</h4>
<p>you have a project, and this project imports mathlib</p>

<a name="135455809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135455809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135455809">Mario Carneiro (Oct 09 2018 at 09:40)</a>:</h4>
<p>this is the format vscode is expecting</p>

<a name="135455831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135455831" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135455831">Mario Carneiro (Oct 09 2018 at 09:40)</a>:</h4>
<p>You can have mathlib as a global install and work with loose files, but I think this approach is less robust</p>

<a name="135455852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135455852" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135455852">Johan Commelin (Oct 09 2018 at 09:41)</a>:</h4>
<p>Right, but I'm more thinking about mathematicians that want to contribute to mathlib</p>

<a name="135455859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135455859" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135455859">Mario Carneiro (Oct 09 2018 at 09:41)</a>:</h4>
<p>contributing to mathlib is another thing altogether</p>

<a name="135455901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135455901" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135455901">Johan Commelin (Oct 09 2018 at 09:42)</a>:</h4>
<p>So they will end up hacking on the community fork asap</p>

<a name="135455909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135455909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135455909">Mario Carneiro (Oct 09 2018 at 09:42)</a>:</h4>
<p>sure, in that case they are working on mathlib itself so there is already a project</p>

<a name="135455916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135455916" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135455916">Mario Carneiro (Oct 09 2018 at 09:42)</a>:</h4>
<p>I mean for new leaners, like the kids in Kevin's classes</p>

<a name="135455917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135455917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135455917">Johan Commelin (Oct 09 2018 at 09:42)</a>:</h4>
<p>Right, and they get to know that project by looking in <code>tutorials/</code></p>

<a name="135455933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135455933" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135455933">Scott Morrison (Oct 09 2018 at 09:43)</a>:</h4>
<p>A scratch project is a good idea.</p>

<a name="135455938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135455938" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135455938">Johan Commelin (Oct 09 2018 at 09:43)</a>:</h4>
<p>I see. Well, I was more thinking about people like Neil.</p>

<a name="135455947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135455947" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135455947">Mario Carneiro (Oct 09 2018 at 09:43)</a>:</h4>
<p>I don't think Neil was ready to be a contributor</p>

<a name="135455951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135455951" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135455951">Scott Morrison (Oct 09 2018 at 09:43)</a>:</h4>
<p>Just the bare minimum setup, with perhaps a file that reminds them where to go for more help.</p>

<a name="135455966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135455966" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135455966">Mario Carneiro (Oct 09 2018 at 09:43)</a>:</h4>
<p>I assume people start out with projects on their own for a while, and then move to contribution if they are so inclined</p>

<a name="135455967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135455967" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135455967">Johan Commelin (Oct 09 2018 at 09:43)</a>:</h4>
<p><a href="https://github.com/leanprover-community/hello-world" target="_blank" title="https://github.com/leanprover-community/hello-world">https://github.com/leanprover-community/hello-world</a></p>

<a name="135456022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135456022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135456022">Scott Morrison (Oct 09 2018 at 09:44)</a>:</h4>
<p>And as Lean/mathlib improves, we actually hope a larger and larger fraction of the community are _not_ hacking on mathlib!</p>

<a name="135456026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135456026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135456026">Johan Commelin (Oct 09 2018 at 09:44)</a>:</h4>
<p>Why?</p>

<a name="135456031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135456031" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135456031">Johan Commelin (Oct 09 2018 at 09:44)</a>:</h4>
<p>I thought we wanted to be a massive monolith</p>

<a name="135456033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135456033" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135456033">Scott Morrison (Oct 09 2018 at 09:45)</a>:</h4>
<p>(because they're actually doing maths, rather than filling in all the gaps before they can actually get started)</p>

<a name="135456040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135456040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135456040">Sean Leather (Oct 09 2018 at 09:45)</a>:</h4>
<p>There's ambiguity in the word “tutorial.” I was thinking of something more like a walkthrough of various features of mathlib. But a scratch/hello-world repository would also be useful.</p>

<a name="135456045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135456045" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135456045">Johan Commelin (Oct 09 2018 at 09:45)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> But why not do maths inside mathlib?</p>

<a name="135456047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135456047" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135456047">Scott Morrison (Oct 09 2018 at 09:45)</a>:</h4>
<p>If I'm going to formalise a bunch of the boring-but-technical lemmas in my research paper, they don't belong in mathlib.</p>

<a name="135456049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135456049" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135456049">Mario Carneiro (Oct 09 2018 at 09:45)</a>:</h4>
<p><span class="user-mention" data-user-id="110045">@Sean Leather</span>  I guess Kevin's mathlib docs pages already do that?</p>

<a name="135456127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135456127" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135456127">Scott Morrison (Oct 09 2018 at 09:47)</a>:</h4>
<p>or because they're working out the lemmas for their research project. They don't belong in mathlib because they've got no idea if they're the right lemmas yet. But this is all dreaming. For the next couple of decades, I agree, all in mathlib. :-)</p>

<a name="135456195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135456195" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135456195">Sean Leather (Oct 09 2018 at 09:49)</a>:</h4>
<blockquote>
<p>I guess Kevin's mathlib docs pages already do that?</p>
</blockquote>
<p>Not in the sense that you can see examples in Lean of what is provable and how with mathlib.</p>

<a name="135456299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135456299" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135456299">Sean Leather (Oct 09 2018 at 09:51)</a>:</h4>
<p>Perhaps I'm off-topic here with my own definition of tutorial — I'm not sure — but I was thinking of something that demonstrated usage of mathlib with proofs and words, not <em>just</em> words.</p>

<a name="135457779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135457779" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135457779">Johan Commelin (Oct 09 2018 at 10:23)</a>:</h4>
<p><span class="user-mention" data-user-id="110045">@Sean Leather</span> I think we can have both</p>

<a name="135457873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135457873" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135457873">Sean Leather (Oct 09 2018 at 10:24)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> Yep, we probably should.</p>

<a name="135482607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tutorial/near/135482607" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/22229tutorial.html#135482607">Kevin Buzzard (Oct 09 2018 at 16:48)</a>:</h4>
<p>The Xena.zip file which I was going to use with my 1st years this year (until ICT delivered something much better) -- that was precisely what Mario was describing above. The way this seems to work is that once a year I am allowed to update what the Imperial College undergraduates see by default when they open up VS Code. This year they see a project with one file <code>test.lean</code> containing <code>import data.int.basic theorem 2+2=4:=rfl</code> and then all the lean and olean files for mathlib and lean (with mathlib as a dependency). This is what I would now call "the bare minimum for mathematicians who are interested". But it sounds like the community might be able to make a much better variant of this, which we could just generally advertise on GH. I think it's worth stressing that win10 users have no git and no command line, and I've met plenty of people who just want to get going. We make a better repo, and we replace Xena.zip with this repo and I document it on the installation page and people will be happier.</p>


{% endraw %}
