---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/32447listappendassocdefeq.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html">list.append_assoc defeq?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="167736807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167736807" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167736807">Scott Morrison (Jun 10 2019 at 06:30)</a>:</h4>
<p>This may be a strange question, but can anyone think of a way of modelling lists so the <code>append</code> operation becomes definitionally associative?</p>

<a name="167736812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167736812" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167736812">Scott Morrison (Jun 10 2019 at 06:30)</a>:</h4>
<p>(i.e. in the sense that with normal <code>list</code>, <code>list.nil_append</code> is by <code>rfl</code>, but <code>list.append_nil</code> and <code>list.append_assoc</code> are proper theorems)</p>

<a name="167736888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167736888" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167736888">Scott Morrison (Jun 10 2019 at 06:32)</a>:</h4>
<p>(For context, I just "proved" that every monoidal category was monoidally equivalent to a strictly associative one, by building an equivalence to a category whose objects were words in the objects of the original category. To a certain sort of mathematician, this is morally the right proof. However, in Lean it doesn't end up saying quite what you expected: the unitors and associator are not actually identities! Instead they are things like <code>eq_to_hom (list.append_assoc _ _ _)</code>.)</p>

<a name="167737463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167737463" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167737463">Kevin Buzzard (Jun 10 2019 at 06:48)</a>:</h4>
<p>What happens with maps <code>fin n -&gt; alpha</code>?</p>

<a name="167737796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167737796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167737796">Keeley Hoek (Jun 10 2019 at 06:57)</a>:</h4>
<p>I get that for lists it's not definitional, but how is (e.g.) a unitor not an identity at the end of the day when <code>X</code> and <code>X \otimes 1</code> are equal on the nose?</p>

<a name="167738634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167738634" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167738634">Kevin Buzzard (Jun 10 2019 at 07:17)</a>:</h4>
<p>I don't think <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">M</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>R</mi></mrow><annotation encoding="application/x-tex">M \otimes_R R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span> are equal on the nose, despite every mathematician telling you they are</p>

<a name="167739457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167739457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167739457">Keeley Hoek (Jun 10 2019 at 07:34)</a>:</h4>
<p>Sure, but I think Scott is making the "strictification" of a monoidal category using lists, where the point is that in the new category nice things like <code>X</code> and <code>X \otimes 1</code> being equal actually hold because concatenation of lists is strictly associative.</p>

<a name="167741568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167741568" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167741568">Reid Barton (Jun 10 2019 at 08:10)</a>:</h4>
<blockquote>
<p>This may be a strange question, but can anyone think of a way of modelling lists so the <code>append</code> operation becomes definitionally associative?</p>
</blockquote>
<p>Yes, it is true if you use difference lists, although it is not quite true with the <code>dlist</code> implementation in core for reasons I forget off-hand</p>

<a name="167741758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167741758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167741758">Reid Barton (Jun 10 2019 at 08:14)</a>:</h4>
<p><a href="#narrow/stream/116395-maths/topic/strictification/near/127139698" title="#narrow/stream/116395-maths/topic/strictification/near/127139698">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/strictification/near/127139698</a></p>

<a name="167742866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167742866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167742866">Kevin Buzzard (Jun 10 2019 at 08:38)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm">-</span>
<span class="cm">A difference list is a function that, given a list, returns the original</span>
<span class="cm">contents of the difference list prepended to the given list.</span>

<span class="cm">This structure supports `O(1)` `append` and `concat` operations on lists, making it</span>
<span class="cm">useful for append-heavy uses such as logging and pretty printing.</span>
<span class="cm">-/</span>
<span class="kn">structure</span> <span class="n">dlist</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">apply</span>     <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">invariant</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span> <span class="n">apply</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">apply</span> <span class="o">[]</span> <span class="bp">++</span> <span class="n">l</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">dlist</span>
<span class="kn">open</span> <span class="n">function</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="n">local</span> <span class="kn">notation</span> <span class="bp">`</span><span class="err">♯</span><span class="bp">`</span><span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">abstract</span> <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">simp</span> <span class="o">}</span>

<span class="c">/-</span><span class="cm">- Convert a list to a dlist -/</span>
<span class="n">def</span> <span class="n">of_list</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">append</span> <span class="n">l</span><span class="o">,</span> <span class="err">♯</span><span class="bp">⟩</span>
</pre></div>


<p>I've never seen this before today. It looks to me like some sort of tedious implementation issue ;-)</p>

<a name="167742909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167742909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167742909">Kevin Buzzard (Jun 10 2019 at 08:39)</a>:</h4>
<p>wooah is that local notation being used to denote a tactic? What is this <code>abstract</code>?</p>

<a name="167742968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167742968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167742968">Kevin Buzzard (Jun 10 2019 at 08:40)</a>:</h4>
<p>So a <code>dlist</code> is a way of changing lists (to be thought of as appending the given list). This does feel like that whole monoid thing that Reid linked to.</p>

<a name="167743285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167743285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167743285">Kevin Buzzard (Jun 10 2019 at 08:46)</a>:</h4>
<p>Are two functions defeq if they defeqly agree everywhere?</p>

<a name="167743623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167743623" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167743623">Reid Barton (Jun 10 2019 at 08:55)</a>:</h4>
<p><code>f</code> is equal to <code>λ x, f x</code> definitionally, so I guess that means yes</p>

<a name="167745920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167745920" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167745920">Kevin Buzzard (Jun 10 2019 at 09:43)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">xena</span>

<span class="kn">structure</span> <span class="n">dlist</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">apply</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="c1">-- λ l, l ++ d</span>
<span class="o">(</span><span class="n">thm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span> <span class="n">apply</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">l</span> <span class="bp">++</span> <span class="n">apply</span> <span class="o">[])</span>

<span class="kn">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="n">def</span> <span class="n">dlist</span><span class="bp">.</span><span class="n">to_list</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">d</span><span class="bp">.</span><span class="n">apply</span> <span class="o">[]</span>

<span class="kn">theorem</span> <span class="n">apply_def</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">d</span><span class="bp">.</span><span class="n">apply</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">l</span> <span class="bp">++</span> <span class="n">d</span><span class="bp">.</span><span class="n">to_list</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">d</span><span class="bp">.</span><span class="n">thm</span><span class="o">,</span>
  <span class="n">refl</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">dlist</span><span class="bp">.</span><span class="n">nil</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">apply</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span>
  <span class="n">thm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append_nil</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">}</span>

<span class="n">def</span> <span class="n">dlist</span><span class="bp">.</span><span class="n">append</span> <span class="o">(</span><span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">apply</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">e</span><span class="bp">.</span><span class="n">apply</span> <span class="o">(</span><span class="n">d</span><span class="bp">.</span><span class="n">apply</span> <span class="n">l</span><span class="o">),</span>
  <span class="n">thm</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intro</span> <span class="n">l</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">apply_def</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">apply_def</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">apply_def</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">apply_def</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="kn">end</span><span class="o">}</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span><span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">dlist</span><span class="bp">.</span><span class="n">append</span><span class="bp">⟩</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">d</span><span class="o">)</span> <span class="bp">+</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">d</span> <span class="bp">+</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>


<span class="kn">end</span> <span class="n">xena</span>
</pre></div>

<a name="167745975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167745975" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167745975">Kevin Buzzard (Jun 10 2019 at 09:44)</a>:</h4>
<p>I did it the other way to core (they go for <code>d ++ l</code>) and I'm not sure if it matters.</p>

<a name="167746032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167746032" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167746032">Johan Commelin (Jun 10 2019 at 09:45)</a>:</h4>
<p>Can we also have a <code>dnat</code> and <code>dint</code> etc? Where addition is associative by defeq...</p>

<a name="167746102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167746102" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167746102">Kevin Buzzard (Jun 10 2019 at 09:46)</a>:</h4>
<p>You define dnat to be the function which adds d to a nat.</p>

<a name="167746112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167746112" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167746112">Reid Barton (Jun 10 2019 at 09:46)</a>:</h4>
<p>The original use for difference lists is to turn some arbitrary tree of appends into right-associated <code>a ++ (b ++ (c ++ ...))</code> which can be computed back to a list in linear time. If you append on the other side then you're always getting the worst case of <code>++</code> rather than always getting the best case.</p>

<a name="167746151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167746151" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167746151">Reid Barton (Jun 10 2019 at 09:47)</a>:</h4>
<p>But it doesn't matter if your goal is to achieve this strictification</p>

<a name="167746331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167746331" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167746331">Johan Commelin (Jun 10 2019 at 09:50)</a>:</h4>
<p>I would love to have a <code>dint</code> where <code>i</code> is defeq to <code>(i - 1) + 1</code>.</p>

<a name="167746726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167746726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167746726">Kenny Lau (Jun 10 2019 at 09:58)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">dint</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">apply</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="bp">ℤ</span><span class="o">)</span>
<span class="o">(</span><span class="n">commutes</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">apply</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">i</span> <span class="bp">+</span> <span class="n">apply</span> <span class="mi">0</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">dint</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">s</span> <span class="n">t</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">s</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">t</span><span class="bp">.</span><span class="mi">1</span> <span class="n">i</span><span class="o">),</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">s</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="n">t</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="n">s</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">t</span><span class="bp">.</span><span class="n">apply</span> <span class="mi">0</span><span class="o">),</span> <span class="n">add_assoc</span><span class="o">]</span><span class="bp">⟩⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">is_associative</span> <span class="n">dint</span> <span class="o">(</span><span class="bp">+</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span>
</pre></div>

<a name="167746884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167746884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167746884">Kevin Buzzard (Jun 10 2019 at 10:01)</a>:</h4>
<p>I think that if I'd gone the core way then both zero_add and add_zero would be rfl</p>

<a name="167754335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167754335" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167754335">Kevin Buzzard (Jun 10 2019 at 12:24)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">dlist</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">apply</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="c1">-- λ l, d ++ l</span>
<span class="o">(</span><span class="n">thm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span> <span class="n">apply</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">apply</span> <span class="o">[]</span> <span class="bp">++</span> <span class="n">l</span><span class="o">)</span>

<span class="kn">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="n">def</span> <span class="n">dlist</span><span class="bp">.</span><span class="n">to_list</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">d</span><span class="bp">.</span><span class="n">apply</span> <span class="o">[]</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">apply_def</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">d</span><span class="bp">.</span><span class="n">apply</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">d</span><span class="bp">.</span><span class="n">to_list</span> <span class="bp">++</span> <span class="n">l</span><span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span><span class="n">rw</span> <span class="n">d</span><span class="bp">.</span><span class="n">thm</span><span class="o">,</span> <span class="n">refl</span><span class="o">}</span>

<span class="n">def</span> <span class="n">dlist</span><span class="bp">.</span><span class="n">nil</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">apply</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span>
  <span class="n">thm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">nil_append</span> <span class="n">l</span><span class="o">)}</span>

<span class="n">def</span> <span class="n">dlist</span><span class="bp">.</span><span class="n">append</span> <span class="o">(</span><span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">apply</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">e</span><span class="bp">.</span><span class="n">apply</span> <span class="o">(</span><span class="n">d</span><span class="bp">.</span><span class="n">apply</span> <span class="n">l</span><span class="o">),</span>
  <span class="n">thm</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simp</span><span class="o">}</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span><span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">dlist</span><span class="bp">.</span><span class="n">append</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="o">(</span><span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">dlist</span><span class="bp">.</span><span class="n">nil</span> <span class="n">α</span><span class="bp">⟩</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">d</span><span class="o">)</span> <span class="bp">+</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">d</span> <span class="bp">+</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">d</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">cases</span> <span class="n">d</span><span class="o">,</span> <span class="n">refl</span><span class="o">}</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">d</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">cases</span> <span class="n">d</span><span class="o">,</span> <span class="n">refl</span><span class="o">}</span>
</pre></div>


<p>That's really annoying. How come I have to cases on d for add_zero and zero_add?</p>

<a name="167754523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167754523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167754523">Reid Barton (Jun 10 2019 at 12:26)</a>:</h4>
<p>Because one side is a variable and the other side is an application of <code>dlist.mk</code></p>

<a name="167754677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167754677" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167754677">Kevin Buzzard (Jun 10 2019 at 12:29)</a>:</h4>
<p>And this is different to the add_assoc example?</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="n">dint</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="o">{</span> <span class="n">apply</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">commutes</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">add_zero</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">}</span><span class="bp">⟩</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">dint</span><span class="o">)</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">d</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">cases</span> <span class="n">d</span><span class="bp">;</span> <span class="n">refl</span> <span class="c1">-- rfl fails</span>
</pre></div>


<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span></p>

<a name="167754718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167754718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167754718">Reid Barton (Jun 10 2019 at 12:30)</a>:</h4>
<p>If we had definitional eta for structures then these would become defeq. (Same with unitality of bundled morphisms, functors, etc.)</p>

<a name="167754738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167754738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167754738">Reid Barton (Jun 10 2019 at 12:30)</a>:</h4>
<p>In associativity both sides are <code>dlist.mk</code> applications</p>

<a name="167755005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167755005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167755005">Kevin Buzzard (Jun 10 2019 at 12:34)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">dint</span><span class="o">)</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">d</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>


<p>Penny has dropped</p>

<a name="167768638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167768638" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167768638">Mario Carneiro (Jun 10 2019 at 15:26)</a>:</h4>
<p>I really hope people don't put this stuff in mathlib</p>

<a name="167768648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167768648" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167768648">Keeley Hoek (Jun 10 2019 at 15:26)</a>:</h4>
<p>Ssssssssssssssssssslllllllllllllllllllllllooooooooooooooooooowwwwwwwwwwwwwwwww</p>

<a name="167768862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167768862" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167768862">Kevin Buzzard (Jun 10 2019 at 15:29)</a>:</h4>
<p>But so beautiful!</p>

<a name="167769347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167769347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167769347">Mario Carneiro (Jun 10 2019 at 15:35)</a>:</h4>
<p>I think it will just make you more mad about the things that are defeq now vs the things that aren't</p>

<a name="167769393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167769393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167769393">Kevin Buzzard (Jun 10 2019 at 15:35)</a>:</h4>
<p>In the limit it seems that all proofs will become rfl. This seems appealing.</p>

<a name="167769400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167769400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167769400">Mario Carneiro (Jun 10 2019 at 15:35)</a>:</h4>
<p>right, that's a false sense</p>

<a name="167769409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167769409" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167769409">Kevin Buzzard (Jun 10 2019 at 15:35)</a>:</h4>
<p>And if it's slow, just get a faster computer.</p>

<a name="167769474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167769474" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167769474">Mario Carneiro (Jun 10 2019 at 15:36)</a>:</h4>
<p>that isn't going to happen with any coding scheme in DTT</p>

<a name="167769487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167769487" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167769487">Kevin Buzzard (Jun 10 2019 at 15:36)</a>:</h4>
<p>:-(</p>

<a name="167769504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167769504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167769504">Mario Carneiro (Jun 10 2019 at 15:36)</a>:</h4>
<p>and chasing it will make you constructions crazy and not obviously motivated</p>

<a name="167769542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167769542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167769542">Kevin Buzzard (Jun 10 2019 at 15:37)</a>:</h4>
<p>Yes, the other part of me wants to say to Scott "who cares what is defeq and what isn't? This is a weird computer science notion"</p>

<a name="167769556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167769556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167769556">Mario Carneiro (Jun 10 2019 at 15:37)</a>:</h4>
<p>With extensional type theory you can actually achieve that, at the expense of undecidable type checking</p>

<a name="167769577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167769577" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167769577">Mario Carneiro (Jun 10 2019 at 15:37)</a>:</h4>
<p>it's basically saying "let's call mathematician's equality defeq and call it a day"</p>

<a name="167769697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167769697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167769697">Kevin Buzzard (Jun 10 2019 at 15:39)</a>:</h4>
<p>I was having a conversation with a Coq user over lunch last week (Nicola Gambino, from Leeds) and he said that because Coq doesn't have quotients, you can end up in what is commonly referred to as "setoid hell".</p>

<a name="167769711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167769711" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167769711">Mario Carneiro (Jun 10 2019 at 15:39)</a>:</h4>
<p>yes</p>

<a name="167769774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167769774" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167769774">Mario Carneiro (Jun 10 2019 at 15:40)</a>:</h4>
<p>that has to do with the inability to use lean <code>=</code> to represent other equivalence relations</p>

<a name="167769790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167769790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167769790">Kevin Buzzard (Jun 10 2019 at 15:40)</a>:</h4>
<p>And I said "but you can just make quotients, using sets of equivalence classes, except they have some problems" and he said "yeah, one problem is equality". And I was a bit confused and talked to him about what equality was, and he started talking about "extensional v intensional equality" and at that point I lost him.</p>

<a name="167769831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167769831" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167769831">Mario Carneiro (Jun 10 2019 at 15:41)</a>:</h4>
<p>lol, equality is a PhD topic around here</p>

<a name="167769938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167769938" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167769938">Mario Carneiro (Jun 10 2019 at 15:42)</a>:</h4>
<p>I'm not exactly sure how far you can get in Coq, but I think the problem is that even showing that two sets are <code>=</code> iff they have the same elements requires some function extensionality and/or quotient types</p>

<a name="167770001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167770001" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167770001">Mario Carneiro (Jun 10 2019 at 15:43)</a>:</h4>
<p>so the equivalence class construction replaces one problem with an equivalent problem</p>

<a name="167770714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167770714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167770714">Mario Carneiro (Jun 10 2019 at 15:51)</a>:</h4>
<p>Coq has a much more bifurcated notion of equality than lean, because the axioms don't allow making the other equalities the same as <code>=</code> as in lean. A setoid in Coq is the same as <code>setoid</code> in lean - a type with an equivalence relation, but in Coq they stop there and don't build the quotient. So they have to add notation for the <code>≈</code> and call it "equals", and then prove that various functions and predicates are "extensional", i.e. they respect the equality-pretender. In lean this is "free" since we can use <code>eq.rec</code> to rewrite any predicate using <code>=</code>. It's very similar to the issue we face when rewriting across isomorphisms, that is solved by univalence. The "free" is in quotes because of course we still have to prove our functions and predicates are extensional; this is the final argument of <code>quot.lift</code> that appears in all functions on quotients. But it does give us some functions for free, like <code>eq</code>, that are extensional without having to be proven so.</p>


{% endraw %}
