---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/82176fintype.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html">fintype</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="123059884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/123059884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#123059884">Chris Hughes (Feb 27 2018 at 21:23)</a>:</h4>
<p>What's the reason fintype isn't marked as Prop?</p>

<a name="123060084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/123060084" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#123060084">Simon Hudon (Feb 27 2018 at 21:28)</a>:</h4>
<p>I think it can't be <code>Prop</code> because its accessor <code>elems</code> has a non-<code>Prop</code> type</p>

<a name="123060323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/123060323" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#123060323">Chris Hughes (Feb 27 2018 at 21:35)</a>:</h4>
<p>Exists is a Prop, so presumably it's possible to define it in a way such that it is a Prop. I thought that since it's a subsingleton, it may as well be a Prop, but there's probably a good reason why not.</p>

<a name="123060387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/123060387" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#123060387">Simon Hudon (Feb 27 2018 at 21:37)</a>:</h4>
<p>That's true. The difference is that <code>Exists</code> is defined using <code>inductive</code> not <code>structure</code>. Inductive doesn't come with accessors (in the case of <code>Exists</code>, the accessors could also be called the axiom of choice).</p>

<a name="123060434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/123060434" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#123060434">Simon Hudon (Feb 27 2018 at 21:38)</a>:</h4>
<p>I think allowing <code>fintype</code> to be <code>Prop</code> would render every constructivist paranoid</p>

<a name="123060441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/123060441" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#123060441">Simon Hudon (Feb 27 2018 at 21:38)</a>:</h4>
<p>(because merely declaring a structure could quietly add the axiom of choice into your development)</p>

<a name="123060454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/123060454" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#123060454">Kevin Buzzard (Feb 27 2018 at 21:39)</a>:</h4>
<blockquote>
<p>I think allowing <code>fintype</code> to be <code>Prop</code> would render every constructivist paranoid</p>
</blockquote>
<p>I think they're already pretty paranoid if they're constructivists...</p>

<a name="123060505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/123060505" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#123060505">Simon Hudon (Feb 27 2018 at 21:40)</a>:</h4>
<p>Should I say "paranoider"?</p>

<a name="123060543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/123060543" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#123060543">Chris Hughes (Feb 27 2018 at 21:41)</a>:</h4>
<p>Mario mentioned that he wanted his proofs of <code>[fintype \a] \r [fintype \b] \r [fintype (\a \r \b)]</code> to be computable. Not sure why, especially since choice is everywhere in mathlib</p>

<a name="123060674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/123060674" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#123060674">Simon Hudon (Feb 27 2018 at 21:44)</a>:</h4>
<p>Even when you assume the axiom of choice, constructive functions are great. They allow you to build programs without efforts</p>

<a name="123061184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/123061184" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#123061184">Kevin Buzzard (Feb 27 2018 at 21:55)</a>:</h4>
<p>Try calculations with integers</p>

<a name="123061227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/123061227" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#123061227">Kevin Buzzard (Feb 27 2018 at 21:56)</a>:</h4>
<p>What do you mean by "forever"?</p>

<a name="123061255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/123061255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#123061255">Simon Hudon (Feb 27 2018 at 21:56)</a>:</h4>
<p>wrong topic</p>

<a name="123061261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/123061261" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#123061261">Kevin Buzzard (Feb 27 2018 at 21:56)</a>:</h4>
<p>damn topics</p>

<a name="123067712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/123067712" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#123067712">Mario Carneiro (Feb 28 2018 at 00:55)</a>:</h4>
<p><code>fintype</code> and <code>finite</code> exist exactly so that you can decide whether or not you want to work in Prop</p>

<a name="123067953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/123067953" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#123067953">Chris Hughes (Feb 28 2018 at 01:01)</a>:</h4>
<p>Didn't know about finite. I'll have to look at it.</p>

<a name="175342573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/175342573" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#175342573">Reid Barton (Sep 10 2019 at 14:36)</a>:</h4>
<p>Prompted by Scott's PR <a href="https://github.com/leanprover-community/mathlib/issues/1427" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/1427">#1427</a>, I just realized that <code>fintype</code> is not the same as the usual constructive notion of <a href="https://ncatlab.org/nlab/show/finite+set#Constructivist" target="_blank" title="https://ncatlab.org/nlab/show/finite+set#Constructivist">finite</a>. I'm not really sure how to think about this though. What is an example of a <code>fintype</code> which is not finite?</p>

<a name="175342616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/175342616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#175342616">Reid Barton (Sep 10 2019 at 14:36)</a>:</h4>
<p>(Here, finite means there is a bijection to <code>fin n</code> for some <code>n</code> and so in particular it implies that the type has decidable equality)</p>

<a name="175342712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/175342712" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#175342712">Reid Barton (Sep 10 2019 at 14:37)</a>:</h4>
<p>Maybe another question is: is <code>fintype</code> "correct"?</p>

<a name="175350392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/175350392" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#175350392">Floris van Doorn (Sep 10 2019 at 15:49)</a>:</h4>
<p>Good point. Maybe we can prove that every <code>fintype</code> has decidable equality. <br>
You can definitely prove <code>nonempty (decidable_eq \a)</code>, and maybe you can do some trickery to get decidable equality, since that is a subsingleton?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span>

<span class="n">def</span> <span class="n">dec</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfreezeI</span><span class="o">,</span> <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="bp">⟨⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">hs</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">h2s</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">revert</span> <span class="n">hs</span> <span class="n">h2s</span><span class="o">,</span> <span class="n">refine</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">rec_on_subsingleton</span> <span class="n">s</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">l</span> <span class="n">hl</span> <span class="n">h2l</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hx</span> <span class="o">:=</span> <span class="n">h2l</span> <span class="n">x</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hy</span> <span class="o">:=</span> <span class="n">h2l</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">list</span><span class="bp">.</span><span class="n">mem_iff_nth_le</span><span class="o">]</span> <span class="n">at</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">hx</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">hn</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">hy</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">hm</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">refine</span> <span class="n">mt</span> <span class="bp">_</span> <span class="n">h</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">list</span><span class="bp">.</span><span class="n">nodup_iff_nth_le_inj</span><span class="o">]</span> <span class="n">at</span> <span class="n">hl</span><span class="o">,</span> <span class="n">apply</span> <span class="n">hl</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="175351695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/175351695" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#175351695">Floris van Doorn (Sep 10 2019 at 16:04)</a>:</h4>
<p>So to answer your question, Our notion of <code>fintype</code> is (at least) very close to the correct one.<br>
I have a very bad intuition of the failure to eliminate from propositions to subsingletons: in HoTT that is provable.<br>
If we replace <code>(complete : ∀ x : α, x ∈ elems)</code> by something which is type-valued and says the same thing, then we can definitely prove decidable equality.</p>

<a name="175351746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/175351746" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#175351746">Reid Barton (Sep 10 2019 at 16:05)</a>:</h4>
<p>I'm pretty sure you can't obtain <code>decidable_eq</code> constructively, because <code>fintype</code> just gives you a bunch of elements of the type and some useless props.</p>

<a name="175351765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/175351765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#175351765">Reid Barton (Sep 10 2019 at 16:05)</a>:</h4>
<p>It doesn't give you any way to consume an element of the type</p>

<a name="175354058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/175354058" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#175354058">Chris Hughes (Sep 10 2019 at 16:32)</a>:</h4>
<p>Simon has a PR doing <code>enumerable</code> as a bijection with <code>fin n</code>. I'd rather <code>fintype</code> remained a subsingleton.</p>

<a name="175354460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/175354460" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#175354460">Chris Hughes (Sep 10 2019 at 16:37)</a>:</h4>
<p>Or a <code>Prop</code></p>

<a name="175358741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/175358741" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#175358741">Reid Barton (Sep 10 2019 at 17:23)</a>:</h4>
<p>I agree it should be a subsingleton. For example one "fix" (if it is a fix) would be to just add a field with a <code>decidable_eq</code> instance.</p>

<a name="175358769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/175358769" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#175358769">Reid Barton (Sep 10 2019 at 17:23)</a>:</h4>
<p>As far as I can tell, this is ehat ssreflect does</p>

<a name="175360309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/175360309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#175360309">Floris van Doorn (Sep 10 2019 at 17:38)</a>:</h4>
<p>When I say something type-valued, it will remain a subsingleton. But probably the easiest is to just add a <code>decidable_eq</code> instance, which I think would be very helpful.</p>

<a name="175402056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/175402056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#175402056">Mario Carneiro (Sep 11 2019 at 05:15)</a>:</h4>
<p>I gave an example to Simon recently about this. Consider the quotient <code>Q</code> of nat (treated as enumerating programs) that identifies programs that both halt or both do not halt. Classically, this is a two element set, and we can computably construct a <code>fintype Q</code> with two elements (the proof that this enumeration is complete requires LEM, but it is still lean-computable). But deciding equality on this type is equivalent to the halting problem.</p>

<a name="175402172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/175402172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#175402172">Mario Carneiro (Sep 11 2019 at 05:18)</a>:</h4>
<p>I also argued that putting a decidable_eq argument in the definition would mean an instance <code>fintype A -&gt; decidable_eq A</code> and I'm not sure we want to make the <code>decidable</code> typeclass search any larger than it already is</p>

<a name="175402344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/175402344" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#175402344">Mario Carneiro (Sep 11 2019 at 05:23)</a>:</h4>
<p>By the way, it's not actually clear if we follow the letter of that definition of finite. <code>fintype</code> is equivalent to a <code>bijection</code> from <code>fin n</code> for some <code>n</code> (not an <code>equiv</code>)</p>

<a name="175421291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/175421291" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#175421291">Reid Barton (Sep 11 2019 at 11:20)</a>:</h4>
<p>Nice example. It also gives me a better appreciation for Floris's <code>dec</code>. We need LEM to hold for equality on our type, just not computably. (Contrast with examples of subfinite sets which are not finite, which can be constructed from failures of LEM.)</p>

<a name="175421433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/175421433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#175421433">Reid Barton (Sep 11 2019 at 11:22)</a>:</h4>
<p>I'm pretty sure that in this context, "bijection" is supposed to be interpreted as <code>equiv</code>. (I'm not as sure how "there exists" is meant to be interpreted...) At any rate, that nlab page claims further down that finite sets have decidable equality (but maybe one can quibble over the meaning of "have"?)</p>

<a name="175421790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype/near/175421790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82176fintype.html#175421790">Johan Commelin (Sep 11 2019 at 11:28)</a>:</h4>
<p>The joys of constructive math... all of a sudden not only your nouns have multiple interpretations, but also your adjectives, your verbs, and everything...</p>


{% endraw %}

{% include archive_update.html %}