---
layout: archive
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/99238finnfinm.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/99238finnfinm.html">(fin n) ≃ (fin m)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="151189960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%28fin%20n%29%20%E2%89%83%20%28fin%20m%29/near/151189960" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/99238finnfinm.html#151189960">Kevin Buzzard (Dec 08 2018 at 19:04)</a>:</h4>
<p>I was looking at the full Lean proof that if <code>fin n</code> bijects with <code>fin m</code> then <code>n = m</code>. It seems to me to be very long. It follows from the theorem that two fintypes biject with each other if and only if they have the same cardinality, but the cardinality of a fintype is defined to be the cardinality of the underlying list, and one now has to prove that this is well-defined. One might argue that this can be done relatively straightforwardly using <code>list.perm</code>, but the permutation equivalence relation on list is not defined to be "there's a bijection", it's defined to be the statement that we can make one list from another using some sequence of moves which define the inductive <code>perm</code> type, so now this reduces us to the statement that any bijection between lists comes from a perm, and this seems to be a fair amount of effort -- and all this is just to define the cardinality of a fintype. One still has to prove the theorem after this. Are there much shorter proofs available or is this what an actual proof of this statement looks like? In ZFC is there a shorter proof that if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">\{1,2,3,\ldots,n\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">{</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord mathrm">3</span><span class="mpunct">,</span><span class="minner">…</span><span class="mpunct">,</span><span class="mord mathit">n</span><span class="mclose">}</span></span></span></span> bijects with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>m</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">\{1,2,\ldots,m\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">{</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="minner">…</span><span class="mpunct">,</span><span class="mord mathit">m</span><span class="mclose">}</span></span></span></span> then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n=m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span><span class="mrel">=</span><span class="mord mathit">m</span></span></span></span>? Can one for example use the pigeonhole principle, arguing that if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo≯</mo><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n\not=m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">n</span><span class="mrel" style="position:relative;"><span class="mainrm" style="position:absolute;right:0;"≯</span><span class="mrel">=</span></span><span class="mord mathit">m</span></span></span></span> then wlog <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n&gt;m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base"><span class="mord mathit">n</span><span class="mrel">&gt;</span><span class="mord mathit">m</span></span></span></span> and now any map from a set with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span> elements to a set with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">m</span></span></span></span> elements cannot be an injection by the pigeonhole principle?  Is this in Lean? Is this just the same work expressed in another way?</p>

<a name="151215999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%28fin%20n%29%20%E2%89%83%20%28fin%20m%29/near/151215999" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/99238finnfinm.html#151215999">Chris Hughes (Dec 09 2018 at 09:53)</a>:</h4>
<p>My attempt</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span> <span class="n">data</span><span class="bp">.</span><span class="n">fin</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">fin</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="n">inj_eq&#39;</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="bp">⟩</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">fin</span><span class="bp">.</span><span class="n">veq_of_eq</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="k">by</span> <span class="n">subst</span> <span class="n">h</span><span class="bp">⟩</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">fin</span><span class="bp">.</span><span class="n">coe_inj</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="n">function</span><span class="bp">.</span><span class="n">injective</span><span class="bp">.</span><span class="n">eq_iff</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h</span><span class="o">,</span> <span class="n">fin</span><span class="bp">.</span><span class="n">eq_of_veq</span> <span class="n">h</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">fin</span><span class="bp">.</span><span class="n">eta&#39;</span> <span class="o">{</span><span class="n">a</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">((</span><span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">open</span> <span class="n">nat</span>

<span class="kn">lemma</span> <span class="n">pigeonhole</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span> <span class="n">f</span><span class="o">),</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="n">m</span> <span class="n">f</span> <span class="n">hf</span> <span class="o">:=</span> <span class="o">(</span><span class="n">le_of_not_gt</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">not_lt_zero</span> <span class="bp">_</span> <span class="o">(</span><span class="n">f</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">))</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="mi">0</span> <span class="n">f</span> <span class="n">hf</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero_le</span> <span class="bp">_</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="n">hf</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_le_succ</span>
  <span class="o">(</span><span class="n">pigeonhole</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">,</span>
      <span class="k">if</span> <span class="n">hfx</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">lt_succ_self</span> <span class="n">n</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span> <span class="bp">⟨</span><span class="n">x</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">lt_succ_of_lt</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span><span class="o">)</span>
      <span class="k">then</span> <span class="bp">⟨</span><span class="n">f</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">last</span> <span class="n">m</span><span class="o">),</span>
        <span class="n">lt_of_not_ge</span>
          <span class="o">(</span><span class="bp">λ</span> <span class="n">hfm</span><span class="o">,</span>
            <span class="k">have</span> <span class="n">hfm</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">last</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
              <span class="k">from</span> <span class="n">le_antisymm</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_of_lt_succ</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">last</span> <span class="n">m</span><span class="o">))</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="n">hfm</span><span class="o">,</span>
            <span class="k">have</span> <span class="n">hfx</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">lt_succ_of_lt</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
              <span class="k">from</span> <span class="n">le_antisymm</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_of_lt_succ</span> <span class="o">(</span><span class="n">f</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">lt_succ_of_lt</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span>
                <span class="o">(</span><span class="n">trans_rel_left</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span> <span class="o">(</span><span class="n">le_refl</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">veq_of_eq</span> <span class="n">hfx</span><span class="o">)),</span>
            <span class="k">have</span> <span class="o">(</span><span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">lt_succ_of_lt</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="n">fin</span><span class="bp">.</span><span class="n">last</span> <span class="n">m</span><span class="o">,</span>
              <span class="k">from</span> <span class="n">hf</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">eq_of_veq</span> <span class="o">(</span><span class="n">hfx</span><span class="bp">.</span><span class="n">trans</span> <span class="n">hfm</span><span class="bp">.</span><span class="n">symm</span><span class="o">)),</span>
            <span class="k">have</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">=</span> <span class="n">m</span><span class="o">,</span> <span class="k">from</span> <span class="n">fin</span><span class="bp">.</span><span class="n">veq_of_eq</span> <span class="n">this</span><span class="o">,</span>
            <span class="n">absurd</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">this</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">▸</span> <span class="n">lt_irrefl</span> <span class="bp">_</span><span class="o">))</span><span class="bp">⟩</span>
      <span class="k">else</span> <span class="bp">⟨</span><span class="n">f</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">lt_succ_of_lt</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">lt_of_le_of_ne</span> <span class="o">(</span><span class="n">le_of_lt_succ</span> <span class="o">(</span><span class="n">f</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">lt_succ_of_lt</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span>
        <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">vne_of_ne</span> <span class="o">(</span><span class="n">ne</span><span class="bp">.</span><span class="n">symm</span> <span class="n">hfx</span><span class="o">))</span><span class="bp">⟩</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="k">have</span> <span class="bp">_</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">@</span><span class="n">function</span><span class="bp">.</span><span class="n">injective</span><span class="bp">.</span><span class="n">eq_iff</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">hf</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">lt_succ_of_lt</span> <span class="n">hx</span><span class="bp">⟩</span>
        <span class="bp">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">lt_succ_of_lt</span> <span class="n">hy</span><span class="bp">⟩</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
      <span class="k">begin</span>
        <span class="n">clear</span> <span class="bp">_</span><span class="n">fun_match</span> <span class="bp">_</span><span class="n">fun_match</span> <span class="bp">_</span><span class="n">x</span> <span class="bp">_</span><span class="n">x</span><span class="o">,</span>
        <span class="n">simp</span><span class="o">,</span>
        <span class="n">split_ifs</span><span class="o">,</span>
        <span class="o">{</span> <span class="n">simp</span> <span class="bp">*</span> <span class="n">at</span> <span class="bp">*;</span> <span class="n">cc</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
          <span class="n">exact</span> <span class="n">absurd</span> <span class="n">hy</span> <span class="o">(</span><span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="n">fin</span><span class="bp">.</span><span class="n">last</span><span class="o">,</span> <span class="n">hf</span><span class="bp">.</span><span class="n">eq_iff</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">)</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
          <span class="n">exact</span> <span class="n">absurd</span> <span class="n">hx</span> <span class="o">(</span><span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="n">fin</span><span class="bp">.</span><span class="n">last</span><span class="o">,</span> <span class="n">hf</span><span class="bp">.</span><span class="n">eq_iff</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">)</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hf</span><span class="bp">.</span><span class="n">eq_iff</span><span class="o">]</span> <span class="o">}</span>
      <span class="kn">end</span><span class="o">))</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="err">≃</span> <span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span>
<span class="n">le_antisymm</span>
  <span class="o">(</span><span class="n">pigeonhole</span> <span class="n">e</span> <span class="n">e</span><span class="bp">.</span><span class="n">bijective</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">pigeonhole</span> <span class="n">e</span><span class="bp">.</span><span class="n">symm</span> <span class="n">e</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">bijective</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span>
</pre></div>

<a name="151220117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%28fin%20n%29%20%E2%89%83%20%28fin%20m%29/near/151220117" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/99238finnfinm.html#151220117">Kevin Buzzard (Dec 09 2018 at 12:14)</a>:</h4>
<p>Chris I suspect that your life would have been easier if you'd used results involving <code>fintype.card</code>. But I think you have proved my point. I am telling all the students "look, the composite of injective functions is injective" and the proof is something which is just a few lines long in Lean. I am also telling them "the reals have this cool completeness property" but here I am clear that this is actually a lot of work, it is just work that we are not going to do. </p>
<p>But I am also telling them "look, the pigeonhole principle is obvious" and I don't see any way of proving it which doesn't involve some pretty messy induction. My course contains lies. I say to them "look, if X and Y are finite sets and X injects into Y then the size of X is at most the size of Y, this is obvious because consider the image of the map" and yet I do not even tell them what I mean by the size of a set and if I need this sort of result for X and Y of the form <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">\{1,2,3,\ldots,n\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">{</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord mathrm">3</span><span class="mpunct">,</span><span class="minner">…</span><span class="mpunct">,</span><span class="mord mathit">n</span><span class="mclose">}</span></span></span></span> before I can define "size" then these arguments are circular.</p>

<a name="151228257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%28fin%20n%29%20%E2%89%83%20%28fin%20m%29/near/151228257" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/99238finnfinm.html#151228257">Reid Barton (Dec 09 2018 at 16:58)</a>:</h4>
<p>I think at some point you have to use this idea that if f is a bijection from {1,...,n}  to {1,...,m} then by permuting the input (or output) we can assume that f sends n to m and then the restriction of f to {1,...,n-1] is a bijection to {1,...,m-1}.</p>

<a name="151228807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%28fin%20n%29%20%E2%89%83%20%28fin%20m%29/near/151228807" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/99238finnfinm.html#151228807">Chris Hughes (Dec 09 2018 at 17:16)</a>:</h4>
<p>That's the messy part.</p>

<a name="151229379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%28fin%20n%29%20%E2%89%83%20%28fin%20m%29/near/151229379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/99238finnfinm.html#151229379">Mario Carneiro (Dec 09 2018 at 17:35)</a>:</h4>
<p>You could leverage some theorems about <code>equiv.swap</code> here, I think?</p>


{% endraw %}
