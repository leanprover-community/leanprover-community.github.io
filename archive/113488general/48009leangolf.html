---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/48009leangolf.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html">lean golf</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="123089630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/123089630" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#123089630">Sean Leather (Feb 28 2018 at 13:27)</a>:</h4>
<p>Shortest proof of this?</p>
<div class="codehilite"><pre><span></span><span class="n">a</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">∧</span> <span class="n">d</span> <span class="bp">∧</span> <span class="n">e</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">∧</span> <span class="n">d</span> <span class="bp">∧</span> <span class="n">e</span>
</pre></div>

<a name="123089805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/123089805" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#123089805">Sebastian Ullrich (Feb 28 2018 at 13:32)</a>:</h4>
<p>Let's start with the basics</p>
<div class="codehilite"><pre><span></span><span class="k">by</span> <span class="n">split</span><span class="bp">;</span><span class="n">intro</span><span class="bp">;</span><span class="n">simp</span><span class="bp">*</span>
</pre></div>

<a name="123090043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/123090043" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#123090043">Sean Leather (Feb 28 2018 at 13:40)</a>:</h4>
<p>That's like a sledgehammer using sledgehammers to hit small nails. For some reason, I never think to try <code>simp *</code>.</p>

<a name="123090128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/123090128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#123090128">Sebastian Ullrich (Feb 28 2018 at 13:43)</a>:</h4>
<p>Well, I don't really need <code>*</code> here, but naming the hypothesis obviously is a golf no-go :P</p>

<a name="123090420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/123090420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#123090420">Sean Leather (Feb 28 2018 at 13:52)</a>:</h4>
<p>Is it? If the proof is short, I don't see why. <span class="emoji emoji-1f642" title="simple smile">:simple_smile:</span></p>

<a name="123090434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/123090434" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#123090434">Scott Morrison (Feb 28 2018 at 13:53)</a>:</h4>
<p>I was happy to see <code>by tidy</code> works too. Maybe one day I'll get up the courage to PR it.</p>

<a name="123109866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/123109866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#123109866">Kevin Buzzard (Feb 28 2018 at 21:57)</a>:</h4>
<p>I wondered whether <code>by cc</code> would work -- but it doesn't. I still don't really know what to expect with cc but I think I've seen it prove other goals of this nature.</p>

<a name="123129844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/123129844" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#123129844">Sean Leather (Mar 01 2018 at 09:11)</a>:</h4>
<p>I'm slowly learning how to use <code>simp *</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">list</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span>

<span class="kn">theorem</span> <span class="n">nth_of_map</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">option</span><span class="bp">.</span><span class="n">get_or_else</span> <span class="o">(</span><span class="n">nth</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">l</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">option</span><span class="bp">.</span><span class="n">get_or_else</span> <span class="o">(</span><span class="n">nth</span> <span class="n">l</span> <span class="n">n</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">induction</span> <span class="n">l</span> <span class="n">generalizing</span> <span class="n">n</span><span class="bp">;</span> <span class="o">[</span><span class="n">skip</span><span class="o">,</span> <span class="n">cases</span> <span class="n">n</span><span class="o">]</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="n">option</span><span class="bp">.</span><span class="n">get_or_else</span><span class="o">]</span>

<span class="kn">end</span> <span class="n">list</span>
</pre></div>

<a name="123179941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/123179941" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#123179941">Johannes Hölzl (Mar 02 2018 at 11:22)</a>:</h4>
<p>I guess <code>cc</code> doesn't work as it currently doesn't handle idempotent laws (i.e. <code>c ∧ c</code>).</p>

<a name="123658195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/123658195" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#123658195">Kevin Buzzard (Mar 13 2018 at 15:09)</a>:</h4>
<p>Curry:</p>

<a name="123658197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/123658197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#123658197">Kevin Buzzard (Mar 13 2018 at 15:09)</a>:</h4>
<p><code>example (P Q R : Prop) : (P ∧ Q → R) ↔ (P → (Q → R)) := sorry</code></p>

<a name="123658245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/123658245" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#123658245">Kevin Buzzard (Mar 13 2018 at 15:10)</a>:</h4>
<p>Doing this one taught me something, although it was arguably not very useful</p>

<a name="123658252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/123658252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#123658252">Kevin Buzzard (Mar 13 2018 at 15:10)</a>:</h4>
<p>Actually it taught me 2 things, one being that bash shell is not very good at counting unicode characters</p>

<a name="127015438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127015438" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127015438">Sean Leather (May 24 2018 at 06:31)</a>:</h4>
<p>I'm sure I've asked this before, but I don't remember the answer. Better/shorter way to do this?</p>
<div class="codehilite"><pre><span></span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span>
</pre></div>


<p>Note that <code>simp</code> by itself doesn't work.</p>

<a name="127016063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127016063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127016063">Johannes Hölzl (May 24 2018 at 06:55)</a>:</h4>
<p><code>simp {contextual:=tt}</code> should do it.</p>

<a name="127016150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127016150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127016150">Sean Leather (May 24 2018 at 06:58)</a>:</h4>
<p>Yep, that did it. Thanks!</p>

<a name="127017262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127017262" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127017262">Sean Leather (May 24 2018 at 07:38)</a>:</h4>
<p><code>simp</code> doesn't solve this. Is there a theorem I can use with <code>simp</code> to solve it?</p>
<div class="codehilite"><pre><span></span><span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="bp">⟩</span> <span class="err">∈</span> <span class="n">l</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a₁</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">==</span> <span class="n">b₁</span> <span class="bp">∨</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="bp">⟩</span> <span class="err">∈</span> <span class="n">l</span>
</pre></div>

<a name="127017535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127017535" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127017535">Johannes Hölzl (May 24 2018 at 07:49)</a>:</h4>
<p>I guess you have <code>⟨a₁, b₁⟩ ∈ l</code>?</p>

<a name="127017583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127017583" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127017583">Johannes Hölzl (May 24 2018 at 07:50)</a>:</h4>
<p>But I also don't see how to solve it with the simplifier.</p>

<a name="127017645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127017645" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127017645">Sean Leather (May 24 2018 at 07:52)</a>:</h4>
<p>Oh wait, I'm stupid. Let me actually think. <span class="emoji emoji-1f642" title="simple smile">:simple_smile:</span></p>

<a name="127017653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127017653" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127017653">Kevin Buzzard (May 24 2018 at 07:53)</a>:</h4>
<p>Do you CS people know how to parse that sort of statement?</p>

<a name="127017685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127017685" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127017685">Kevin Buzzard (May 24 2018 at 07:54)</a>:</h4>
<p>I look at it (away from Lean) and have no idea about the relative priorities of and, or and iff. Is this just all some standard convention that you CS people know and we maths people just avoid by adding brackets?</p>

<a name="127017716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127017716" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127017716">Kevin Buzzard (May 24 2018 at 07:54)</a>:</h4>
<p>I mean -- I know I can go and check them -- my question is whether there are uniform standards or whether Lean made some random choice and you find different choices in other systems.</p>

<a name="127017741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127017741" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127017741">Kevin Buzzard (May 24 2018 at 07:55)</a>:</h4>
<p>obviously I can guess the answer in this situation from the context, but in the past I have written statements without brackets and then later on gone "oh crap, that doesn't mean what I wanted it to mean at all"</p>

<a name="127017785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127017785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127017785">Gabriel Ebner (May 24 2018 at 07:56)</a>:</h4>
<p>The precedence is pretty standard.  In most (all?) programming languages as well as logic, and binds more tightly than or.  C doesn't have iff, so its hard to compare.</p>

<a name="127017792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127017792" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127017792">Sean Leather (May 24 2018 at 07:57)</a>:</h4>
<p>The “usual conventions:” <a href="https://groups.google.com/d/msg/lean-user/lbFwVL21Az4/1erXpLqBAwAJ" target="_blank" title="https://groups.google.com/d/msg/lean-user/lbFwVL21Az4/1erXpLqBAwAJ">https://groups.google.com/d/msg/lean-user/lbFwVL21Az4/1erXpLqBAwAJ</a></p>

<a name="127017838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127017838" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127017838">Gabriel Ebner (May 24 2018 at 07:58)</a>:</h4>
<p>Excerpt from a proof theory textbook lying around here (Troelstra &amp; Schwichtenberg):</p>
<blockquote>
<p>Notation (Saving on parentheses) In writing formulas we save on parentheses by assuming that ∀, ∃,  ¬ bind more strongly than ∧, ∨, and that in turn ∨, ∧ bind more strongly than →, ↔. [...]</p>
</blockquote>

<a name="127017848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127017848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127017848">Gabriel Ebner (May 24 2018 at 07:58)</a>:</h4>
<p>I guess you will find similar boilerplate in most texts that deal with logical formulas.</p>

<a name="127017854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127017854" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127017854">Sean Leather (May 24 2018 at 07:58)</a>:</h4>
<p>One that I struggled with was <code>=</code> vs. <code>↔</code>, but now I'm used to it.</p>

<a name="127018118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127018118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127018118">Kevin Buzzard (May 24 2018 at 08:07)</a>:</h4>
<blockquote>
<p>I guess you will find similar boilerplate in most texts that deal with logical formulas.</p>
</blockquote>
<p>I follow a text which deals with logical formulas in my introduction to proof class and I can find no mention of binding preferences anywhere!</p>

<a name="127018119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127018119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127018119">Kevin Buzzard (May 24 2018 at 08:07)</a>:</h4>
<p>But I do see a lot of brackets :-)</p>

<a name="127018159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127018159" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127018159">Kevin Buzzard (May 24 2018 at 08:08)</a>:</h4>
<p>I conclude that the guy who wrote it (who is in the office a few doors down from me) was also a mathematician who had no idea of standard CS conventions :-)</p>

<a name="127018330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127018330" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127018330">Gabriel Ebner (May 24 2018 at 08:14)</a>:</h4>
<p>There is one confusing difference between proof theory and CS though: the precedence of ∀, ∃ is different.</p>
<div class="codehilite"><pre><span></span>  ∃x P(x) → Q     means:

  (∃x P(x)) → Q       for everyone in my research group
  ∃x (P(x) → Q)       in Lean, Coq, etc.
</pre></div>

<a name="127018489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127018489" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127018489">Chris Hughes (May 24 2018 at 08:20)</a>:</h4>
<p><code>(∃x P(x)) → Q</code> seems like really stupid precedence, since you would usually write <code>∀ x , P x → Q</code> instead of that.</p>

<a name="127018550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127018550" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127018550">Sean Leather (May 24 2018 at 08:21)</a>:</h4>
<p>Interesting. Pierce (Types and Programming Languages) uses explicit bracketing : <code>{∃x, P(x)}</code></p>

<a name="127018815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127018815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127018815">Gabriel Ebner (May 24 2018 at 08:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> The same precedence is also used for ∀: <code>(∀x P(x)) → Q</code> vs. <code>∀x (P(x) → Q)</code>, which is just as confusing.</p>

<a name="127019269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/127019269" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#127019269">Kevin Buzzard (May 24 2018 at 08:43)</a>:</h4>
<p>In fact it was exactly this forall point which I was referring to in my earlier "that doesn't mean what I wanted it to mean" comment</p>

<a name="132455368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132455368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132455368">Sean Leather (Aug 20 2018 at 13:35)</a>:</h4>
<p>Shortest proof of this?</p>
<div class="codehilite"><pre><span></span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span>
<span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span>
<span class="n">q</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span>
<span class="err">⊢</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span>
</pre></div>

<a name="132455921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132455921" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132455921">Sean Leather (Aug 20 2018 at 13:44)</a>:</h4>
<p>This is what I came up with:</p>
<div class="codehilite"><pre><span></span><span class="n">nat</span><span class="bp">.</span><span class="n">lt_of_le_and_ne</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_of_lt_succ</span> <span class="n">p</span><span class="o">)</span> <span class="n">q</span>
</pre></div>

<a name="132456748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132456748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132456748">Kenny Lau (Aug 20 2018 at 13:59)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">cases</span> <span class="n">p</span><span class="bp">;</span> <span class="o">[</span><span class="n">cc</span><span class="o">,</span> <span class="n">assumption</span><span class="o">]</span>
</pre></div>

<a name="132457185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132457185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132457185">Johan Commelin (Aug 20 2018 at 14:05)</a>:</h4>
<p>I'm not on a Lean machine atm, but could <code>cooper</code> or <code>tidy</code> kill this one?</p>

<a name="132529548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132529548" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132529548">Kenny Lau (Aug 21 2018 at 17:17)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">H1</span> <span class="o">:</span> <span class="n">S</span> <span class="err">⊆</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">H2</span> <span class="o">:</span> <span class="n">T</span><span class="bp">.</span><span class="n">card</span> <span class="bp">≤</span> <span class="n">S</span><span class="bp">.</span><span class="n">card</span><span class="o">)</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">T</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">H3</span> <span class="o">:</span> <span class="n">disjoint</span> <span class="n">S</span> <span class="o">(</span><span class="n">T</span> <span class="err">\</span> <span class="n">S</span><span class="o">),</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">disjoint</span><span class="o">],</span>
<span class="k">have</span> <span class="n">H4</span> <span class="o">:</span> <span class="bp">_</span><span class="o">,</span> <span class="k">from</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card_disjoint_union</span> <span class="n">H3</span><span class="o">,</span>
<span class="k">have</span> <span class="n">H5</span> <span class="o">:</span> <span class="n">S</span> <span class="err">∪</span> <span class="n">T</span> <span class="err">\</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">T</span><span class="o">,</span> <span class="k">from</span> <span class="n">finset</span><span class="bp">.</span><span class="n">ext&#39;</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
  <span class="bp">⟨λ</span> <span class="n">H</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">cases_on</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_union</span><span class="bp">.</span><span class="mi">1</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_of_subset</span> <span class="n">H1</span><span class="o">)</span> <span class="o">(</span><span class="n">and</span><span class="bp">.</span><span class="n">left</span> <span class="err">∘</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_sdiff</span><span class="bp">.</span><span class="mi">1</span><span class="o">),</span>
  <span class="bp">λ</span> <span class="n">H</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">by_cases</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_union_left</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">H&#39;</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_union_right</span> <span class="bp">_</span> <span class="err">$</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_sdiff</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">H</span><span class="o">,</span> <span class="n">H&#39;</span><span class="bp">⟩</span><span class="o">)</span><span class="bp">⟩</span><span class="o">,</span>
<span class="k">have</span> <span class="n">H6</span> <span class="o">:</span> <span class="n">S</span><span class="bp">.</span><span class="n">card</span> <span class="bp">=</span> <span class="n">T</span><span class="bp">.</span><span class="n">card</span><span class="o">,</span> <span class="k">from</span> <span class="n">le_antisymm</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">card_le_of_subset</span> <span class="n">H1</span><span class="o">)</span> <span class="n">H2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">H7</span> <span class="o">:</span> <span class="n">T</span> <span class="err">\</span> <span class="n">S</span> <span class="bp">=</span> <span class="err">∅</span><span class="o">,</span> <span class="k">from</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card_eq_zero</span><span class="bp">.</span><span class="mi">1</span> <span class="err">$</span>
  <span class="n">nat</span><span class="bp">.</span><span class="n">add_left_cancel</span> <span class="err">$</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="err">$</span> <span class="k">by</span> <span class="n">rwa</span> <span class="o">[</span><span class="n">H5</span><span class="o">,</span> <span class="n">H6</span><span class="o">]</span> <span class="n">at</span> <span class="n">H4</span><span class="o">,</span>
<span class="k">have</span> <span class="n">H8</span> <span class="o">:</span> <span class="n">T</span> <span class="err">⊆</span> <span class="n">S</span><span class="o">,</span> <span class="k">from</span> <span class="n">finset</span><span class="bp">.</span><span class="n">subset_iff</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">classical</span><span class="bp">.</span><span class="n">by_contradiction</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">H&#39;</span><span class="o">,</span>
  <span class="n">finset</span><span class="bp">.</span><span class="n">ne_empty_of_mem</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_sdiff</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">H</span><span class="o">,</span> <span class="n">H&#39;</span><span class="bp">⟩</span><span class="o">)</span> <span class="n">H7</span><span class="o">,</span>
<span class="n">finset</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">antisymm</span> <span class="n">H1</span> <span class="n">H8</span>
</pre></div>

<a name="132529552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132529552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132529552">Kenny Lau (Aug 21 2018 at 17:17)</a>:</h4>
<p>is there a shorter proof?</p>

<a name="132531216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132531216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132531216">Mario Carneiro (Aug 21 2018 at 17:46)</a>:</h4>
<div class="codehilite"><pre><span></span>example (H1 : S ⊆ T) (H2 : T.card ≤ S.card) : S = T :=
finset.eq_of_veq $ multiset.eq_of_le_of_card_le (finset.val_le_iff.2 H1) H2
</pre></div>

<a name="132531244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132531244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132531244">Mario Carneiro (Aug 21 2018 at 17:47)</a>:</h4>
<p>this should be in mathlib though</p>

<a name="132531591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132531591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132531591">Kenny Lau (Aug 21 2018 at 17:53)</a>:</h4>
<p>ah it's in multiset lol</p>

<a name="132531934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132531934" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132531934">Chris Hughes (Aug 21 2018 at 17:59)</a>:</h4>
<p>Pretty sure it's there for finsets. I remember seeing it.</p>

<a name="132532050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132532050" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132532050">Chris Hughes (Aug 21 2018 at 18:00)</a>:</h4>
<p><code>finset.eq_of_subset_of_card_le</code></p>

<a name="132532088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132532088" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132532088">Kenny Lau (Aug 21 2018 at 18:01)</a>:</h4>
<p>genius</p>

<a name="132533414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132533414" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132533414">Kenny Lau (Aug 21 2018 at 18:27)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>

<span class="kn">example</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">surjective</span> <span class="n">f</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">eq_univ_iff_forall</span><span class="bp">.</span><span class="mi">1</span> <span class="err">$</span> <span class="n">finset</span><span class="bp">.</span><span class="n">eq_of_subset_of_card_le</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">subset_univ</span> <span class="bp">_</span><span class="o">)</span>
  <span class="o">(</span><span class="n">le_of_eq</span> <span class="err">$</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="err">$</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card_image_of_injective</span> <span class="bp">_</span> <span class="n">H</span><span class="o">),</span>
<span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">H2</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_image</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">H</span> <span class="n">y</span><span class="o">)</span> <span class="k">in</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">H2</span><span class="bp">⟩</span>
</pre></div>

<a name="132533415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132533415" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132533415">Kenny Lau (Aug 21 2018 at 18:27)</a>:</h4>
<p>how about this?</p>

<a name="132533791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132533791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132533791">Chris Hughes (Aug 21 2018 at 18:33)</a>:</h4>
<p>Already in mathlib. <code>fintype.injective_iff_surjective</code> Your proof  is shorter though</p>

<a name="132534113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132534113" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132534113">Kenny Lau (Aug 21 2018 at 18:38)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>

<span class="kn">theorem</span> <span class="n">something</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">surjective</span> <span class="n">f</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">eq_univ_iff_forall</span><span class="bp">.</span><span class="mi">1</span> <span class="err">$</span> <span class="n">finset</span><span class="bp">.</span><span class="n">eq_of_subset_of_card_le</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">subset_univ</span> <span class="bp">_</span><span class="o">)</span>
  <span class="o">(</span><span class="n">le_of_eq</span> <span class="err">$</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="err">$</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card_image_of_injective</span> <span class="bp">_</span> <span class="n">H</span><span class="o">),</span>
<span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">H2</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_image</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">H</span> <span class="n">y</span><span class="o">)</span> <span class="k">in</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">H2</span><span class="bp">⟩</span>

<span class="kn">theorem</span> <span class="n">something2</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">,</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="n">something</span> <span class="n">α</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">r</span> <span class="n">s</span> <span class="o">(</span><span class="n">H&#39;</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">s</span> <span class="bp">*</span> <span class="n">x</span><span class="o">),</span> <span class="n">eq_of_sub_eq_zero</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">resolve_right</span>
    <span class="o">(</span><span class="n">eq_zero_or_eq_zero_of_mul_eq_zero</span> <span class="err">$</span> <span class="k">show</span> <span class="o">(</span><span class="n">r</span> <span class="bp">-</span> <span class="n">s</span><span class="o">)</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">sub_mul</span><span class="o">,</span> <span class="n">H&#39;</span><span class="o">,</span> <span class="n">sub_self</span><span class="o">])</span> <span class="n">H</span><span class="o">)</span> <span class="mi">1</span>

<span class="n">noncomputable</span> <span class="kn">instance</span> <span class="n">field_of_fintype_of_integral_domain</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">field</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">H</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="err">$</span> <span class="n">something2</span> <span class="n">α</span> <span class="n">x</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">mul_inv_cancel</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">H</span><span class="o">,</span> <span class="k">by</span> <span class="n">unfold</span> <span class="n">has_inv</span><span class="bp">.</span><span class="n">inv</span><span class="bp">;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">dif_neg</span> <span class="n">H</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="o">(</span><span class="n">something2</span> <span class="n">α</span> <span class="n">x</span> <span class="n">H</span><span class="o">)],</span>
  <span class="n">inv_mul_cancel</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">H</span><span class="o">,</span> <span class="k">by</span> <span class="n">unfold</span> <span class="n">has_inv</span><span class="bp">.</span><span class="n">inv</span><span class="bp">;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">dif_neg</span> <span class="n">H</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="o">(</span><span class="n">something2</span> <span class="n">α</span> <span class="n">x</span> <span class="n">H</span><span class="o">)],</span>
  <span class="bp">..</span> <span class="o">(</span><span class="k">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">integral_domain</span> <span class="n">α</span><span class="o">)</span> <span class="o">}</span>
</pre></div>

<a name="132534118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132534118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132534118">Kenny Lau (Aug 21 2018 at 18:38)</a>:</h4>
<blockquote>
<p>Already in mathlib. <code>fintype.injective_iff_surjective</code> Your proof  is shorter though</p>
</blockquote>
<p>well I didn't prove the other direction</p>

<a name="132534147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132534147" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132534147">Chris Hughes (Aug 21 2018 at 18:39)</a>:</h4>
<p>Don't make that an instance or we have a cycle.</p>

<a name="132534161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132534161" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132534161">Kenny Lau (Aug 21 2018 at 18:39)</a>:</h4>
<p>also I can't find <code>injective_iff_surjective</code></p>

<a name="132534228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132534228" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132534228">Chris Hughes (Aug 21 2018 at 18:40)</a>:</h4>
<p>It's quite new. Last month or so.</p>

<a name="132601084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132601084" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132601084">Kevin Buzzard (Aug 22 2018 at 20:46)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>Too embarrassed to post my effort. <span class="user-mention" data-user-id="110044">@Chris Hughes</span> this came up with that countp v count thing. The proof isn't refl even though the predicates are whatever they call it -- eta equivalent or something.</p>

<a name="132601170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132601170" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132601170">Patrick Massot (Aug 22 2018 at 20:48)</a>:</h4>
<p><code>by cc</code></p>

<a name="132601195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132601195" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132601195">Mario Carneiro (Aug 22 2018 at 20:49)</a>:</h4>
<p><code>propext eq_comm</code></p>

<a name="132601255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132601255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132601255">Patrick Massot (Aug 22 2018 at 20:50)</a>:</h4>
<p>Mine is shorter! <span class="emoji emoji-1f3c6" title="trophy">:trophy:</span></p>

<a name="132601261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132601261" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132601261">Patrick Massot (Aug 22 2018 at 20:50)</a>:</h4>
<p>I know, yours is probably faster</p>

<a name="132601274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132601274" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132601274">Mario Carneiro (Aug 22 2018 at 20:50)</a>:</h4>
<p>Mine is smaller with <code>pp.all</code> :)</p>

<a name="132603490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132603490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132603490">Kevin Buzzard (Aug 22 2018 at 21:37)</a>:</h4>
<p>Here's the context this came up in:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">multiset</span>

<span class="kn">open</span> <span class="n">multiset</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">count</span> <span class="n">a</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">card</span> <span class="o">(</span><span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">countp_eq_card_filter</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">count</span><span class="o">,</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">funext</span><span class="o">,</span>
  <span class="k">by</span> <span class="n">cc</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>I was surprised this wasn't there, but perhaps the issue is that you can filter on <code>λ b, b = a</code> or <code>λ b, a = b</code></p>

<a name="132603835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132603835" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132603835">Kenny Lau (Aug 22 2018 at 21:47)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">multiset</span>

<span class="kn">open</span> <span class="n">multiset</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">count</span> <span class="n">a</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">card</span> <span class="o">(</span><span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">convert</span> <span class="n">countp_eq_card_filter</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">funext</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">cc</span>
<span class="kn">end</span>
</pre></div>

<a name="132603896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132603896" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132603896">Mario Carneiro (Aug 22 2018 at 21:48)</a>:</h4>
<p><code>by simp [count, countp_eq_card_filter, eq_comm]; congr</code></p>

<a name="132604013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132604013" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132604013">Kenny Lau (Aug 22 2018 at 21:51)</a>:</h4>
<p><code>by convert countp_eq_card_filter s; simp [eq_comm]</code></p>

<a name="132604473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132604473" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132604473">Kevin Buzzard (Aug 22 2018 at 22:03)</a>:</h4>
<p>If I hover over <code>convert</code> in VS Code I get "convert &lt;- expr &lt;error while executing interactive.param_desc: don't know how to pretty print lean.parser.small_nat&gt;  Similar to <code>refine</code> but generates equality proof obligations for every discrepancy between the goal and the type of the rule"</p>

<a name="132604528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/132604528" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#132604528">Mario Carneiro (Aug 22 2018 at 22:04)</a>:</h4>
<p>that's because <code>small_nat</code> doesn't have a description - compare with <code>congr'</code></p>

<a name="133795530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/133795530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#133795530">Sean Leather (Sep 12 2018 at 12:31)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">max</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:=</span> <span class="bp">_</span>
</pre></div>

<a name="133796099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/133796099" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#133796099">Reid Barton (Sep 12 2018 at 12:42)</a>:</h4>
<p>not very creative, but <code>by rw [add_comm, nat.lt_succ_iff]; apply le_max_left</code></p>

<a name="136055689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/136055689" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#136055689">Kenny Lau (Oct 18 2018 at 16:45)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">topology</span><span class="bp">.</span><span class="n">topological_space</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">t1_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_open</span> <span class="n">s</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">letI</span> <span class="o">:=</span> <span class="n">classical</span><span class="bp">.</span><span class="n">dec_pred</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="bp">-</span><span class="n">s</span><span class="o">)</span><span class="bp">;</span> <span class="n">exact</span>
<span class="o">(</span><span class="n">is_closed_compl_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="err">$</span> <span class="n">set</span><span class="bp">.</span><span class="n">bUnion_of_singleton</span> <span class="o">(</span><span class="bp">-</span><span class="n">s</span><span class="o">)</span> <span class="bp">▸</span> <span class="n">is_closed_Union</span>
  <span class="bp">⟨</span><span class="n">set</span><span class="bp">.</span><span class="n">fintype_of_finset</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="bp">-</span><span class="n">s</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_filter</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_univ</span><span class="o">,</span> <span class="n">true_and</span><span class="o">])</span><span class="bp">⟩</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">is_closed_singleton</span><span class="o">))</span>
</pre></div>

<a name="136059466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/136059466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#136059466">Mario Carneiro (Oct 18 2018 at 17:45)</a>:</h4>
<p>I think this theorem could also be stated as <code>t = \top</code></p>

<a name="136060001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/136060001" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#136060001">Mario Carneiro (Oct 18 2018 at 17:53)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">t2_space&#39;</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">t2</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">,</span> <span class="n">is_open</span> <span class="n">u</span> <span class="bp">→</span> <span class="n">is_open</span> <span class="n">v</span> <span class="bp">→</span>
   <span class="n">x</span> <span class="err">∈</span> <span class="n">u</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">v</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">z</span><span class="o">,</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">u</span> <span class="bp">∧</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">v</span><span class="o">)</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">t</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span>
<span class="n">include</span> <span class="n">t</span>

<span class="n">def</span> <span class="n">Hausdorffification</span><span class="bp">.</span><span class="n">setoid</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">r</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">t2_space&#39;</span> <span class="o">(</span><span class="n">quotient</span> <span class="n">s</span><span class="o">)],</span> <span class="bp">@</span><span class="n">setoid</span><span class="bp">.</span><span class="n">r</span> <span class="n">α</span> <span class="n">s</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">iseqv</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="bp">_</span> <span class="n">s</span> <span class="bp">_</span><span class="o">,</span> <span class="n">s</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">H</span> <span class="n">s</span> <span class="n">ht2</span><span class="o">,</span> <span class="n">s</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="bp">@</span><span class="n">H</span> <span class="n">s</span> <span class="n">ht2</span><span class="o">),</span>
    <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">H1</span> <span class="n">H2</span> <span class="n">s</span> <span class="n">ht2</span><span class="o">,</span> <span class="n">s</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="bp">@</span><span class="n">H1</span> <span class="n">s</span> <span class="n">ht2</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">H2</span> <span class="n">s</span> <span class="n">ht2</span><span class="o">)</span><span class="bp">⟩</span> <span class="o">}</span>

<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">Hausdorffification</span><span class="bp">.</span><span class="n">setoid</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">Hausdorffification</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span>
<span class="n">quotient</span> <span class="o">(</span><span class="n">Hausdorffification</span><span class="bp">.</span><span class="n">setoid</span> <span class="n">α</span><span class="o">)</span>

<span class="kn">instance</span> <span class="n">Hausdorffification</span><span class="bp">.</span><span class="n">t2_space&#39;</span> <span class="o">:</span>
  <span class="n">t2_space&#39;</span> <span class="o">(</span><span class="n">Hausdorffification</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">t2</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on₂</span> <span class="n">x</span> <span class="n">y</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">m</span> <span class="n">n</span> <span class="n">H</span><span class="o">,</span>
    <span class="n">quot</span><span class="bp">.</span><span class="n">sound</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">ht2</span><span class="o">,</span> <span class="k">begin</span>
      <span class="n">resetI</span><span class="o">,</span>
      <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="n">Hausdorffification</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">quotient</span> <span class="n">r</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">refine</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">lift_on&#39;</span> <span class="n">e</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">mk</span> <span class="bp">_</span><span class="o">,</span>
        <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">H</span><span class="o">,</span> <span class="n">apply</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">sound</span><span class="o">,</span> <span class="n">apply</span> <span class="n">H</span> <span class="o">},</span>
      <span class="k">have</span> <span class="n">hf</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">f</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">intros</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span>
        <span class="n">change</span> <span class="n">is_open</span> <span class="o">(</span><span class="n">quotient</span><span class="bp">.</span><span class="n">mk</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="bp">_</span><span class="o">),</span>
        <span class="n">rw</span> <span class="err">←</span> <span class="n">set</span><span class="bp">.</span><span class="n">preimage_comp</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">hs</span> <span class="o">},</span>
      <span class="n">refine</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">exact</span> <span class="o">(</span><span class="n">t2_space&#39;</span><span class="bp">.</span><span class="n">t2</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">u</span> <span class="n">v</span> <span class="n">h1</span> <span class="n">h2</span> <span class="n">h3</span> <span class="n">h4</span><span class="o">,</span> <span class="bp">_</span><span class="o">),</span>
      <span class="n">rcases</span> <span class="n">H</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">hf</span> <span class="bp">_</span> <span class="n">h1</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="bp">_</span> <span class="n">h2</span><span class="o">)</span> <span class="n">h3</span> <span class="n">h4</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">z</span><span class="o">,</span> <span class="n">zu</span><span class="o">,</span> <span class="n">zv</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">exact</span> <span class="bp">⟨</span><span class="n">fz</span><span class="o">,</span> <span class="n">zu</span><span class="o">,</span> <span class="n">zv</span><span class="bp">⟩</span>
    <span class="kn">end</span> <span class="o">}</span>
</pre></div>

<a name="136060806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/136060806" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#136060806">Johannes Hölzl (Oct 18 2018 at 18:04)</a>:</h4>
<p>By the way: this T2 space definition is equal to <code>not (disjoint (nhds x) (nhds y)) -&gt; x = y</code>.</p>

<a name="136061226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/136061226" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#136061226">Mario Carneiro (Oct 18 2018 at 18:11)</a>:</h4>
<p>not constructively</p>

<a name="136061506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/lean%20golf/near/136061506" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/48009leangolf.html#136061506">Mario Carneiro (Oct 18 2018 at 18:16)</a>:</h4>
<p>(oops, wrong thread, this should be in <a href="#narrow/stream/116395-maths/subject/Hausdorffification/near/136026443" title="#narrow/stream/116395-maths/subject/Hausdorffification/near/136026443">Hausdorffification</a>)</p>


{% endraw %}

{% include archive_update.html %}