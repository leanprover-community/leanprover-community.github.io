---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/50231groupequiv.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html">group_equiv</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="159916408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/159916408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#159916408">Kevin Buzzard (Mar 04 2019 at 14:13)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">group_equiv</span> <span class="kn">extends</span> <span class="n">G</span> <span class="err">≃</span> <span class="n">H</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span> <span class="o">:</span> <span class="n">is_group_hom</span> <span class="n">to_fun</span><span class="o">}</span>
</pre></div>


<p>I'm making <code>group_equiv</code> because it is convenient to have it for the perfectoid project. It's not finished yet but for what it's worth here's the current state:</p>
<p><a href="https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/src/for_mathlib/group.lean" target="_blank" title="https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/src/for_mathlib/group.lean">https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/src/for_mathlib/group.lean</a></p>
<p>My question is: I have just realised that I want that if <code>H</code> and <code>K</code> are both normal subgroups of a group <code>G</code>, and if <code>h : H = K</code>, I want the obvious term of type <code>group_equiv (quotient H) (quotient K)</code>. Mathematically, I want to write down the isomorphism <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi mathvariant="normal">/</mi><mi>H</mi><mo>=</mo><mi>G</mi><mi mathvariant="normal">/</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">G/H=G/K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mrel">=</span><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span> if I know <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>=</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">H=K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span>.</p>
<p>Should this construction be part of the API, or is a ridiculous thing to prove? If <code>H = K</code> but the proof is not <code>rfl</code> then it seems to me that type theory would like me to define this term explicitly, and use it where necessary. Have I understood this correctly? I'm happy to prove it, I just want to check I'm not wasting my time.</p>

<a name="159916602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/159916602" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#159916602">Kevin Buzzard (Mar 04 2019 at 14:16)</a>:</h4>
<p>NB <code>H</code> and <code>K</code> have type <code>set G</code></p>

<a name="159925605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/159925605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#159925605">Kevin Buzzard (Mar 04 2019 at 16:07)</a>:</h4>
<p>Is this missing?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">quotient_group</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">quotient_group</span><span class="bp">.</span><span class="n">ker</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">normal_subgroup</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span>
<span class="n">is_group_hom</span><span class="bp">.</span><span class="n">ker</span> <span class="o">(</span><span class="n">quotient_group</span><span class="bp">.</span><span class="n">mk</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">quotient_group</span><span class="bp">.</span><span class="n">quotient</span> <span class="n">N</span><span class="o">)</span> <span class="bp">=</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>

<a name="159929405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/159929405" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#159929405">Kevin Buzzard (Mar 04 2019 at 16:50)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">quot_eq_of_eq</span> <span class="o">{</span><span class="n">G1</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">}</span> <span class="o">[</span><span class="n">normal_subgroup</span> <span class="n">G1</span><span class="o">]</span> <span class="o">{</span><span class="n">G2</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">}</span> <span class="o">[</span><span class="n">normal_subgroup</span> <span class="n">G2</span><span class="o">]</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G1</span> <span class="bp">=</span> <span class="n">G2</span><span class="o">)</span> <span class="o">:</span> <span class="n">group_equiv</span> <span class="o">(</span><span class="n">quotient</span> <span class="n">G1</span><span class="o">)</span> <span class="o">(</span><span class="n">quotient</span> <span class="n">G2</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">q</span><span class="o">,</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">lift_on&#39;</span> <span class="n">q</span> <span class="o">(</span><span class="n">quotient_group</span><span class="bp">.</span><span class="n">mk</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">quotient</span> <span class="n">G2</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hab</span><span class="o">,</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">sound&#39;</span>
  <span class="k">begin</span>
    <span class="n">change</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">G1</span> <span class="n">at</span> <span class="n">hab</span><span class="o">,</span> <span class="n">rwa</span> <span class="n">h</span> <span class="n">at</span> <span class="n">hab</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">q</span><span class="o">,</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">lift_on&#39;</span> <span class="n">q</span> <span class="o">(</span><span class="n">quotient_group</span><span class="bp">.</span><span class="n">mk</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">quotient</span> <span class="n">G1</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hab</span><span class="o">,</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">sound&#39;</span>
  <span class="k">begin</span>
    <span class="n">change</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">G2</span> <span class="n">at</span> <span class="n">hab</span><span class="o">,</span> <span class="n">rwa</span> <span class="err">←</span><span class="n">h</span> <span class="n">at</span> <span class="n">hab</span><span class="o">,</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">induction</span> <span class="n">x</span><span class="bp">;</span> <span class="n">refl</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">induction</span> <span class="n">x</span><span class="bp">;</span> <span class="n">refl</span><span class="o">,</span>
  <span class="n">hom</span> <span class="o">:=</span> <span class="n">quotient_group</span><span class="bp">.</span><span class="n">is_group_hom_quotient_lift</span>
    <span class="n">G1</span> <span class="bp">_</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="k">by</span> <span class="n">rwa</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="err">←</span><span class="n">quotient_group</span><span class="bp">.</span><span class="n">ker</span> <span class="n">G2</span><span class="o">,</span> <span class="n">is_group_hom</span><span class="bp">.</span><span class="n">mem_ker</span><span class="o">]</span> <span class="n">at</span> <span class="n">hx</span><span class="o">}</span>
</pre></div>

<a name="159929442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/159929442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#159929442">Kevin Buzzard (Mar 04 2019 at 16:51)</a>:</h4>
<p>The proof for <code>hom</code> should be <code>by apply_instance</code> but I couldn't convince Lean that it knew all the instances.</p>

<a name="162537350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162537350" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162537350">Assia Mahboubi (Apr 04 2019 at 15:33)</a>:</h4>
<blockquote>
<p>Mathematically, I want to write down the isomorphism  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi mathvariant="normal">/</mi><mi>H</mi><mo>=</mo><mi>G</mi><mi mathvariant="normal">/</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">G/H=G/K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mrel">=</span><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span> if I know  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>=</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">H=K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span>.</p>
</blockquote>
<p>Why isomorphism? Isn't this an equality?</p>

<a name="162537771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162537771" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162537771">Patrick Massot (Apr 04 2019 at 15:37)</a>:</h4>
<p>Oh, Assia is back! She even pretends to be a stupid mathematician like us</p>

<a name="162538265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162538265" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162538265">Johan Commelin (Apr 04 2019 at 15:42)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> You might as well try to answer her question...</p>

<a name="162538296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162538296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162538296">Johan Commelin (Apr 04 2019 at 15:42)</a>:</h4>
<p><span class="user-mention" data-user-id="110172">@Assia Mahboubi</span> It seems to give lots of headaches and back pains if you try to treat this as an equality.</p>

<a name="162538330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162538330" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162538330">Johan Commelin (Apr 04 2019 at 15:43)</a>:</h4>
<p>I still don't completely understand why and I still lament it. But it seems to have something to do with dependent type theory.</p>

<a name="162538355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162538355" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162538355">Johan Commelin (Apr 04 2019 at 15:43)</a>:</h4>
<p>Is this not a problem in Coq? You do have DTT, right?</p>

<a name="162539289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162539289" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162539289">Patrick Massot (Apr 04 2019 at 15:52)</a>:</h4>
<p>Johan, I don't think Assia is asking a question here...</p>

<a name="162542596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162542596" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162542596">Johan Commelin (Apr 04 2019 at 16:26)</a>:</h4>
<p>/me got trolled...</p>

<a name="162543436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162543436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162543436">Assia Mahboubi (Apr 04 2019 at 16:35)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="112680">@Johan Commelin</span> ! Yes, may be this has to do with (equality in) type theory.  So in type theory, there are terms and there are types. If <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">x</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span> are two terms of a same type <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">T</span></span></span></span>, one can state, and may be even prove, an equality statement <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x=y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">x</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>. In this case, one can substitute any occurrence of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">x</span></span></span></span> for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>. Well, almost all occurrences. For any 'context', i.e. for any <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span> of type <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>→</mo><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">T \rightarrow Type</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mord mathit">p</span><span class="mord mathit">e</span></span></span></span> (or <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>→</mo><mi>P</mi><mi>r</mi><mi>o</mi><mi>p</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T \rightarrow Prop)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">o</span><span class="mord mathit">p</span><span class="mclose">)</span></span></span></span>, one can turn <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">P(x)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span> into <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">P(y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>, by applying a lemma expressing the so-called "elimination rule of equality". Now in the flavour of dependent type theory we all like, types are themselves terms. So the latter also apply when <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">T</span></span></span></span> is a sort, and thus when <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">x</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span> are types. But in this case, there are around occurrences of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">x</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span> that are not of the former nature, the ones that are on the right hand-side of a column, like in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>:</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">t : x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.61508em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">t</span><span class="mrel">:</span><span class="mord mathit">x</span></span></span></span>. These cannot be affected by a "rewrite" : there is no way to turn <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>:</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">t:x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.61508em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">t</span><span class="mrel">:</span><span class="mord mathit">x</span></span></span></span> into <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>:</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">t:y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">t</span><span class="mrel">:</span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span> using <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x = y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">x</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>: the only useful thing here would be an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>:</mo><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">f : x \rightarrow y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mrel">:</span><span class="mord mathit">x</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>, and in this case if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>:</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">t:x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.61508em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">t</span><span class="mrel">:</span><span class="mord mathit">x</span></span></span></span> then of course  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mo>:</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">f(t):y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">t</span><span class="mclose">)</span><span class="mrel">:</span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>. Unless you not only know that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x=y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">x</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span> but in fact <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">x</span></span></span></span> is convertible to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>. And then indeed the conversion rule does the job. Conclusion: stating equality between types is mostly useless (i.e. not more useful than an equivalence).</p>

<a name="162543793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162543793" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162543793">Assia Mahboubi (Apr 04 2019 at 16:39)</a>:</h4>
<p>But in Kevin's case, I would say that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi mathvariant="normal">/</mi><mi>H</mi></mrow><annotation encoding="application/x-tex">G/H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.08125em;">H</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi mathvariant="normal">/</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">G/K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span> should be equal as elements of <code>set (set G)</code>. Sander, sitting next to me, suggests you could even attach more data if needed.</p>

<a name="162543973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162543973" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162543973">Patrick Massot (Apr 04 2019 at 16:41)</a>:</h4>
<p>G/H is a type in our setup (remember we love quotient types in Lean)</p>

<a name="162544074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162544074" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162544074">Patrick Massot (Apr 04 2019 at 16:42)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/78f1949719676db358ea5e68e211a73e2ce95e7b/src/group_theory/coset.lean#L160" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/78f1949719676db358ea5e68e211a73e2ce95e7b/src/group_theory/coset.lean#L160">https://github.com/leanprover-community/mathlib/blob/78f1949719676db358ea5e68e211a73e2ce95e7b/src/group_theory/coset.lean#L160</a></p>

<a name="162544251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162544251" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162544251">Assia Mahboubi (Apr 04 2019 at 16:44)</a>:</h4>
<p>I know. But may be this is not the best (let's say the only) way to express what you want. What do you want to express by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi mathvariant="normal">/</mi><mi>H</mi><mo>=</mo><mi>G</mi><mi mathvariant="normal">/</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">G/H=G/K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mrel">=</span><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span>, and what usage do you want for this statement?</p>

<a name="162544703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162544703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162544703">Patrick Massot (Apr 04 2019 at 16:50)</a>:</h4>
<p>I don't know what <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  had in mind</p>

<a name="162550560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162550560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162550560">Mario Carneiro (Apr 04 2019 at 17:55)</a>:</h4>
<p>I think the situation is that we want to say <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>=</mo><mi>K</mi><mspace width="0.277778em"></mspace><mo>⟹</mo><mspace width="0.277778em"></mspace><mi>G</mi><mi mathvariant="normal">/</mi><mi>H</mi><mo>≅</mo><mi>G</mi><mi mathvariant="normal">/</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">H = K\implies G/H\cong G/K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mrel"><span class="mspace thickspace"></span><span class="mrel">⟹</span></span><span class="mord mathit"><span class="mspace thickspace"></span><span class="mord mathit">G</span></span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mrel">≅</span><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span>, because <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.08125em;">H</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span> are sets (so they have a nice notion of equality) but <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi mathvariant="normal">/</mi><mi>H</mi></mrow><annotation encoding="application/x-tex">G/H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.08125em;">H</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi mathvariant="normal">/</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">G/K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span> are groups, so the right notion of equality is group isomorphism</p>

<a name="162550748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162550748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162550748">Mario Carneiro (Apr 04 2019 at 17:57)</a>:</h4>
<p>I think Coq avoids this problem by doing "subgroup theory", so that G/H and G/K are also sets (of equivalence classes or something), in some big ambient group</p>

<a name="162552880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162552880" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162552880">Kevin Buzzard (Apr 04 2019 at 18:19)</a>:</h4>
<p>I am sufficiently confused by equality in type theory that I don't know whether Assia is trolling or not :-)</p>

<a name="162553078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162553078" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162553078">Patrick Massot (Apr 04 2019 at 18:21)</a>:</h4>
<p>Hint: Assia mentioned several time that she thought very hard about this kind of question and wrote <a href="https://hal.inria.fr/hal-00825074v1/document" target="_blank" title="https://hal.inria.fr/hal-00825074v1/document">https://hal.inria.fr/hal-00825074v1/document</a> that was already cited many times here</p>

<a name="162553515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162553515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162553515">Kevin Buzzard (Apr 04 2019 at 18:24)</a>:</h4>
<p>The application was some technical result in valuation theory; if two valuations are equivalent then one is continuous if and only if the other one is. This comment of course clarifies essentially nothing. But I wrote down a careful proof of this on paper and then broke it up into tiny pieces. In some sense I am quite proud of the valuations API we have in the perfectoid project. It looks as much like a mathlib file as anything I have ever written. Many proofs are just a few lines long. The reason for this is that I am beginning to understand how to write code in these dependent type theory languages. I isolated this fact as something I needed, I was proving a whole bunch of groups were isomorphic, so I set up the notion of <code>group_equiv</code> and just did it the way one is supposed to do things, proved <code>group_equiv.trans</code> etc and proved that continuity was constant on equivalence classes.</p>
<p>I needed it because it is a basic fact about groups and it seemed to be a step in the process where rewriting was not such a wise idea, in short. I actually rewrote my proof so that the defining map was directly made using the quotient API; initially it was some composition which was much harder to work with.</p>

<a name="162621346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162621346" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162621346">Assia Mahboubi (Apr 05 2019 at 13:10)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> ! Thanks for explaining the context! I am not trolling by the way. And I think this is not so much about subgroup theory (or Lean vs Coq). But about the fact that types and sets are not the same in particular because they cannot be "substituted" in the same way. That's what I meant in my long message above.</p>
<p>My question is why would one need to state this <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi mathvariant="normal">/</mi><mi>K</mi><mo>=</mo><mi>G</mi><mi mathvariant="normal">/</mi><mi>H</mi></mrow><annotation encoding="application/x-tex">G/K=G/H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mrel">=</span><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.08125em;">H</span></span></span></span> at the level of types? What do you mean on paper by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi mathvariant="normal">/</mi><mi>K</mi><mo>=</mo><mi>G</mi><mi mathvariant="normal">/</mi><mi>H</mi></mrow><annotation encoding="application/x-tex">G/K=G/H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mrel">=</span><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.08125em;">H</span></span></span></span>? I would say I mean that the group datas (carrier, law) are the same. And any further stuff needed should follow from the canonical group structure endowed by these sort of things. I would say that this is not what an equality stated at the level of types provides.</p>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> , even in the Coq library you refer to, the <em>notations</em> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi mathvariant="normal">/</mi><mi>H</mi></mrow><annotation encoding="application/x-tex">G/H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.08125em;">H</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi mathvariant="normal">/</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">G/K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span> refer to terms with distinct types, because the type of groups modded  by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.08125em;">H</span></span></span></span> (like <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi mathvariant="normal">/</mi><mi>H</mi></mrow><annotation encoding="application/x-tex">G/H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.08125em;">H</span></span></span></span>) is a priori different from the type of groups modded by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span> (like <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi mathvariant="normal">/</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">G/K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">G</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span>). But one has access to the corresponding sets of cosets, which are equal (like, for real), and can be endowed with group structures.</p>

<a name="162622080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162622080" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162622080">Kevin Buzzard (Apr 05 2019 at 13:20)</a>:</h4>
<p>Mathematicians use <code>=</code> to mean "canonically isomorphic" sometimes, where "canonical" does not have a general definition but one can often pin down what they mean.</p>
<p>Quotients could be thought of as being only uniquely defined up to unique isomorphism, but actually in ZFC mathematicians are often taught that the quotient "equals" the set of equivalence classes. Because of this, the two quotients really are equal in ZFC. In general there are many objects in maths which are only defined up to canonical isomorphism (universal objects are a great example, they are defined up to unique isomorphism, which is a much clearer statement). However you can imagine more than one way of constructing the object. Mathematicians don't care which way they use, because we treat these objects in a different way to computer scientists. You guys need defintions. We are completely happy with properties defining the object up to unique isomorphism. I don't care what "the group of order two" is when I'm being a mathematician, and if G and H are two groups of order 2 I would happily write G=H. Things are much more delicate in your world, which in some sense reflects a way that type theory does not capture the true essence of mathematics.</p>

<a name="162625995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162625995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162625995">Assia Mahboubi (Apr 05 2019 at 14:05)</a>:</h4>
<blockquote>
<p>type theory does not capture the true essence of mathematics.</p>
</blockquote>
<p>I do not know. But I guess that whatever the foundation style, one needs to get the definitions right otherwise things soon get unnecessarily more delicate. I am somehow claiming here that  in your case you could have things behave as smoothly as in ZFC, if you renounce to a Type layer which, again in this case, seems to bring more troubles than support.</p>
<p>Anyway, I am happy to read that you eventually managed to find a satisfactory way out, which is ultimately the important criterium.</p>

<a name="162629388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162629388" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162629388">Kevin Buzzard (Apr 05 2019 at 14:45)</a>:</h4>
<p>In my mind, the quotient G/H is only defined up to canonical isomorphism but we are happy to use = to represent this, and furthermore we are happy to rewrite with this equality because we know how to treat groups and we would never ask a question of them for which the answer depended on anything other than the information of the group up to isomorphism. This is why it is frustrating not to be able to make these rewrites.</p>

<a name="162636787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/group_equiv/near/162636787" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/50231groupequiv.html#162636787">Assia Mahboubi (Apr 05 2019 at 16:13)</a>:</h4>
<p>Performing these substitutions would be way easier if groups were not types  (beyond this very specific example where the datas are equal).</p>


{% endraw %}
