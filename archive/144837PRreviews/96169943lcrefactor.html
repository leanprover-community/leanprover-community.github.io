---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/144837PRreviews/96169943lcrefactor.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/144837PRreviews/index.html">PR reviews</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html">#943 lc refactor</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="165044255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/165044255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#165044255">Johan Commelin (May 07 2019 at 05:29)</a>:</h4>
<p><span class="user-mention" data-user-id="129120">@Alexander Bentkamp</span> Any news on this PR? Are there problems or challenges showing up?</p>

<a name="165051068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/165051068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#165051068">Alexander Bentkamp (May 07 2019 at 08:06)</a>:</h4>
<p>Yes, It's definitely a challenge. I don't believe in Mario's proposal to remove the <code>set</code> argument of <code>linear_independent</code> anymore. I tried it and it led me into something that felt like a swamp. It wasn't really that I got stuck, but it just felt harder and harder to move forward <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span> .</p>

<a name="165051416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/165051416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#165051416">Mario Carneiro (May 07 2019 at 08:10)</a>:</h4>
<p>pray tell</p>

<a name="165051515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/165051515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#165051515">Mario Carneiro (May 07 2019 at 08:12)</a>:</h4>
<p>my claim is that it should be easier, so even if you were able to finish a proof if it seemed unnecessarily complicated then I would like to see it</p>

<a name="165053977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/165053977" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#165053977">Alexander Bentkamp (May 07 2019 at 08:58)</a>:</h4>
<p>Ok, I pushed my current state to the pull request. It's a big mess, but what I have been trying to do is to adapt <code>linear_independent_union</code> to the new definition. I figured that I'd need some auxilliary lemmas and started adding those on the top of the file. But those lemmas again needed additional lemmas etc.</p>

<a name="165148467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/165148467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#165148467">Alexander Bentkamp (May 08 2019 at 09:47)</a>:</h4>
<p>My new plan is to change the definition of <code>is_basis</code> first. Some lemmas about <code>linear_dependent</code> seem to be very specifically designed to be used in the section about <code>is_basis</code>. Once I have made it work for <code>is_basis</code>, I might see more clearly.</p>

<a name="166372225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/166372225" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#166372225">Alexander Bentkamp (May 23 2019 at 15:35)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> How do you think should the lemmas <code>exists_linear_independent</code> and <code>linear_independent_sUnion_of_directed</code> look like after the refactoring? I am tempted to use sets for this, i.e. <code>linear_independent α (subtype.val : s → β)</code> for <code>s : set β</code>.</p>

<a name="166406601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/166406601" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#166406601">Mario Carneiro (May 23 2019 at 22:39)</a>:</h4>
<p><code>exists_linear_independent</code> should use sets to some extent. Given a linear independent family <code>f : I -&gt; V</code> and a set <code>t : set V</code> such that <code>\all i, f i \in t</code>, there exists a <code>b \sub t</code> such that <code>\all i, f i \in b</code> and <code>t \sub span b</code> and <code>(coe : b -&gt; V)</code> is linear independent</p>

<a name="166406701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/166406701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#166406701">Mario Carneiro (May 23 2019 at 22:41)</a>:</h4>
<p><code>linear_independent_sUnion_of_directed</code> looks equivalent to some statement about colimits, I will ask <span class="user-mention" data-user-id="110032">@Reid Barton</span></p>

<a name="166407026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/166407026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#166407026">Mario Carneiro (May 23 2019 at 22:47)</a>:</h4>
<p>The background is a collection of maps <code>f j : I j -&gt; V</code> where <code>j : J</code> is coming from a partially ordered index set, and there is a map <code>h j j' : I j -&gt; I j'</code> when <code>j &lt;= j'</code>, and <code>f j' = h j j' o f j</code></p>

<a name="166407193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/166407193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#166407193">Reid Barton (May 23 2019 at 22:50)</a>:</h4>
<p>This is for the goal of proving that every vector space has a basis, right?<br>
If you're going to do it using Zorn's lemma then you need to bring in sets at some point I suppose.</p>

<a name="166407211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/166407211" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#166407211">Mario Carneiro (May 23 2019 at 22:50)</a>:</h4>
<p>I'm just thinking about <code>linear_independent_sUnion_of_directed</code> in isolation at the moment</p>

<a name="166407215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/166407215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#166407215">Reid Barton (May 23 2019 at 22:50)</a>:</h4>
<p>In its current form, it looks like the lemma basically reflects the fact that linear independence can be checked on finite subsets</p>

<a name="166407310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/166407310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#166407310">Mario Carneiro (May 23 2019 at 22:51)</a>:</h4>
<p>if you replace the sets with familes, then I think it's talking about a colimit cone in Type</p>

<a name="166407394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/166407394" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#166407394">Mario Carneiro (May 23 2019 at 22:52)</a>:</h4>
<p>(Obviously this is bringing enough new tech to the statement that the original version will be wanted anyway, but I'm trying to find the "natural generalization")</p>

<a name="166407425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/166407425" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#166407425">Reid Barton (May 23 2019 at 22:53)</a>:</h4>
<p>Not just in Type, but types equipped with a map to β (i.e. <code>over Type β</code>)</p>

<a name="166407442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/166407442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#166407442">Reid Barton (May 23 2019 at 22:54)</a>:</h4>
<p>i.e. "families in β"</p>

<a name="166407522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/166407522" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#166407522">Reid Barton (May 23 2019 at 22:54)</a>:</h4>
<p>So then I suppose it says that the families which consist of linearly independent elements are closed under directed colimits</p>

<a name="166431644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/166431644" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#166431644">Alexander Bentkamp (May 24 2019 at 08:05)</a>:</h4>
<blockquote>
<p>Obviously this is bringing enough new tech to the statement that the original version will be wanted anyway, but I'm trying to find the "natural generalization"</p>
</blockquote>
<p>You mean I should leave the current version basically as is and then derive the family version from it? IMO that would be the easiest way to prove it.</p>

<a name="166433645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/166433645" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#166433645">Mario Carneiro (May 24 2019 at 08:41)</a>:</h4>
<p>I mean you should in principle derive the union from the family version, but since the family version looks complicated just keep the set version and put the family version off until we need it</p>

<a name="166434116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/166434116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#166434116">Alexander Bentkamp (May 24 2019 at 08:50)</a>:</h4>
<p>ok</p>

<a name="166434146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/166434146" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#166434146">Alexander Bentkamp (May 24 2019 at 08:50)</a>:</h4>
<p>I think I will have something that complies again soon. Then I'll show you what I've done so far.</p>

<a name="166643287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/166643287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#166643287">Alexander Bentkamp (May 27 2019 at 14:50)</a>:</h4>
<p>Maybe actually not so soon. Now I have run into issues with universe levels in<code>dimension.lean</code>.</p>

<a name="167468540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/167468540" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#167468540">Alexander Bentkamp (Jun 06 2019 at 10:10)</a>:</h4>
<p>Yay! I finally have something that compiles again. The main change I made is to use families instead of sets for <code>is_basis</code>. The predicate <code>linear_independent</code> still has two arguments, one for families and one for sets, but I am working on eliminating the set argument now.</p>

<a name="168319773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168319773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168319773">Alexander Bentkamp (Jun 17 2019 at 15:23)</a>:</h4>
<p>I added a function</p>
<div class="codehilite"><pre><span></span><span class="kn">protected</span> <span class="n">def</span> <span class="n">elim</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="err">⊕</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">sum</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">x</span> <span class="n">f</span> <span class="n">g</span>
</pre></div>


<p>to <code>data/sum.lean</code>, as <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  proposed.</p>
<p>But where should the lemmas</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">sum</span><span class="bp">.</span><span class="n">elim_injective</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">g</span><span class="o">)</span>
 <span class="o">(</span><span class="n">hfg</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">g</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">injective</span> <span class="o">(</span><span class="n">sum</span><span class="bp">.</span><span class="n">elim</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>and</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">sum</span><span class="bp">.</span><span class="n">elim_range</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">range</span> <span class="o">(</span><span class="n">sum</span><span class="bp">.</span><span class="n">elim</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="n">range</span> <span class="n">f</span> <span class="err">∪</span> <span class="n">range</span> <span class="n">g</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>go? <code>injective</code> and <code>range</code> are not imported in <code>data/sum.lean</code>.</p>

<a name="168324720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168324720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168324720">Johan Commelin (Jun 17 2019 at 16:19)</a>:</h4>
<p><span class="user-mention" data-user-id="129120">@Alexander Bentkamp</span> I would put them close to <code>sum_range_succ</code> etc... somewhere in <code>data/finsupp</code> I guess.</p>

<a name="168378994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168378994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168378994">Alexander Bentkamp (Jun 18 2019 at 08:14)</a>:</h4>
<p>Not sure what you mean. <code>sum_range_succ</code> exists only in <code>algebra/big_operators</code> and its not about the <code>⊕</code> sum, but about <code>finset.sum</code>. And why should it go into <code>data/finsupp</code>?</p>

<a name="168379282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168379282" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168379282">Mario Carneiro (Jun 18 2019 at 08:18)</a>:</h4>
<p><code>sum.elim_injective</code> should fit in <code>data.sum</code>, unless you are using some unusual theorem about <code>injective</code>. The definition is in core, in the <code>function</code> namespace</p>

<a name="168379298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168379298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168379298">Mario Carneiro (Jun 18 2019 at 08:19)</a>:</h4>
<p><code>sum.elim_range</code> can go in <code>data.set.basic</code> or <code>data.set.lattice</code></p>

<a name="168379779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168379779" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168379779">Alexander Bentkamp (Jun 18 2019 at 08:26)</a>:</h4>
<p>Oh, right. I simply forgot to add <code>function.</code> before <code>injective</code> and then thought it was not available.</p>

<a name="168381696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168381696" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168381696">Johan Commelin (Jun 18 2019 at 08:59)</a>:</h4>
<p><span class="user-mention" data-user-id="129120">@Alexander Bentkamp</span> My bad... I actually meant <code>big_operators</code>, I think. Anyway, please follow Mario's advice.</p>

<a name="168381752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168381752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168381752">Alexander Bentkamp (Jun 18 2019 at 09:00)</a>:</h4>
<p>Ok, thanks.</p>

<a name="168535457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168535457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168535457">Alexander Bentkamp (Jun 19 2019 at 18:55)</a>:</h4>
<p>I have finally removed the set argument of <code>linear_independent</code> completely. <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  Please have a look at the pull request again. I think it is ready to be merged now.</p>

<a name="168535492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168535492" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168535492">Alexander Bentkamp (Jun 19 2019 at 18:55)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/943" target="_blank" title="https://github.com/leanprover-community/mathlib/pull/943">https://github.com/leanprover-community/mathlib/pull/943</a></p>

<a name="168536643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168536643" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168536643">Johan Commelin (Jun 19 2019 at 19:08)</a>:</h4>
<p>You added 1000 lines of code!! Wow!</p>

<a name="168573096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168573096" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168573096">Alexander Bentkamp (Jun 20 2019 at 07:34)</a>:</h4>
<p>I hope it's not just because my proving style is more verbose than yours :-)</p>

<a name="168575144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168575144" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168575144">Alexander Bentkamp (Jun 20 2019 at 08:12)</a>:</h4>
<p>As we discussed earlier, <code>exists_linear_independent</code>, <code>linear_independent_sUnion_of_directed</code>, and related lemmas still use sets (coerced to a subtype and then used as the index type). I hope that you can accept the pull request anyway because every time I rebase on top of master, there are new commits using <code>lc</code> or <code>linear_independent</code> and I have to adapt them to my changes.</p>

<a name="168575298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168575298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168575298">Alexander Bentkamp (Jun 20 2019 at 08:15)</a>:</h4>
<p>In an failed attempt to replace these lemmas based on sets by lemmas based on types, I added the section <code>sigma</code> on the bottom of <code>data/finsupp</code>. It is not used anywhere now, but I think it might be useful in the future. Let me know if you'd rather have it removed.</p>

<a name="168659677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168659677" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168659677">Scott Morrison (Jun 21 2019 at 06:42)</a>:</h4>
<p><span class="user-mention" data-user-id="129120">@Alexander Bentkamp</span>, I just started having a look at your branch. I'm glad <code>lc</code> doesn't exist anymore, good riddance. :-)</p>
<p>I'm still bamboozled by the basic thing I've been missing all along with the <code>lc</code> library. Where is the definition:</p>
<div class="codehilite"><pre><span></span>def just_add_up_the_terms {α β} [discrete_field α] [add_comm_group β] [vector_space α β] (f : β →₀ α) : β := sorry
</pre></div>

<a name="168659697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168659697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168659697">Mario Carneiro (Jun 21 2019 at 06:43)</a>:</h4>
<p>isn't that <code>lc.total</code> (now <code>finsupp.total</code>)?</p>

<a name="168659698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168659698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168659698">Alexander Bentkamp (Jun 21 2019 at 06:43)</a>:</h4>
<p>I guess you mean <code>finsupp.total</code>?</p>

<a name="168659709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168659709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168659709">Alexander Bentkamp (Jun 21 2019 at 06:43)</a>:</h4>
<p>one second too slow :D</p>

<a name="168659749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168659749" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168659749">Scott Morrison (Jun 21 2019 at 06:44)</a>:</h4>
<p>How do I use that? I tried</p>
<div class="codehilite"><pre><span></span>def just_add_up_the_terms {α β} [discrete_field α] [add_comm_group β] [vector_space α β] (f : β →₀ α) : β := (finsupp.total _ _ _ id).1 f
</pre></div>

<a name="168659752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168659752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168659752">Alexander Bentkamp (Jun 21 2019 at 06:44)</a>:</h4>
<p>It's hard to beat Mario :D</p>

<a name="168659758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168659758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168659758">Scott Morrison (Jun 21 2019 at 06:44)</a>:</h4>
<p>(which already seems ... a bit long-winded ... for the basic operation)</p>

<a name="168659774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168659774" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168659774">Scott Morrison (Jun 21 2019 at 06:44)</a>:</h4>
<p>but get errors about not finding an <code>add_comm_group (β →₀ α)</code> instance</p>

<a name="168659872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168659872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168659872">Scott Morrison (Jun 21 2019 at 06:46)</a>:</h4>
<p>So I guess I'm down to two questions: <br>
1. why don't we generate that instance, and <br>
2. can we have a shorter name for this, that doesn't require me to put in the <code>_ _ _ id</code>?</p>

<a name="168660000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660000" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660000">Mario Carneiro (Jun 21 2019 at 06:49)</a>:</h4>
<p>I think Alex said something about how leaving those arguments out causes the tc inference to fail, which is why they are explicit in the first place</p>

<a name="168660054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660054">Scott Morrison (Jun 21 2019 at 06:50)</a>:</h4>
<p>But what if we specialise <code>v</code> to <code>id</code> first? Then the types are all determined by <code>f</code>, I think.</p>

<a name="168660060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660060">Mario Carneiro (Jun 21 2019 at 06:50)</a>:</h4>
<p>they are, I'm not exactly sure about the order of operations here. I was surprised by this as well</p>

<a name="168660079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660079" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660079">Scott Morrison (Jun 21 2019 at 06:51)</a>:</h4>
<p>I think my main complaint is that I want a function with <code>v</code> already specialised to <code>id</code>, as this seems like most peoples' main use case.</p>

<a name="168660093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660093" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660093">Mario Carneiro (Jun 21 2019 at 06:51)</a>:</h4>
<p>More precisely, I think that it won't be able to use <code>f</code> for type inference because that happens after the coercion is inserted, and it can't insert the coercion until it knows the type of the finsupp.total application</p>

<a name="168660104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660104" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660104">Scott Morrison (Jun 21 2019 at 06:51)</a>:</h4>
<p>Ok, the instance not being generated is just about decidability:</p>
<div class="codehilite"><pre><span></span>import linear_algebra.finsupp

local attribute [instance, priority 0] classical.prop_decidable
noncomputable theory

def finsupp.total&#39; {α β} [discrete_field α] [add_comm_group β] [vector_space α β] (f : β →₀ α) : β := (finsupp.total _ _ _ id).1 f
</pre></div>

<a name="168660160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660160">Scott Morrison (Jun 21 2019 at 06:52)</a>:</h4>
<p>Which coercion?</p>

<a name="168660162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660162" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660162">Mario Carneiro (Jun 21 2019 at 06:52)</a>:</h4>
<p>rah rah kill decidability arguments</p>

<a name="168660173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660173">Mario Carneiro (Jun 21 2019 at 06:52)</a>:</h4>
<p>the coercion from -&gt;0 to -&gt;</p>

<a name="168660189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660189">Scott Morrison (Jun 21 2019 at 06:53)</a>:</h4>
<p>Sorry, I don't see where such a coercion is happening.</p>

<a name="168660190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660190" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660190">Mario Carneiro (Jun 21 2019 at 06:53)</a>:</h4>
<p>Or rather, the coercion from -&gt;l to -&gt;</p>

<a name="168660192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660192" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660192">Scott Morrison (Jun 21 2019 at 06:53)</a>:</h4>
<p>ah</p>

<a name="168660193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660193">Mario Carneiro (Jun 21 2019 at 06:53)</a>:</h4>
<p><code>finsupp.total</code> is a linear function</p>

<a name="168660200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660200" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660200">Mario Carneiro (Jun 21 2019 at 06:53)</a>:</h4>
<p>is the .1 supposed to be the coercion?</p>

<a name="168660219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660219" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660219">Scott Morrison (Jun 21 2019 at 06:54)</a>:</h4>
<p>yes</p>

<a name="168660324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660324" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660324">Alexander Bentkamp (Jun 21 2019 at 06:56)</a>:</h4>
<p>Maybe you could use <code>finsupp.sum</code> instead.</p>

<a name="168660345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660345" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660345">Scott Morrison (Jun 21 2019 at 06:57)</a>:</h4>
<p>but then I still need to provide the silly binary function doing scalar multiplication</p>

<a name="168660351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660351">Mario Carneiro (Jun 21 2019 at 06:57)</a>:</h4>
<p>isn't it just (\bu)?</p>

<a name="168660352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660352" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660352">Scott Morrison (Jun 21 2019 at 06:57)</a>:</h4>
<p>I just want to sum up a linear combination! :-)</p>

<a name="168660363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660363">Mario Carneiro (Jun 21 2019 at 06:57)</a>:</h4>
<p>I think it's reasonable to have this as a dedicated function. I guess it used to be there with <code>lc.total</code></p>

<a name="168660364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660364" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660364">Scott Morrison (Jun 21 2019 at 06:57)</a>:</h4>
<p>But I shouldn't need to say it at all, even if it is just (\bu), I think.</p>

<a name="168660410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660410">Mario Carneiro (Jun 21 2019 at 06:58)</a>:</h4>
<p>should it be linear?</p>

<a name="168660428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660428">Mario Carneiro (Jun 21 2019 at 06:59)</a>:</h4>
<p>actually I guess the function can be defined in more generality than "linear" can be</p>

<a name="168660591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660591">Scott Morrison (Jun 21 2019 at 07:02)</a>:</h4>
<p>Ugh, what is the deal with <code>fin_supp.zip_with</code>? It has explicitly <code>decidable_eq</code> arguments for the types \a and \b, but then summons mid-proof a classical instance of decidability for \b\1.</p>

<a name="168660602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660602" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660602">Scott Morrison (Jun 21 2019 at 07:03)</a>:</h4>
<p>Surely it should be all or none</p>

<a name="168660656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660656">Scott Morrison (Jun 21 2019 at 07:04)</a>:</h4>
<p>(Sorry, Alex, I am not complaining to you about these things --- I suspect they predate your helpful refactor. :-)</p>

<a name="168660764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660764" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660764">Mario Carneiro (Jun 21 2019 at 07:07)</a>:</h4>
<p>I want to kill all decidability args in finsupp, polynomial and mv_polynomial</p>

<a name="168660767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660767" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660767">Scott Morrison (Jun 21 2019 at 07:07)</a>:</h4>
<p>I am very much in favour. :-)</p>

<a name="168660773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660773">Scott Morrison (Jun 21 2019 at 07:07)</a>:</h4>
<p>Those files use classical everywhere already.</p>

<a name="168660777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660777" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660777">Mario Carneiro (Jun 21 2019 at 07:07)</a>:</h4>
<p>we are fooling ourselves to think these are actually computation-friendly</p>

<a name="168660778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660778" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660778">Johan Commelin (Jun 21 2019 at 07:07)</a>:</h4>
<blockquote>
<p>I want to kill all decidability args in finsupp, polynomial and mv_polynomial</p>
</blockquote>
<p>Does that also kill computation?</p>

<a name="168660817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660817">Scott Morrison (Jun 21 2019 at 07:08)</a>:</h4>
<p>I think it was already dead.</p>

<a name="168660825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660825" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660825">Mario Carneiro (Jun 21 2019 at 07:08)</a>:</h4>
<p>if you actually want to compute with polynomials finsupp is a <em>terrible</em> representation</p>

<a name="168660830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660830" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660830">Scott Morrison (Jun 21 2019 at 07:08)</a>:</h4>
<p>/me is sad there is no parrot emoji.</p>

<a name="168660842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660842" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660842">Kenny Lau (Jun 21 2019 at 07:08)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> which list is the best list computationally?</p>

<a name="168660855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660855" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660855">Mario Carneiro (Jun 21 2019 at 07:09)</a>:</h4>
<p>For polynomial, a list or array of coefficients</p>

<a name="168660857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660857" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660857">Johan Commelin (Jun 21 2019 at 07:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I was positively surprised by the following reasonable fast proof in an otherwise very slow file:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">witt_add_zero</span> <span class="o">:</span> <span class="n">witt_add</span> <span class="n">p</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">X</span> <span class="o">(</span><span class="n">tt</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">+</span> <span class="n">X</span> <span class="o">(</span><span class="n">ff</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">dec_trivial</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">witt_mul_zero</span> <span class="o">:</span> <span class="n">witt_mul</span> <span class="n">p</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">X</span> <span class="o">(</span><span class="n">tt</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">*</span> <span class="n">X</span> <span class="o">(</span><span class="n">ff</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">dec_trivial</span>
</pre></div>

<a name="168660863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660863">Scott Morrison (Jun 21 2019 at 07:09)</a>:</h4>
<p>So, how shall we go about removing decidability arguments here? In Alex's PR? Separately?</p>

<a name="168660866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660866">Kenny Lau (Jun 21 2019 at 07:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> is <code>list</code> better or is <code>array</code> better?</p>

<a name="168660869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660869" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660869">Mario Carneiro (Jun 21 2019 at 07:09)</a>:</h4>
<p>separately</p>

<a name="168660878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660878" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660878">Mario Carneiro (Jun 21 2019 at 07:09)</a>:</h4>
<p>we've made alex wait long enough, I think this is ready for merge</p>

<a name="168660905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660905" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660905">Johan Commelin (Jun 21 2019 at 07:10)</a>:</h4>
<p>If we go classical, you have to prove those statements by hand. But maybe that's a small offer to make.</p>

<a name="168660927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660927" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660927">Mario Carneiro (Jun 21 2019 at 07:10)</a>:</h4>
<p>array is more efficient in the VM</p>

<a name="168660938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660938" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660938">Johan Commelin (Jun 21 2019 at 07:10)</a>:</h4>
<blockquote>
<p>we've made alex wait long enough, I think this is ready for merge</p>
</blockquote>
<p>I haven't had a chance to look at it, but I trust your judgement.</p>

<a name="168660943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660943">Johan Commelin (Jun 21 2019 at 07:10)</a>:</h4>
<p>Go for it!</p>

<a name="168660944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660944" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660944">Mario Carneiro (Jun 21 2019 at 07:10)</a>:</h4>
<p>you have to prove those statements by simp</p>

<a name="168660971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660971">Kenny Lau (Jun 21 2019 at 07:11)</a>:</h4>
<p>how is a function represented in VM?</p>

<a name="168660984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660984" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660984">Mario Carneiro (Jun 21 2019 at 07:11)</a>:</h4>
<p>an <code>array</code> is represented as an array in the VM, don't let the signature fool you</p>

<a name="168660987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168660987" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168660987">Mario Carneiro (Jun 21 2019 at 07:11)</a>:</h4>
<p>a function is a closure</p>

<a name="168661442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168661442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168661442">Mario Carneiro (Jun 21 2019 at 07:22)</a>:</h4>
<p>You are going to hate me for making this suggestion, but I notice that you are using the idiom <code>linear_independent α (λ x, x : s → β)</code> a lot. Maybe we should give this a name <code>linear_independent_set α s</code>, just to make the statements a bit nicer.</p>

<a name="168662317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168662317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168662317">Kenny Lau (Jun 21 2019 at 07:44)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> but you still need some decidability if you use arrays to make polynomials right</p>

<a name="168662330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168662330" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168662330">Mario Carneiro (Jun 21 2019 at 07:44)</a>:</h4>
<p>yes, but that's a problem for the computational interpretation only</p>

<a name="168662338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168662338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168662338">Mario Carneiro (Jun 21 2019 at 07:44)</a>:</h4>
<p>it doesn't affect the definition or use of <code>polynomial</code></p>

<a name="168662419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168662419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168662419">Kenny Lau (Jun 21 2019 at 07:46)</a>:</h4>
<p>you need decidability of zero already if you want to add two polynomials together</p>

<a name="168662428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168662428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168662428">Mario Carneiro (Jun 21 2019 at 07:46)</a>:</h4>
<p>not if you don't trim zeros</p>

<a name="168662436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168662436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168662436">Kenny Lau (Jun 21 2019 at 07:46)</a>:</h4>
<p>I thought quotients are bad for computation</p>

<a name="168662448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168662448" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168662448">Mario Carneiro (Jun 21 2019 at 07:46)</a>:</h4>
<p>depends on what you want to do</p>

<a name="168662469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168662469" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168662469">Mario Carneiro (Jun 21 2019 at 07:47)</a>:</h4>
<p>I am actually not proposing a computational implementation at all. I just want to remove decidability args from finsupp without changing the definition</p>

<a name="168662471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168662471" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168662471">Kenny Lau (Jun 21 2019 at 07:47)</a>:</h4>
<p>(0x+1)^100 is very inefficient whereas 1^100 is very efficient right</p>

<a name="168662548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168662548" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168662548">Mario Carneiro (Jun 21 2019 at 07:48)</a>:</h4>
<p>I think that we should revisit computational polynomials if and when we ever care to compute with them</p>

<a name="168662570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168662570" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168662570">Mario Carneiro (Jun 21 2019 at 07:49)</a>:</h4>
<p>Generally there are a lot of factors that go into efficient implementations; dropping the <code>noncomputable</code> is only the beginning</p>

<a name="168662579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168662579" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168662579">Mario Carneiro (Jun 21 2019 at 07:49)</a>:</h4>
<p>and without an application it's likely to be mis-optimized</p>

<a name="168662639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168662639" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168662639">Mario Carneiro (Jun 21 2019 at 07:50)</a>:</h4>
<p>Compare this with computational real numbers vs <code>real</code> which is "computable" but basically useless</p>

<a name="168666153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168666153" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168666153">Kevin Buzzard (Jun 21 2019 at 09:03)</a>:</h4>
<blockquote>
<p>and without an application it's likely to be mis-optimized</p>
</blockquote>
<p>This is just the tip of the iceberg. I had some very illuminating conversations with William Stein about this a few years ago, regarding implementation of linear algebra. I did some computations of modular forms in Sage a long time ago, and they were fast. I did some more, several years later, and they were much slower. Amongst the algorithms which go into all of this are basic linear algebra algorithms. I asked William what was going on, and he said that what happens in practice is that people observe that the linear algebra algorithms run slowly for the use case they have in mind, so they rip them out and implement "better" ones (e.g. perhaps from a newer paper) which run much better in their use case, but then they don't notice that there are other use cases which have degraded. There is no silver bullet for optimisation.</p>

<a name="168669469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168669469" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168669469">Reid Barton (Jun 21 2019 at 10:11)</a>:</h4>
<p>Some recent discussions here as well as some talks at Big Proof 2 have led me to the following position regarding doing computer algebra in Lean. The foundational layer of definitions (for things like polynomials, or localizations of rings) should be the mathematical ones, fully general (e.g. without finiteness assumptions), and not necessarily efficient to compute with or even computable at all. On top of that one can then build representations which are good for computation in specific scenarios (e.g. polynomials in finitely many variables, or localization of a Euclidean domain), and use the underlying mathematical concepts to specify the semantics of the representations and algorithms and prove correctness of the algorithms.</p>

<a name="168669624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168669624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168669624">Reid Barton (Jun 21 2019 at 10:14)</a>:</h4>
<p>AFAIK all currently existing computer algebra systems have only this second layer--the foundational layer and the relationship between them exists only in the form of documentation and pen-and-paper proofs.</p>

<a name="168670703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23943%20lc%20refactor/near/168670703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/96169943lcrefactor.html#168670703">Johan Commelin (Jun 21 2019 at 10:37)</a>:</h4>
<p>If I understand correctly, this would also make it more conceptual that one can swap out different computational overlays depending on application.</p>


{% endraw %}
