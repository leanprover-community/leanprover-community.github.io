---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/144837PRreviews/59921410backwardsreasoning.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/144837PRreviews/index.html">PR reviews</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html">#410 backwards reasoning</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="135520408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/135520408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#135520408">Scott Morrison (Oct 10 2018 at 16:41)</a>:</h4>
<p>I've just made a <code>[WIP]</code> pull request for the backwards reasoning tactic which has been discussed in &lt;<a href="#narrow/stream/113488-general/topic/proposal.20for.20.60backwards_reasoning.60" title="#narrow/stream/113488-general/topic/proposal.20for.20.60backwards_reasoning.60">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/proposal.20for.20.60backwards_reasoning.60</a>&gt;.</p>

<a name="135520452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/135520452" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#135520452">Scott Morrison (Oct 10 2018 at 16:42)</a>:</h4>
<p>It still needs some work (possibly not all of it before merging):<br>
1. Verify that this can be used as a replacement for <code>backwards_reasoning</code> currently in <code>lean-tidy</code>, for applications in <code>lean-category-theory</code>.<br>
2. Combine the <code>back</code> and <code>elim</code> attributes into just <code>back</code>, and <code>back!</code>, using <code>!</code> as a parameter.<br>
3. Indexing, to make it fun fast. (It's not slow on small examples, but...?)<br>
4. Refactor, and cleanup, as it's not the nicest code at the moment.</p>

<a name="135520471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/135520471" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#135520471">Scott Morrison (Oct 10 2018 at 16:43)</a>:</h4>
<p>I am going to get on with 1. If anyone is interested in helping with 2/3/4 (<span class="user-mention" data-user-id="110026">@Simon Hudon</span> ? <span class="user-mention" data-user-id="110032">@Reid Barton</span> ?) that would be amazing. :-)</p>

<a name="135520517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/135520517" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#135520517">Simon Hudon (Oct 10 2018 at 16:44)</a>:</h4>
<p>Sure, I'll have a look at 3</p>

<a name="136460194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/136460194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#136460194">Johan Commelin (Oct 25 2018 at 18:11)</a>:</h4>
<p>Currently the example <code>tests/back.lean</code> seems to be broken.</p>

<a name="148342156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148342156" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148342156">Scott Morrison (Nov 26 2018 at 13:29)</a>:</h4>
<p>Here are the constraints:</p>
<ul>
<li>We want to do backtracking search using the "finishing" lemmas, but we don't want to backtrack past the application of a "progress" lemma</li>
<li>Prioritising the application of different lemmas is a bit complicated, and I don't know what is best!</li>
</ul>

<a name="148342157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148342157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148342157">Scott Morrison (Nov 26 2018 at 13:29)</a>:</h4>
<p>You might think we want to apply "progress" lemmas first (because they've been selected as lemmas which "it's always helpful to apply"!). However it's easy to find situations where you really want to apply a local hypothesis with even higher priority. The current hack is to call <code>solve_by_elim</code> with all the lemmas, and then if that fails, try applying a progress lemma and restart <code>back</code>. This is horribly inefficient (in particular, it can uselessly call <code>solve_by_elim</code> over and over again).</p>

<a name="148352552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148352552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148352552">Scott Morrison (Nov 26 2018 at 19:01)</a>:</h4>
<p>Okay, mostly talking to myself here, but I think this is the behaviour I want from <code>back</code> (and will need to rewrite to actually achieve).</p>
<p>Given lists of lemmas <code>P</code> and <code>F</code> (for "progress" and "finishing"), I want to produce a maximal tree of applications, possibly still with metavariables (i.e. remaining subgoals), subject to the condition that no metavariable appears inside an application of a lemma from <code>F</code>. (It might seem that this means if you use any <code>F</code> lemma, you have to discharge the original goal, but that is not the case --- a <code>P</code> lemma might produce multiple subgoals, and then we use <code>F</code> lemmas to completely discharge some but not all of these.)</p>
<p>Now, in general there are many possible such maximal trees. I want to do a depth first search of the space of possible applications, where at each stage the lemmas as sorted according to their "number of open arguments", where "open arguments" just means an argument that would create a subgoal when the lemma is applied. (This is more or less the same as the number of arguments which could not be made implicit!) This ensures that if it is ever possible to actually close a goal immediately, we will investigate that before applying lemmas that would create a further subgoal. It also means it's possible to use transitivity lemmas (e.g. <code>category.comp</code>) in <code>back</code>, but as these typically produce at least 3 new subgoals, they will only be explored "as last resorts".</p>

<a name="148352634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148352634" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148352634">Scott Morrison (Nov 26 2018 at 19:03)</a>:</h4>
<p><span class="user-mention" data-user-id="110111">@Keeley Hoek</span>, do you think computing that "number of open arguments" for a lemma is easy? I was thinking you'd have to inspect each binder in a Pi type, and just check whether the corresponding <code>var</code> actually occurs in the result.</p>

<a name="148353043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148353043" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148353043">Mario Carneiro (Nov 26 2018 at 19:12)</a>:</h4>
<p>there is a function that does this in <code>expr</code></p>

<a name="148353057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148353057" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148353057">Mario Carneiro (Nov 26 2018 at 19:13)</a>:</h4>
<p>it is used for pretty printing exprs, since nondependent pis look different</p>

<a name="148353836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148353836" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148353836">Keeley Hoek (Nov 26 2018 at 19:33)</a>:</h4>
<p>Sure<br>
Just to make sure I understand: the number of "open arguments" of each lemma isn't something that can change throughout the iterations, is it?<br>
Seems like an afternoon-doable thing I guess<br>
So with unwinding, what are we meant to do if we never actually fully discharge the goal?<br>
Say I have a list of "terminal" goals in the search, which one do I actually decide the goal state should be?<br>
---perhaps this backtracking could be a pain</p>

<a name="148354826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148354826" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148354826">Keeley Hoek (Nov 26 2018 at 19:57)</a>:</h4>
<p>By the way, here is another problem I had when writing <code>#where</code>; since <code>data.list.basic</code> imports <code>data.nat.basic</code>, you can't use any code which, say implements sorting lists (as we will want here) which is defined in that file unless you want your tactic to be unusable there.<br>
But, particularly in <code>data.list.basic</code>, there are a whole bunch of useful functions which are just algorithms, but the proofs which are listed alongside them carry the burden of knowing facts about nats, for example. Is there any scope for separating what is a program/routine and what is a proof about a program?</p>

<a name="148355649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148355649" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148355649">Mario Carneiro (Nov 26 2018 at 20:15)</a>:</h4>
<p>yes, this is reasonable. For the most part we have gotten away without it because all the defs are in <code>init.data.list.basic</code>, but we should probably have a file for additional functions on lists added in mathlib</p>

<a name="148356627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148356627" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148356627">Scott Morrison (Nov 26 2018 at 20:36)</a>:</h4>
<blockquote>
<p>So with unwinding, what are we meant to do if we never actually fully discharge the goal?<br>
Say I have a list of "terminal" goals in the search, which one do I actually decide the goal state should be?<br>
---perhaps this backtracking could be a pain</p>
</blockquote>

<a name="148356653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148356653" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148356653">Scott Morrison (Nov 26 2018 at 20:37)</a>:</h4>
<p>I'm not really sure what you meant here. (Also, I wasn't trying (too hard) to pressure you into doing any of this, Keeley. I think I will rewrite the main algorithm, but without the "sorting by number of open arguments" part at first.)</p>

<a name="148356800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148356800" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148356800">Keeley Hoek (Nov 26 2018 at 20:41)</a>:</h4>
<p>Ok sure that's cool<br>
But yeah if we just count non-implicit arguments working out that number is totally not a big deal</p>
<p>What I was trying to say is if we work out some "tree" with some leaves, none of which actually end up closing all of the goals and giving a proof, we're meant to return control back to the user (and not fail), right? If I understood what the tree was right then wouldn't we have to pick a leaf to leave the goal state in? (if so and I don't misunderstood, I was wondering how to pick this leaf)</p>

<a name="148356883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148356883" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148356883">Scott Morrison (Nov 26 2018 at 20:42)</a>:</h4>
<p>Oh, I see, you mean what order should the goals be returned in?</p>

<a name="148356891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148356891" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148356891">Johan Commelin (Nov 26 2018 at 20:43)</a>:</h4>
<p>The safe option is probably just to backtrack, and don't pick a leaf.</p>

<a name="148356894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148356894" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148356894">Scott Morrison (Nov 26 2018 at 20:43)</a>:</h4>
<p>I guess just the order they pop out of <code>apply</code> in.</p>

<a name="148356899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148356899" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148356899">Johan Commelin (Nov 26 2018 at 20:43)</a>:</h4>
<p>No, that's not what he meant.</p>

<a name="148356904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148356904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148356904">Scott Morrison (Nov 26 2018 at 20:43)</a>:</h4>
<p>Ah!</p>

<a name="148356906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148356906" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148356906">Scott Morrison (Nov 26 2018 at 20:43)</a>:</h4>
<p>Okay :-) Sorry, two different trees going on here.</p>

<a name="148356918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148356918" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148356918">Scott Morrison (Nov 26 2018 at 20:43)</a>:</h4>
<p>My idea was just to never backtrack back pass the successful application of a <code>progress</code> lemma</p>

<a name="148356961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148356961" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148356961">Scott Morrison (Nov 26 2018 at 20:44)</a>:</h4>
<p>So it matters how they get ordered!</p>

<a name="148356976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148356976" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148356976">Johan Commelin (Nov 26 2018 at 20:44)</a>:</h4>
<p>What I would like to have in the future is that (if the number of leaves is reasonable), I can just cycle through them interactively, and tell the computer: "Hey, this one looks interesting, let's keep it around." or "Mwahh, this one's going nowhere. We can toss it out."</p>

<a name="148356982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148356982" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148356982">Scott Morrison (Nov 26 2018 at 20:44)</a>:</h4>
<p>It may be necessary to give the user a way to specify both progress and finishing lemmas directly.</p>

<a name="148356988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148356988" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148356988">Keeley Hoek (Nov 26 2018 at 20:44)</a>:</h4>
<p>Ok gotcha<br>
I guess the "maximal trees" were psyching me out</p>

<a name="148357002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148357002" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148357002">Scott Morrison (Nov 26 2018 at 20:45)</a>:</h4>
<p>I was wondering if we can actually write something like: <code>back [foo!, bar, baz!]</code>, and use the exclamation marks to distinguish between the two sorts of lemmas.</p>

<a name="148357004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148357004" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148357004">Keeley Hoek (Nov 26 2018 at 20:45)</a>:</h4>
<p>yep that's a thing</p>

<a name="148357009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148357009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148357009">Keeley Hoek (Nov 26 2018 at 20:45)</a>:</h4>
<p>(like an easy thing I mean, supported functionality even!) :D</p>

<a name="148357060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148357060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148357060">Scott Morrison (Nov 26 2018 at 20:46)</a>:</h4>
<p>I think actually it might be worth swapping the meaning of <code>!</code> and no-<code>!</code>, so <code>!</code> is for decorating the "progress lemmas". As in "this lemma is a really good idea, apply it whenever you can!"</p>

<a name="148357129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148357129" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148357129">Keeley Hoek (Nov 26 2018 at 20:48)</a>:</h4>
<p>How about <code>:commitment:</code> for <code>commit</code>ed xd</p>

<a name="148357522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148357522" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148357522">Johan Commelin (Nov 26 2018 at 20:57)</a>:</h4>
<p>We don't really care about <code>commit</code>s though... only about <code>push</code> and <code>merge</code>... but I don't know good emoji's for those either...</p>

<a name="148407774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148407774" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148407774">Scott Morrison (Nov 27 2018 at 10:46)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, do you recall the name of this function:</p>
<blockquote>
<p>Mario Carneiro: there is a function that does this in expr<br>
Mario Carneiro: it is used for pretty printing exprs, since nondependent pis look different</p>
</blockquote>
<p>I've had a look but can't identify it.</p>

<a name="148407791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148407791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148407791">Scott Morrison (Nov 27 2018 at 10:47)</a>:</h4>
<p>Recall this is inspecting a lemma, and deciding how many arguments it has that are not fixed by the return type. Hopefully this is the same number as the number of new goals that will be created when we <code>apply</code> the lemma.</p>

<a name="148410955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148410955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148410955">Keeley Hoek (Nov 27 2018 at 12:00)</a>:</h4>
<p>I think maybe there is a little subtlety with dependence here scott which has to be accounted for because of the following situation:<br>
say a big 2-layer Pi binder has type <code>var 0</code> (nice and simple), but the inner pi binder defining <code>var 0</code> has type depending itself on <code>var 0</code> (which now refers to the outer Pi binder)<br>
Then we should observe that both arguments will have to be accounted for, right?</p>

<a name="148411034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148411034" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148411034">Scott Morrison (Nov 27 2018 at 12:03)</a>:</h4>
<p>Oof, I'm not sure I follow. Can you give an example?</p>

<a name="148411274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148411274" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148411274">Scott Morrison (Nov 27 2018 at 12:09)</a>:</h4>
<p>I've just pushed a major revision of <code>back</code>. It's more efficient, has better user interface, and entirely subsumes <code>apply_rules</code>. (And possibly also <code>solve_by_elim</code>, I'd have to think a bit.)</p>

<a name="148412008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148412008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148412008">Keeley Hoek (Nov 27 2018 at 12:28)</a>:</h4>
<p>When making an example I realised my original point was just something that you'd make an implicit arg, but here is a variant.</p>
<div class="codehilite"><pre><span></span>def my_type (n : ℕ) := Type

def my_identity {n : ℕ} (t : my_type n) : Type := t
</pre></div>


<p>Imagine applying <code>my_identity</code> to the goal. The nat <code>n</code> will be deduced when the goal associated with <code>t</code> is cleared, but the var associated to <code>n</code> does not appear in the type and will be considered explicit. I guess changing this is just an improvement to the goal-estimator.</p>

<a name="148412018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148412018" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148412018">Keeley Hoek (Nov 27 2018 at 12:28)</a>:</h4>
<p>Also super sick tactic</p>

<a name="148617753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148617753" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148617753">Scott Morrison (Nov 27 2018 at 16:14)</a>:</h4>
<p>I think I'm happy for <code>apply my_identity</code> to count as creating two goals. Unfortunately I haven't yet worked out how to do this accounting, and I can see playing with examples that it will be really helpful. You'll be able to tag more ambitious lemmas as <code>[back]</code> without worrying about them derailing quick and otherwise successful searches.</p>

<a name="148617836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148617836" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148617836">Johan Commelin (Nov 27 2018 at 16:17)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Just reading the docs for <code>back</code> that you wrote. So in the list <code>hs</code> there is no distinction between <code>foo</code> and <code>foo!</code>?</p>

<a name="148617841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148617841" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148617841">Scott Morrison (Nov 27 2018 at 16:17)</a>:</h4>
<p>There is! (Or there should be... docs aren't finished.)</p>

<a name="148617885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148617885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148617885">Scott Morrison (Nov 27 2018 at 16:18)</a>:</h4>
<p>first, in the list you have to write it as <code>!foo</code> for now, as I couldn't get the parser to accept trailing punctuation in a list.</p>

<a name="148617895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148617895" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148617895">Scott Morrison (Nov 27 2018 at 16:18)</a>:</h4>
<p>second, using <code>!foo</code> will include <code>foo</code> in the list of lemmas whose successful application qualifies as an overall success, even if we don't end up discharging all subgoals.</p>

<a name="148618030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618030">Scott Morrison (Nov 27 2018 at 16:22)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span>, do you know this one? How do I tell ahead of time how many goals <code>apply L</code> will create, if <code>L</code> is some expr? I want to count how many Pi binders there are, that aren't determined by the result type.</p>

<a name="148618035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618035" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618035">Johan Commelin (Nov 27 2018 at 16:22)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> This is really cool! I'm looking forward to having this in my toolkit <span class="emoji emoji-1f528" title="hammer">:hammer:</span></p>

<a name="148618045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618045" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618045">Scott Morrison (Nov 27 2018 at 16:23)</a>:</h4>
<p>Said another way, if you pretty-printed the type, some arguments would be shown as Pi's and some just as function arrows (because nothing later depends on that argument). I want to know the number that will appear as function arrows.</p>

<a name="148618052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618052" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618052">Scott Morrison (Nov 27 2018 at 16:23)</a>:</h4>
<p>Mario said that this exists somewhere in <code>expr</code>, for the sake of pretty-printing, but I haven't been able to find it.</p>

<a name="148618121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618121" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618121">Simon Hudon (Nov 27 2018 at 16:25)</a>:</h4>
<p><code>is_arrow</code> will give you that information for the first pi type. If you want to count the arrows, you can do it like this:</p>

<a name="148618228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618228" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618228">Simon Hudon (Nov 27 2018 at 16:28)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">meta</span> <span class="n">def</span> <span class="n">count_arrows</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">-&gt;</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr</span><span class="bp">.</span><span class="n">pi</span> <span class="n">n</span> <span class="n">bi</span> <span class="n">d</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
   <span class="k">if</span> <span class="n">b</span><span class="bp">.</span><span class="n">has_var_idx</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">count_arrows</span> <span class="n">b</span>
                      <span class="k">else</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">count_arrows</span> <span class="n">b</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="mi">0</span>
</pre></div>

<a name="148618237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618237" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618237">Simon Hudon (Nov 27 2018 at 16:29)</a>:</h4>
<p>You can modify this code to list their types but you'll need to take better care of bound variables.</p>

<a name="148618242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618242" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618242">Scott Morrison (Nov 27 2018 at 16:29)</a>:</h4>
<p>I really just need the count for my application, so this is perfect.</p>

<a name="148618245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618245" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618245">Simon Hudon (Nov 27 2018 at 16:30)</a>:</h4>
<p><span class="emoji emoji-1f44d" title="+1">:+1:</span></p>

<a name="148618307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618307" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618307">Scott Morrison (Nov 27 2018 at 16:30)</a>:</h4>
<p>err... while you're here, do you know how to sort lists by the value of a function in Lean?</p>

<a name="148618308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618308" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618308">Simon Hudon (Nov 27 2018 at 16:30)</a>:</h4>
<p>Please let me know if it works. I haven't used <code>has_var_idx</code> before and I'd like to make sure I used it properly</p>

<a name="148618310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618310">Keeley Hoek (Nov 27 2018 at 16:30)</a>:</h4>
<p>Does that really work simon? Like what if <code>b</code> is another <code>expr.pi</code>, so that a <code>var 0</code> bound under this other <code>pi</code> changes the meaning of <code>var 0</code><br>
Does <code>has_var_idx</code> actually account for that? (I guess I should just read its implementation)</p>

<a name="148618370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618370" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618370">Simon Hudon (Nov 27 2018 at 16:32)</a>:</h4>
<p><span class="user-mention" data-user-id="110111">@Keeley Hoek</span> I think so. The correct way of implementing it would be that every time you encounter a binder, instead of calling recursively <code>has_var_idx n</code> you call <code>has_var_idx $ n+1</code> so that when you use the function, you're actually looking for variables bound exactly where the call originated from.</p>

<a name="148618378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618378" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618378">Keeley Hoek (Nov 27 2018 at 16:33)</a>:</h4>
<p>Actually, according to line 303 of src/library/vm/vm_expr.cpp is seems that <code>expr.has_var_idx _ 0</code> always returns false?</p>

<a name="148618389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618389" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618389">Keeley Hoek (Nov 27 2018 at 16:33)</a>:</h4>
<p>sure makes sense</p>

<a name="148618504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618504">Keeley Hoek (Nov 27 2018 at 16:36)</a>:</h4>
<p>From a little test I'm definitely wrong<br>
But I totally don't understand why :D</p>

<a name="148618510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618510">Keeley Hoek (Nov 27 2018 at 16:36)</a>:</h4>
<p>Oh <code>auto n</code> is a pointer, all g</p>

<a name="148618520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618520" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618520">Simon Hudon (Nov 27 2018 at 16:37)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> If you import <code>data.list.sort</code>, you can choose your sorting algorithm (say <code>merge_sort</code>) and you have to provide a relation. What you can do if you want to sort according to <code>f</code> is to use <code>inv_image (&lt;) f</code> as the relation you're going to sort with.</p>

<a name="148618570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618570" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618570">Simon Hudon (Nov 27 2018 at 16:38)</a>:</h4>
<p><span class="user-mention" data-user-id="110111">@Keeley Hoek</span> Thanks for looking into it. I'm reassured :)</p>

<a name="148618638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618638" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618638">Keeley Hoek (Nov 27 2018 at 16:40)</a>:</h4>
<p>Note though that then you can't use <code>back</code> in the stuff which <code>data.list.sort</code> imports, which includes <code>tactic.interactive</code> and <code>algebra.group</code>. If anyone more confident could come up with some "official" names for an algorithm file and a proof file, I'll de-splice like mario suggested/claimed non-opposition-in-principle above</p>

<a name="148618777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618777" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618777">Simon Hudon (Nov 27 2018 at 16:45)</a>:</h4>
<p>Is the issue that you're putting <code>back</code> in <code>tactic.interactive</code>?</p>

<a name="148618830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618830" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618830">Keeley Hoek (Nov 27 2018 at 16:46)</a>:</h4>
<p>it's not an issue per-se<br>
It's just that if you ever want to prove something with back in any of those files it includes<br>
well<br>
you can't</p>

<a name="148618831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618831" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618831">Scott Morrison (Nov 27 2018 at 16:46)</a>:</h4>
<p>Oh, this is beautiful. <code>count_arrows</code> does exactly what I wanted (after I remembered to <code>infer_type</code> on the lemma .... duh!), and moreover sorting the lemmas by <code>count_arrows</code> has exactly the desired effect, and <code>back</code> is no longer distracted when you give it dumb lemmas (e.g. transitivity style lemmas).</p>

<a name="148618833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618833">Keeley Hoek (Nov 27 2018 at 16:46)</a>:</h4>
<p>whooooooooooooooooooooooooooooooooooo</p>

<a name="148618979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148618979" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148618979">Simon Hudon (Nov 27 2018 at 16:51)</a>:</h4>
<p><span class="user-mention" data-user-id="110111">@Keeley Hoek</span> To reduce the size of the dependency, you can use <code>qsort</code> which is defined in core</p>

<a name="148619022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148619022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148619022">Keeley Hoek (Nov 27 2018 at 16:52)</a>:</h4>
<p>Thanks simon I didn't know about that</p>

<a name="148619080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148619080" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148619080">Scott Morrison (Nov 27 2018 at 16:55)</a>:</h4>
<p>Oh, it turns out I need one little tweak to <code>count_arrows</code>. Since I automatically try applying <code>iff</code> statements in both directions, I need to add one if the statement ends with an <code>iff</code>.</p>

<a name="148619260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148619260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148619260">Mario Carneiro (Nov 27 2018 at 17:01)</a>:</h4>
<p>how about <code>data.list.defs</code>?</p>

<a name="148619410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148619410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148619410">Simon Hudon (Nov 27 2018 at 17:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Try</p>
<div class="codehilite"><pre><span></span><span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="err">%%</span><span class="n">a</span> <span class="bp">&lt;-&gt;</span> <span class="err">%%</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">+</span> <span class="n">count_arrows</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">count_arrows</span> <span class="n">b</span>
</pre></div>


<p>as an additional branch</p>

<a name="148619417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148619417" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148619417">Scott Morrison (Nov 27 2018 at 17:07)</a>:</h4>
<p>ooh, I'm not sure that's actually the counting I want.</p>

<a name="148619466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148619466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148619466">Scott Morrison (Nov 27 2018 at 17:08)</a>:</h4>
<p>I think <code>1 + min (count_arrows a) (count_arrows b)</code> is actually what I need.</p>

<a name="148619531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148619531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148619531">Scott Morrison (Nov 27 2018 at 17:10)</a>:</h4>
<p>In any case, thanks. I see that handling <code>iff</code>s requires a bit more work, but I'll have to pause for now.</p>

<a name="148619591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148619591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148619591">Simon Hudon (Nov 27 2018 at 17:13)</a>:</h4>
<p>Good luck :) I've been meaning to look more closely at your project but I've been pretty absorbed by something else ... plus three other projects. In any case, don't hesitate to call on me if you need to.</p>

<a name="148622890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148622890" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148622890">Johan Commelin (Nov 27 2018 at 18:55)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Is back going to kill this goal for me?</p>
<div class="codehilite"><pre><span></span><span class="err">⊢</span> <span class="n">X</span><span class="bp">.</span><span class="n">left</span> <span class="err">⟶</span> <span class="n">X</span><span class="bp">.</span><span class="n">left</span>
</pre></div>


<p>I currently have</p>
<div class="codehilite"><pre><span></span><span class="o">{</span> <span class="n">app</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span><span class="n">tidy</span><span class="o">,</span> <span class="n">exact</span> <span class="mi">𝟙</span> <span class="bp">_</span><span class="o">,</span> <span class="n">tidy</span><span class="o">,</span> <span class="n">exact</span> <span class="mi">𝟙</span> <span class="bp">_</span><span class="o">,</span> <span class="n">tidy</span><span class="o">,</span> <span class="o">}</span> <span class="o">},</span>
</pre></div>

<a name="148665760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148665760" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148665760">Scott Morrison (Nov 28 2018 at 07:32)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>: If you tag <code>category.id</code> with <code>back</code> then <code>tidy</code> will kill this goal.</p>
<p>However this would be a bad idea. Better would be to define an attribute <code>[fyn]</code>, and tag <code>category.id</code>, <code>category.comp</code>, and a few other things with <code>[fyn]</code>, and then define <code>meta def follow_your_nose : tactic unit := `[back [fyn]]</code>, and then <code>local attribute [tidy] follow_your_nose</code> will result in <code>tidy</code> being able to kill goals like this.</p>

<a name="148678798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148678798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148678798">Scott Morrison (Nov 28 2018 at 11:15)</a>:</h4>
<p>I've now removed <code>apply_rules</code>, moving its test cases into the test cases for <code>back</code>.</p>
<p>My todo list is now:</p>
<ul>
<li>[ ] Decide if <code>solve_by_elim</code> should be subsumed by <code>back</code>; they are very close.</li>
<li>[X] Switch to using <code>back [lemma] using [attr]</code> instead of <code>back [lemma, attr]</code>.</li>
<li>[X] Add support for <code>back using [!attr]</code>.</li>
<li>[ ] Can we use postfix <code>!</code> for lemmas, e.g. <code>back [attr!]</code> instead of the current <code>back [!attr]</code>?</li>
<li>[ ] Add a mechanism to locally include an attribute in all calls to <code>back</code>, so we can write something like <code>local attribute [back] dvd</code>, where <code>dvd</code> is itself an attribute. (Not sure about the best implementation here.)</li>
</ul>
<p>Any suggestions about the implementation of the last two points appreciated.</p>

<a name="148741472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148741472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148741472">Scott Morrison (Nov 29 2018 at 07:40)</a>:</h4>
<p>Okay, <code>back</code> is getting more awesome. :-) How about this:</p>
<div class="codehilite"><pre><span></span>theorem infinitude_of_primes&#39;&#39; (N : ℕ) : ∃ p ≥ N, prime p :=
begin
  let M := fact N + 1,
  let p := min_fac M,
  use p,
  have pp : prime p, back,
  -- Goal is `∃ (H : p ≥ N), prime p`
  split; try { assumption },
  -- Goal is `p ≥ N`.
  by_contradiction h, simp at h,
  back,
end
</pre></div>

<a name="148741603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148741603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148741603">Scott Morrison (Nov 29 2018 at 07:42)</a>:</h4>
<p>(That is, <code>back</code> successfully, and quickly, runs the whole "<code>p | fact N</code>, and <code>p | M</code> so <code>p | 1</code>, but that's nonsense" argument by itself.)</p>

<a name="148741618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148741618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148741618">Mario Carneiro (Nov 29 2018 at 07:42)</a>:</h4>
<p>how is <code>back</code> performance looking at this point?</p>

<a name="148741653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148741653" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148741653">Scott Morrison (Nov 29 2018 at 07:43)</a>:</h4>
<p>And if you write <code>back?</code> there, it prints:</p>
<div class="codehilite"><pre><span></span>exact prime.not_dvd_one pp
  ((nat.dvd_add_iff_right (dvd_fact (prime.pos pp) (le_of_lt h)).mpr)
     (min_fac_dvd M))
</pre></div>

<a name="148741680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148741680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148741680">Mario Carneiro (Nov 29 2018 at 07:43)</a>:</h4>
<p>nice short proof there</p>

<a name="148741809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148741809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148741809">Scott Morrison (Nov 29 2018 at 07:45)</a>:</h4>
<p>It seems fast to me. :-)</p>
<div class="codehilite"><pre><span></span>example {a b c d e : nat} (h1 : a ≤ b) (h2 : c ≤ d) (h3 : 0 ≤ e) :
a + c * e + a + c + 0 ≤ b + d * e + b + d + e :=
by back [add_le_add, mul_le_mul_of_nonneg_right]
</pre></div>


<p>takes 0.259s, producing the proof <code>add_le_add (add_le_add (add_le_add (add_le_add h1 (mul_le_mul_of_nonneg_right h2 h3)) h1 ) h2) h3</code>.<br>
The proof above about primes takes 0.189s.</p>

<a name="148741914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148741914" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148741914">Scott Morrison (Nov 29 2018 at 07:46)</a>:</h4>
<p>I think the basic performance point here is: Leo made <code>apply</code> incredibly fast, and so if you don't do anything dumb with it, tactics based on it are fast.</p>

<a name="148741926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148741926" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148741926">Mario Carneiro (Nov 29 2018 at 07:47)</a>:</h4>
<p>I recall you mentioning that there were some known inefficiencies, are those fixed now?</p>

<a name="148741964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148741964" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148741964">Scott Morrison (Nov 29 2018 at 07:47)</a>:</h4>
<p>(And I should say, of course, <code>back</code> is really just tweaks and improvements on the already awesome <code>solve_by_elim</code>, by <span class="user-mention" data-user-id="110026">@Simon Hudon</span>).</p>

<a name="148741980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148741980" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148741980">Scott Morrison (Nov 29 2018 at 07:47)</a>:</h4>
<p>Yes, the efficiency problems are gone. It's a complete rewrite.</p>

<a name="148742097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148742097" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148742097">Scott Morrison (Nov 29 2018 at 07:49)</a>:</h4>
<p>A big todo list item remaining is the decide whether to replace <code>solve_by_elim</code> with <code>back</code>. There are two reasons I don't want to do this immediately:<br>
1) I'd have to check that <code>back</code> really is just as fast in all the applications in mathlib. (I suspect it is.)<br>
2) There's a fair bit of code in <code>back</code>, and I'd prefer to get some review of it before going to the effort of making replacements. :-)</p>

<a name="148742202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148742202" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148742202">Kevin Buzzard (Nov 29 2018 at 07:50)</a>:</h4>
<p>What does <code>back</code> do? I know people talk about it but I have no idea what it is supposed to do.</p>

<a name="148742207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148742207" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148742207">Scott Morrison (Nov 29 2018 at 07:50)</a>:</h4>
<p>That proof of the infinitude of primes makes me wish for a few things:<br>
1) <code>split</code> would try <code>assumption</code> on each propositional goal it produces (or perhaps even <code>back</code>!)</p>

<a name="148742229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148742229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148742229">Scott Morrison (Nov 29 2018 at 07:50)</a>:</h4>
<p>2) <code>by_contradiction h</code> would automatically try <code>simp at h</code> afterwards?</p>

<a name="148742296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148742296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148742296">Kenny Lau (Nov 29 2018 at 07:51)</a>:</h4>
<blockquote>
<p>That proof of the infinitude of primes makes me wish for a few things:<br>
1) <code>split</code> would try <code>assumption</code> on each propositional goal it produces (or perhaps even <code>back</code>!)</p>
</blockquote>
<p>you can write a <code>split'</code> tactic that does that! :D</p>

<a name="148742307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148742307" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148742307">Scott Morrison (Nov 29 2018 at 07:51)</a>:</h4>
<p>3) For a tactic <code>have' p : Q</code>, which is just <code>have p : Q, back</code>, for some better name for <code>have'</code>. :-)</p>

<a name="148742339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148742339" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148742339">Kenny Lau (Nov 29 2018 at 07:51)</a>:</h4>
<blockquote>
<p>2) <code>by_contradiction h</code> would automatically try <code>simp at h</code> afterwards?</p>
</blockquote>
<p>you can write <code>by_contradiction'</code>! :D</p>

<a name="148742351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148742351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148742351">Reid Barton (Nov 29 2018 at 07:51)</a>:</h4>
<p>in the limit, our proofs will be entirely <code>'</code>s</p>

<a name="148742606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148742606" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148742606">Scott Morrison (Nov 29 2018 at 07:54)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>, to a first approximation, <code>back</code> is just <code>solve_by_elim</code>. It repeatedly `apply's hypotheses against the goal, succeeding if it discharges the goal.</p>

<a name="148742718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148742718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148742718">Scott Morrison (Nov 29 2018 at 07:56)</a>:</h4>
<p>You can also pass it extra lemmas to use. You can also pass it attributes to use (so all lemmas with that attribute are applied). You can (soon) give it "hints", saying, for the rest of this file, always use all the lemmas marked with this attribute.</p>

<a name="148742774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148742774" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148742774">Scott Morrison (Nov 29 2018 at 07:57)</a>:</h4>
<p>You can also mark a lemma or hypothesis with <code>!</code> (as in <code>back [!foo]</code>, or <code>attribute [back!] foo</code>), and then <code>back</code> will act as an "interactive tactic" --- if it manages to apply a <code>!</code> lemma, it will return successfully even if it didn't complete every resulting subgoal.</p>

<a name="148742850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148742850" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148742850">Kenny Lau (Nov 29 2018 at 07:58)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>

<span class="kn">namespace</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>
<span class="kn">open</span> <span class="n">lean</span><span class="bp">.</span><span class="n">parser</span> <span class="n">tactic</span> <span class="n">interactive</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">split&#39;</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="bp">`</span><span class="o">[</span><span class="n">split</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span><span class="n">assumption</span><span class="o">}]</span>
<span class="kn">end</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">}</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">split&#39;</span>
<span class="kn">example</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">hp</span> <span class="o">:</span> <span class="n">q</span><span class="o">}</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">split&#39;</span>
</pre></div>

<a name="148742856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148742856" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148742856">Scott Morrison (Nov 29 2018 at 07:58)</a>:</h4>
<p>It's also clever enough to accept <code>iff</code> lemmas. (Although the current implementation says: if you apply an iff lemma, never apply it again.)</p>

<a name="148742863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148742863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148742863">Kevin Buzzard (Nov 29 2018 at 07:58)</a>:</h4>
<blockquote>
<p>in the limit, our proofs will be entirely <code>'</code>s</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Iota_and_Jot" target="_blank" title="https://en.wikipedia.org/wiki/Iota_and_Jot">https://en.wikipedia.org/wiki/Iota_and_Jot</a></p>

<a name="148743562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148743562" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148743562">Mario Carneiro (Nov 29 2018 at 08:07)</a>:</h4>
<p>I vote <code>then</code> for <code>have, back</code></p>

<a name="148743606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148743606" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148743606">Reid Barton (Nov 29 2018 at 08:08)</a>:</h4>
<p>can't wait for <code>thus</code>, <code>hence</code> and <code>therefore</code></p>

<a name="148743728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148743728" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148743728">Reid Barton (Nov 29 2018 at 08:09)</a>:</h4>
<p>Actually I don't think you can use <code>then</code></p>

<a name="148743738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148743738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148743738">Mario Carneiro (Nov 29 2018 at 08:09)</a>:</h4>
<p>oh, if then?</p>

<a name="148743760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148743760" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148743760">Reid Barton (Nov 29 2018 at 08:09)</a>:</h4>
<p>Yeah, it's complaining about "invalid expression"</p>

<a name="148743841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148743841" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148743841">Kevin Buzzard (Nov 29 2018 at 08:10)</a>:</h4>
<p><code>thither</code></p>

<a name="148743895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148743895" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148743895">Mario Carneiro (Nov 29 2018 at 08:11)</a>:</h4>
<p>nope, it's fine</p>

<a name="148743904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148743904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148743904">Mario Carneiro (Nov 29 2018 at 08:11)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>
<span class="n">meta</span> <span class="n">def</span> <span class="err">«</span><span class="k">then</span><span class="err">»</span> <span class="o">:=</span> <span class="err">«</span><span class="k">have</span><span class="err">»</span>
<span class="kn">end</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">then</span> <span class="n">a</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="n">trivial</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="148743969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148743969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148743969">Mario Carneiro (Nov 29 2018 at 08:12)</a>:</h4>
<p>you have to quote it since it's keywordish</p>

<a name="148743979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148743979" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148743979">Mario Carneiro (Nov 29 2018 at 08:12)</a>:</h4>
<p><code>have</code> is also defined like this</p>

<a name="148744041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148744041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148744041">Mario Carneiro (Nov 29 2018 at 08:13)</a>:</h4>
<p>although it's a bit weird that it shows up purple in the highlighting</p>

<a name="148744085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148744085" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148744085">Kenny Lau (Nov 29 2018 at 08:14)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> how would you convert my <code>split; try {assumption}</code> to tactic notation?</p>

<a name="148744093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148744093" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148744093">Mario Carneiro (Nov 29 2018 at 08:14)</a>:</h4>
<p>?</p>

<a name="148744104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148744104" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148744104">Kenny Lau (Nov 29 2018 at 08:14)</a>:</h4>
<p>I wrote this:</p>
<div class="codehilite"><pre><span></span><span class="n">meta</span> <span class="n">def</span> <span class="n">split&#39;</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="bp">`</span><span class="o">[</span><span class="n">split</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span><span class="n">assumption</span><span class="o">}]</span>
</pre></div>

<a name="148744123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148744123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148744123">Kenny Lau (Nov 29 2018 at 08:14)</a>:</h4>
<p>and I wonder how to write it using ... how do you call it</p>

<a name="148744128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148744128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148744128">Kenny Lau (Nov 29 2018 at 08:14)</a>:</h4>
<p>monads and what not</p>

<a name="148744152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148744152" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148744152">Kenny Lau (Nov 29 2018 at 08:15)</a>:</h4>
<p>because once I <code>tactic.split</code> it's hard to keep track of the newly added goals</p>

<a name="148744160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148744160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148744160">Kenny Lau (Nov 29 2018 at 08:15)</a>:</h4>
<p>I could get the goals before and after and just compare the length</p>

<a name="148744175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148744175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148744175">Kenny Lau (Nov 29 2018 at 08:15)</a>:</h4>
<p>but I don't think that's very safe nor the best way to do it</p>

<a name="148744244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148744244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148744244">Mario Carneiro (Nov 29 2018 at 08:16)</a>:</h4>
<p>a straight translation:</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">tactic</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">split&#39;</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">split</span> <span class="bp">&gt;&gt;</span> <span class="n">return</span> <span class="o">())</span><span class="bp">;</span> <span class="n">try</span> <span class="n">assumption</span>
<span class="kn">end</span> <span class="n">tactic</span>
</pre></div>

<a name="148744267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148744267" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148744267">Kenny Lau (Nov 29 2018 at 08:16)</a>:</h4>
<p>I have much to learn</p>

<a name="148744325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148744325" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148744325">Mario Carneiro (Nov 29 2018 at 08:17)</a>:</h4>
<p>the semicolon operator is <code>tactic.seq_focus</code></p>

<a name="148744333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148744333" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148744333">Mario Carneiro (Nov 29 2018 at 08:17)</a>:</h4>
<p>you can see what it does for goal management</p>

<a name="148744378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148744378" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148744378">Kenny Lau (Nov 29 2018 at 08:18)</a>:</h4>
<p>I see that the unsafe option (actually it's safe, it just seems weird) is used</p>

<a name="148744384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148744384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148744384">Kenny Lau (Nov 29 2018 at 08:18)</a>:</h4>
<p>well technically it is different</p>

<a name="148744388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148744388" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148744388">Kenny Lau (Nov 29 2018 at 08:18)</a>:</h4>
<p>I've learnt, thanks</p>

<a name="148744393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148744393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148744393">Mario Carneiro (Nov 29 2018 at 08:18)</a>:</h4>
<p>unsafe?</p>

<a name="148744406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148744406" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148744406">Kenny Lau (Nov 29 2018 at 08:18)</a>:</h4>
<p>I don't feel very comfortable messing with the goals</p>

<a name="148744440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148744440" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148744440">Mario Carneiro (Nov 29 2018 at 08:19)</a>:</h4>
<p>you can often just get away with using the built in tactic combinators like <code>and_then</code> if it suffices</p>

<a name="148767152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148767152" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148767152">Johan Commelin (Nov 29 2018 at 16:44)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> So we can now also do the following?</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">infinitude_of_primes&#39;&#39;</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">p</span> <span class="bp">≥</span> <span class="n">N</span><span class="o">,</span> <span class="n">prime</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">use</span> <span class="n">min_fac</span> <span class="o">(</span><span class="n">fact</span> <span class="n">N</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span><span class="bp">;</span> <span class="n">tidy</span>
</pre></div>


<p>Or will <code>tidy</code> not (yet) try the proof by contradiction? If we want to golf this proof, I suggest we introduce <code>N!</code> notation for factorials <span class="emoji emoji-1f923" title="rolling on the floor laughing">:rolling_on_the_floor_laughing:</span></p>

<a name="148767171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148767171" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148767171">Scott Morrison (Nov 29 2018 at 16:45)</a>:</h4>
<p>One thing to remember is that part of the philosophy of <code>tidy</code> is that it does no backtracking. So if we wanted to add <code>by_contradiction</code> to tidy, it would be because we're committing to "when all else fails, actually go ahead and try contradiction (returning to the user the goals produced by <code>by_contradiction</code>", which I don't think is a good idea.</p>

<a name="148767280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148767280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148767280">Johan Commelin (Nov 29 2018 at 16:48)</a>:</h4>
<p>Right... so we need a bigger hammer (-;<br>
Is it possible to write something like <code>tidy [by_contradiction]</code> so that <code>tidy</code> knows it can use that tactic for this proof?</p>

<a name="148767291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148767291" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148767291">Scott Morrison (Nov 29 2018 at 16:49)</a>:</h4>
<p>It's a reasonable idea. So far <code>tidy</code> doesn't take many configuration arguments.</p>

<a name="148767651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148767651" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148767651">Keeley Hoek (Nov 29 2018 at 17:00)</a>:</h4>
<p>Wouldn't <code>tidy { tactics := [by_contradiction &gt;&gt; return "by_contradiction"] }</code> work</p>

<a name="148767905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148767905" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148767905">Scott Morrison (Nov 29 2018 at 17:09)</a>:</h4>
<p>Oh, hmm, yeah :-)</p>

<a name="148773132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148773132" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148773132">Johan Commelin (Nov 29 2018 at 19:46)</a>:</h4>
<blockquote>
<p>Wouldn't <code>tidy { tactics := [by_contradiction &gt;&gt; return "by_contradiction"] }</code> work</p>
</blockquote>
<p>Cool! So the functionality is there. Now we only need to make it a bit more user-friendly. I guess the <code>&gt;&gt; return "by_contradiction"</code> is needed for the trace output, right? How hard is it to write a function that takes a <code>tactic</code> and stringifies its name?</p>

<a name="148777157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148777157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148777157">Keeley Hoek (Nov 29 2018 at 21:16)</a>:</h4>
<p>Well, Scott, if we use the fancy configurator then we could parse <code>tactic unit</code>s and <code>tactic strings</code> at the same time ;)<br>
But there is the dreaded <code>{}</code> requirement.<br>
Maybe an extra character? <code>tidy</code> or <code>tidy@{ my_config }</code>? I suspect this won't be approved :P</p>
<p>Unfortunately, Johan, the only way to obtain the name of a tactic you are passing is to use a <code>parser</code>, which is some work to set up the most convenient way.</p>

<a name="148777208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148777208" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148777208">Mario Carneiro (Nov 29 2018 at 21:17)</a>:</h4>
<p>what about <code>tidy with [stuff]</code>?</p>

<a name="148777280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/148777280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#148777280">Mario Carneiro (Nov 29 2018 at 21:19)</a>:</h4>
<p>Rather than trying to guess the tactic script, you should just have some additional tidy tactics that are enabled explicitly via some tags</p>

<a name="150909827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150909827" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150909827">Johan Commelin (Dec 05 2018 at 18:25)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> What is the status of this PR? I got the impression you made quite some nice improvements. Do you have more up your sleeve?</p>

<a name="150910787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150910787" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150910787">Scott Morrison (Dec 05 2018 at 18:51)</a>:</h4>
<p>It's a bit rough, but could be made usable with not much effort. However, I'd also like to put in a larger amount of effort, to make it better. :-)</p>

<a name="150910852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150910852" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150910852">Scott Morrison (Dec 05 2018 at 18:52)</a>:</h4>
<p>Essentially, at the moment it does a depth-first search of possible uses of <code>apply</code> (with a simple heuristic to order the branches, and one or two rules for cutting off the search). I'd really like to restructure the core code a bit, to make the type of search configurable, as once you make "too many" rules available to <code>back</code> the depth first search starts being too dumb.</p>

<a name="150910861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150910861" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150910861">Scott Morrison (Dec 05 2018 at 18:53)</a>:</h4>
<p>I'd really like to have it more robust to having "too many" rules, so that it's possible to just set and forget large groups of rules, and still have <code>back</code> performant enough.</p>

<a name="150910916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150910916" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150910916">Scott Morrison (Dec 05 2018 at 18:54)</a>:</h4>
<p>Given <code>back?</code> produces proof terms that you can copy and paste, it's potentially a good hammer.</p>

<a name="150913149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150913149" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150913149">Patrick Massot (Dec 05 2018 at 19:48)</a>:</h4>
<p>I have a question about this PR. How is it related to the core library <a href="https://github.com/leanprover/lean/blob/master/library/init/meta/backward.lean" target="_blank" title="https://github.com/leanprover/lean/blob/master/library/init/meta/backward.lean">back_chaining tactic</a>?</p>

<a name="150913185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150913185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150913185">Patrick Massot (Dec 05 2018 at 19:49)</a>:</h4>
<p>And, since <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> is here: what is the status of this tactic? What is only a tech demo, or is it meant to be ready for use? I discovered it while reading demo slides (POPL 2017)</p>

<a name="150913344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150913344" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150913344">Sebastian Ullrich (Dec 05 2018 at 19:53)</a>:</h4>
<p>I suppose it's just as ready to use as <code>rcases</code>. Which you people probably have more experience with and opinions about than me.</p>

<a name="150913352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150913352" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150913352">Patrick Massot (Dec 05 2018 at 19:53)</a>:</h4>
<p>Is it possible to use custom tags, or does it have to be <code>intro</code>?</p>

<a name="150913402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150913402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150913402">Patrick Massot (Dec 05 2018 at 19:54)</a>:</h4>
<p>It looks like only two things are tagged with <code>intro</code> in core+mathlib</p>

<a name="150913412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150913412" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150913412">Patrick Massot (Dec 05 2018 at 19:54)</a>:</h4>
<p>but still we could want several sets of lemmas depending on the kind of statement we'd like to prove</p>

<a name="150913533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150913533" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150913533">Scott Morrison (Dec 05 2018 at 19:58)</a>:</h4>
<p>That's a great question, Patrick. It looks closely related (and both to solve_by_elim). This one is implemented in C, and does two extra things --- allows you to specify a "simp" tactic to apply at each step, and allows you to specify a "leaf" tactic to apply once you run out of lemmas but haven't closed the goal.</p>

<a name="150913577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150913577" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150913577">Scott Morrison (Dec 05 2018 at 19:58)</a>:</h4>
<p>It doesn't seem to give you that much control over which lemmas to use (i.e. just the one attribute [intro])</p>

<a name="150913604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150913604" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150913604">Scott Morrison (Dec 05 2018 at 19:59)</a>:</h4>
<p>and <code>back</code> additionally gives you the idea of "progress" lemmas, i.e. lemmas whose successful application will result in the tactic being considered a success, even if it doesn't finish the proof. I've found this very useful in practice (and as part of <code>tidy</code>).</p>

<a name="150913611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150913611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150913611">Scott Morrison (Dec 05 2018 at 19:59)</a>:</h4>
<p>(I had no idea this one existed!)</p>

<a name="150913948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150913948" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150913948">Patrick Massot (Dec 05 2018 at 20:06)</a>:</h4>
<p>I found it yesterday!</p>

<a name="150917059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150917059" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150917059">Patrick Massot (Dec 05 2018 at 21:10)</a>:</h4>
<p>I have a riddle now. Download <a href="https://github.com/leanprover/lean/blob/master/library/init/meta/backward.lean" target="_blank" title="https://github.com/leanprover/lean/blob/master/library/init/meta/backward.lean">https://github.com/leanprover/lean/blob/master/library/init/meta/backward.lean</a> It works. Now add <code>import data.multiset</code> on top. It doesn't work anymore.</p>

<a name="150917106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150917106" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150917106">Johannes Hölzl (Dec 05 2018 at 21:11)</a>:</h4>
<p><code>backward.lean</code> is in <code>init</code> so it will be loaded automatically. <code>data.multiset</code> will import it.</p>

<a name="150917161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150917161" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150917161">Johannes Hölzl (Dec 05 2018 at 21:12)</a>:</h4>
<p><code>prelude</code> means to _not_ load <code>init</code></p>

<a name="150918133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150918133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150918133">Patrick Massot (Dec 05 2018 at 21:34)</a>:</h4>
<p>Oops, I copied the wrong link. I meant <a href="https://github.com/leanprover/presentations/blob/master/20170116_POPL/backchain/builtin.lean" target="_blank" title="https://github.com/leanprover/presentations/blob/master/20170116_POPL/backchain/builtin.lean">https://github.com/leanprover/presentations/blob/master/20170116_POPL/backchain/builtin.lean</a></p>

<a name="150918141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150918141" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150918141">Patrick Massot (Dec 05 2018 at 21:34)</a>:</h4>
<p>I'm sorry about this confusion</p>

<a name="150927154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150927154" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150927154">Patrick Massot (Dec 06 2018 at 00:26)</a>:</h4>
<p>Mario, did you try this little puzzle? Were you aware of <code>back_chaining</code>?</p>

<a name="150927485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150927485" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150927485">Mario Carneiro (Dec 06 2018 at 00:31)</a>:</h4>
<p>as I thought, it's a notation ambiguity problem</p>

<a name="150927577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150927577" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150927577">Mario Carneiro (Dec 06 2018 at 00:32)</a>:</h4>
<p><code>in_tail</code> and <code>in_head</code> break because the <code>::</code> is overloaded notation that means <code>multiset.cons</code> and <code>list.cons</code></p>

<a name="150927611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150927611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150927611">Mario Carneiro (Dec 06 2018 at 00:33)</a>:</h4>
<p>In this case you can fix it by putting a type ascription around <code>a::l</code></p>

<a name="150927729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150927729" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150927729">Patrick Massot (Dec 06 2018 at 00:35)</a>:</h4>
<p>Thanks. Are you sure this notation overloading was a good idea?</p>

<a name="150928365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150928365" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150928365">Mario Carneiro (Dec 06 2018 at 00:44)</a>:</h4>
<p>no, it's avoided almost everywhere because lean is flaky about it</p>

<a name="150928445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150928445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150928445">Mario Carneiro (Dec 06 2018 at 00:44)</a>:</h4>
<p>but in this case <code>::</code> is already overloaded in core so there isn't much we can do about it</p>

<a name="150928495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/150928495" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#150928495">Patrick Massot (Dec 06 2018 at 00:45)</a>:</h4>
<p>Sorry, I didn't realize this was in core</p>

<a name="156933827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23410%20backwards%20reasoning/near/156933827" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/59921410backwardsreasoning.html#156933827">Johan Commelin (Jan 27 2019 at 04:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Any updates with regards to <code>back</code>? Are there big issues, or just little things that need to be done? I still don't have the time to seriously learn how to write tactics, but I would love to see this one land in mathlib. If you are to busy with real-world maths, then I completely understand (it is eating my time as well).</p>


{% endraw %}
