---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/144837PRreviews/47033711Calculus.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/144837PRreviews/index.html">PR reviews</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html">#711 Calculus</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="157983538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/157983538" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#157983538">Johan Commelin (Feb 10 2019 at 17:30)</a>:</h4>
<p><span class="user-mention" data-user-id="130500">@Abhimanyu Pallavi Sudhir</span> It's cool to see that people are working on Calculus!<br>
Experience has shown that it works best if you make lots of small PRs (&lt;200 lines). So I think you have more than enough for two or three meaningful PRs. Big mega-project PRs tend to rot away in the PR list.</p>

<a name="157983822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/157983822" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#157983822">Patrick Massot (Feb 10 2019 at 17:38)</a>:</h4>
<p>Thank you for working on this. I'm not opposed to doing dimension one first. We will need specific statements for this case anyway, for teaching purposes, and because they have special notations. It would be a nice exercise to check that all proofs can be replaced by one-liners once we'll get the higher dimensional case. But I agree you should split this PR. You should also have a look at what <span class="user-mention" data-user-id="110865">@Jeremy Avigad</span>  did in order to handle punctured neighborhoods.</p>

<a name="157983841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/157983841" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#157983841">Patrick Massot (Feb 10 2019 at 17:39)</a>:</h4>
<p>I also think we should make more use of <a href="https://github.com/ImperialCollegeLondon/M1P1-lean/blob/master/src/limits.lean#L93-L94" target="_blank" title="https://github.com/ImperialCollegeLondon/M1P1-lean/blob/master/src/limits.lean#L93-L94">https://github.com/ImperialCollegeLondon/M1P1-lean/blob/master/src/limits.lean#L93-L94</a> in order to avoid splitting epsilons</p>

<a name="157986344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/157986344" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#157986344">Abhimanyu Pallavi Sudhir (Feb 10 2019 at 18:55)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="130500">@Abhimanyu Pallavi Sudhir</span> It's cool to see that people are working on Calculus!<br>
Experience has shown that it works best if you make lots of small PRs (&lt;200 lines). So I think you have more than enough for two or three meaningful PRs. Big mega-project PRs tend to rot away in the PR list.</p>
</blockquote>
<p>What should I have in my first calculus PR? Just the definitions of the derivative, or definitions with a few basic theorems? I'm not completely sure of how small PRs can be, especially when it comes to defining a whole new library.</p>

<a name="157986415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/157986415" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#157986415">Abhimanyu Pallavi Sudhir (Feb 10 2019 at 18:57)</a>:</h4>
<blockquote>
<p>I also think we should make more use of <a href="https://github.com/ImperialCollegeLondon/M1P1-lean/blob/master/src/limits.lean#L93-L94" target="_blank" title="https://github.com/ImperialCollegeLondon/M1P1-lean/blob/master/src/limits.lean#L93-L94">https://github.com/ImperialCollegeLondon/M1P1-lean/blob/master/src/limits.lean#L93-L94</a> in order to avoid splitting epsilons</p>
</blockquote>
<p>Yes -- "wlog epsilon &lt; A" is another one (or even just epsilon &lt; 1 will be useful wherever powers are involved). And some of my <code>abs</code> splitting, which I did based on intuition, can be done easily (and in a way that generalises) with the triangle inequality.</p>

<a name="157986617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/157986617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#157986617">Abhimanyu Pallavi Sudhir (Feb 10 2019 at 19:02)</a>:</h4>
<blockquote>
<p>...a look at what <span class="user-mention silent" data-user-id="110865">@Jeremy Avigad</span>  did in order to handle punctured neighborhoods.</p>
</blockquote>
<p>Do you have a link? Is this in mathlib?</p>

<a name="157988591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/157988591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#157988591">Patrick Massot (Feb 10 2019 at 19:54)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/cfd2b75e7a80462001fd1c2b835196b28dcd25c1/src/topology/basic.lean#L1750" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/cfd2b75e7a80462001fd1c2b835196b28dcd25c1/src/topology/basic.lean#L1750">https://github.com/leanprover-community/mathlib/blob/cfd2b75e7a80462001fd1c2b835196b28dcd25c1/src/topology/basic.lean#L1750</a></p>

<a name="157990080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/157990080" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#157990080">Jeremy Avigad (Feb 10 2019 at 20:36)</a>:</h4>
<p><span class="user-mention" data-user-id="130500">@Abhimanyu Pallavi Sudhir</span> , this is very nice! Coincidentally, I have just started formalizing the Frechet derivative. I put my current work in progress here:</p>
<p><a href="https://github.com/leanprover-community/mathlib/blob/multivariate/src/analysis/deriv.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/multivariate/src/analysis/deriv.lean">https://github.com/leanprover-community/mathlib/blob/multivariate/src/analysis/deriv.lean</a></p>
<p>The basic notion is <code>has_fderiv_at_within f f' x s</code>, which says that <code>f</code> has Frechet derivative <code>f'</code> at point <code>x</code>, where everything is relativized to the set <code>s</code>.</p>
<p>The approach is more general than yours, in two ways:<br>
- The Frechet derivative works on functions between arbitrary normed spaces.<br>
- Everything is relativized to a set <code>s</code>.</p>
<p>But I have not gotten nearly as far as you. (I am planning to do the chain rule next.) Can we somehow merge the two approaches?</p>
<p>In my experience, relativizing to a set is important. Sooner or later we will need the relativized versions. It is not too hard to do everything that way from the start, and, if we don't, there is no good way to fix it later without redoing everything.</p>
<p>Once we have the <code>at_within</code> notions, we can define</p>
<p><code>has_fderiv_at f f' x := has_fderiv_at_within f f' x univ</code><br>
<code>has_fderiv f f'</code> := forall x, has_fderiv_at f (f' x) x`</p>
<p>and so on. Note that we have similar notions for continuity, <code>continuous_at_within</code>, <code>continuous_at</code>, and <code>continuous</code>. </p>
<p>We can also define the univariate version,</p>
<p><code>has_deriv_at_within f y x s := has_fderiv_at_within f (λ x', y * x') x s</code>  </p>
<p>Regarding punctured neighborhoods, we can get this e.g. using <code>nhds_within x (λ x', x' ≠ x)</code>. But are you sure you need them? Note that, by convention, <code>x / 0 = 0</code>.</p>
<p>I suggest shortening <code>derivative</code> to <code>deriv</code>. That will save us a lot of typing. Also, the theorem names should approximate the statements as closely as possible, e.g. <code>has_deriv_at_within id 1 x s</code> should be named <code>has_deriv_id</code>. I took the liberty of dropping the <code>at_within</code> from the name. You can then apply <code>has_deriv_id</code> to a goal of the form <code>has_deriv_at id 1 x</code>.</p>
<p>I really like the fact that you have started computing concrete derivatives. That is really useful.</p>

<a name="157990318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/157990318" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#157990318">Jeremy Avigad (Feb 10 2019 at 20:43)</a>:</h4>
<p>Oh, also, in response to your PR: I think we should skip Riemann integration, and use the Lebesgue integral instead. Some people here at CMU might be willing to do the fundamental theorem of calculus, formalizing bounded variation and so on.</p>

<a name="157991154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/157991154" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#157991154">Kevin Buzzard (Feb 10 2019 at 21:06)</a>:</h4>
<p>Yes it's hard to imagine the Riemann integral having any use; the Lebesgue integral is I guess defined every time the Riemann integral is, and they agree on functions which are Riemann integrable. The only problem will be that nobody will be able to example sheet questions of the form "Show that the function which is 1 on rationals and 0 on irrationals is not Riemann integrable, but it is Lebesgue integrable" :-)</p>

<a name="157991287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/157991287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#157991287">Patrick Massot (Feb 10 2019 at 21:10)</a>:</h4>
<p>You can still define Riemann integrable without defining the Riemann integral, but I guess this is cheating</p>

<a name="157991366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/157991366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#157991366">Patrick Massot (Feb 10 2019 at 21:12)</a>:</h4>
<blockquote>
<p>The Frechet derivative. We use <code>fderiv</code> for the Frechet derivative, and <code>deriv</code> for the univariate one.</p>
</blockquote>
<p>This really feels wrong to me. I never ever use the word Fréchet (although I know how to write it...). It's the derivative.</p>

<a name="157991502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/157991502" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#157991502">Patrick Massot (Feb 10 2019 at 21:16)</a>:</h4>
<p>But thanks anyway! I can't wait to see the chain rule</p>

<a name="157992321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/157992321" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#157992321">Kevin Buzzard (Feb 10 2019 at 21:39)</a>:</h4>
<blockquote>
<p>This really feels wrong to me. I never ever use the word Fréchet (although I know how to write it...). It's the derivative.</p>
</blockquote>
<p>Ha ha we don't have that button :-)</p>

<a name="157992375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/157992375" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#157992375">Kevin Buzzard (Feb 10 2019 at 21:41)</a>:</h4>
<p>é = ctrl-shift u 00e9</p>

<a name="157996739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/157996739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#157996739">Jeremy Avigad (Feb 10 2019 at 23:53)</a>:</h4>
<p>But for ordinary calculus we want the derivative to be a number, not a linear function. What would you call that one?<br>
P.S. I am sorry for mangling Fréchet's name. Maybe his ghost will now come to haunt me.</p>

<a name="157997307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/157997307" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#157997307">Mario Carneiro (Feb 11 2019 at 00:08)</a>:</h4>
<p>I guess it's a property of one-dimensional derivatives? I would want it to be defined in whatever generality it can be, based on the Fréchet derivative, but I agree that <code>deriv1</code> is a bit noisy for general calculus usage.</p>

<a name="157999670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/157999670" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#157999670">François G. Dorais (Feb 11 2019 at 01:18)</a>:</h4>
<p>Mathematically, it's a conflation of a finite dimensional real vector space with its dual  (in this case dim=1, so it's hard to see at the outset). The problem is that it's not entirely canonical how to do this (whatever <a href="https://mathoverflow.net/questions/19644/what-is-the-definition-of-canonical" target="_blank" title="https://mathoverflow.net/questions/19644/what-is-the-definition-of-canonical">canonical means</a>). Lean doesn't know about canonical in the mathematical sense and rightfully so! So you do need both and, more importantly, explain their equivalence.</p>

<a name="157999914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/157999914" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#157999914">Mario Carneiro (Feb 11 2019 at 01:27)</a>:</h4>
<p>That suggests that you can do this even in the N -&gt; 1 dimensional case, where the output is then an element of an n-dimensional vector space?</p>

<a name="157999915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/157999915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#157999915">Mario Carneiro (Feb 11 2019 at 01:27)</a>:</h4>
<p>As long as it's an inner product space you can define this map via the dot product</p>

<a name="157999970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/157999970" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#157999970">Reid Barton (Feb 11 2019 at 01:29)</a>:</h4>
<p>When the domain is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="double-struck">R</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68889em;"></span><span class="strut bottom" style="height:0.68889em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> then you can canonically identify <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow><mi mathvariant="normal">H</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><mrow><mi mathvariant="double-struck">R</mi></mrow></msub><mo>(</mo><mrow><mi mathvariant="double-struck">R</mi></mrow><mo separator="true">,</mo><mi>V</mi><mo>)</mo><mo>=</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\mathrm{Hom}_{\mathbb{R}}(\mathbb{R}, V) = V</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathrm">H</span><span class="mord mathrm">o</span><span class="mord mathrm">m</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33222299999999994em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathbb mtight">R</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathbb">R</span></span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.22222em;">V</span></span></span></span> for any <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">V</span></span></span></span></p>

<a name="158000016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000016" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000016">Mario Carneiro (Feb 11 2019 at 01:30)</a>:</h4>
<p>That generalizes to any field, yes?</p>

<a name="158000075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000075" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000075">Reid Barton (Feb 11 2019 at 01:32)</a>:</h4>
<p>Right, but in this context I guess only <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="double-struck">R</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68889em;"></span><span class="strut bottom" style="height:0.68889em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> is relevant (or <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="double-struck">C</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68889em;"></span><span class="strut bottom" style="height:0.68889em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathbb">C</span></span></span></span></span> for complex analytic functions)</p>

<a name="158000084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000084" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000084">Mario Carneiro (Feb 11 2019 at 01:32)</a>:</h4>
<p>sure, I'm just trying to figure out what is necessary to define this thing</p>

<a name="158000094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000094">Mario Carneiro (Feb 11 2019 at 01:33)</a>:</h4>
<p>Does it work when the domain is a field other than the base field?</p>

<a name="158000154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000154" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000154">Mario Carneiro (Feb 11 2019 at 01:35)</a>:</h4>
<p>No, there are discontinuous linear maps in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><mrow><mi mathvariant="double-struck">Q</mi></mrow></msub><mo>(</mo><mrow><mi mathvariant="double-struck">R</mi></mrow><mo separator="true">,</mo><mrow><mi mathvariant="double-struck">R</mi></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathrm{End}_{\mathbb{Q}}(\mathbb{R}, \mathbb{R})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.016669em;vertical-align:-0.266669em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathrm">E</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.332223em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathbb mtight">Q</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266669em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathbb">R</span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathbb">R</span></span><span class="mclose">)</span></span></span></span></p>

<a name="158000207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000207" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000207">Mario Carneiro (Feb 11 2019 at 01:36)</a>:</h4>
<p>oh but I guess these can't come out of a derivative calculation, which uses bounded linear maps</p>

<a name="158000257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000257" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000257">François G. Dorais (Feb 11 2019 at 01:38)</a>:</h4>
<p>The key is _finite_ dimensional.</p>

<a name="158000270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000270">François G. Dorais (Feb 11 2019 at 01:38)</a>:</h4>
<p>(Finite is still hard for lean.)</p>

<a name="158000379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000379">Kenny Lau (Feb 11 2019 at 01:42)</a>:</h4>
<p><a href="/user_uploads/3121/Tyh8153oL73QXAoGkvU8QU0u/icfh0gv5ipu01.jpg" target="_blank" title="icfh0gv5ipu01.jpg">icfh0gv5ipu01.jpg</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/Tyh8153oL73QXAoGkvU8QU0u/icfh0gv5ipu01.jpg" target="_blank" title="icfh0gv5ipu01.jpg"><img src="/user_uploads/3121/Tyh8153oL73QXAoGkvU8QU0u/icfh0gv5ipu01.jpg"></a></div>

<a name="158000390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000390" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000390">Mario Carneiro (Feb 11 2019 at 01:43)</a>:</h4>
<p>The finite dimensionality thing doesn't seem to matter so much, since in all the contexts that matter we have more structure than this anyway</p>

<a name="158000394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000394" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000394">Mario Carneiro (Feb 11 2019 at 01:43)</a>:</h4>
<p>i.e. an inner product structure gives a canonical way to pass to the dual</p>

<a name="158000443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000443" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000443">Mario Carneiro (Feb 11 2019 at 01:44)</a>:</h4>
<p>Also in infinite dimensional spaces we only care about continuous linear maps, doesn't this give you more? (I recall the Riesz representation theorem in this context.)</p>

<a name="158000444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000444" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000444">François G. Dorais (Feb 11 2019 at 01:44)</a>:</h4>
<p>The alternative key is Hilbert, which requires completeness and brings you down to R and C.</p>

<a name="158000523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000523">François G. Dorais (Feb 11 2019 at 01:47)</a>:</h4>
<p>Riesz representation gets you to another space, which is isomorphic to the dual but different. The whole self duality idea gets into pretty deep functional analysis territory.</p>

<a name="158000656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000656">Reid Barton (Feb 11 2019 at 01:51)</a>:</h4>
<p>I thought the original claim was about functions <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mi mathvariant="double-struck">R</mi></mrow><mo>→</mo><mrow><mi mathvariant="double-struck">R</mi></mrow></mrow><annotation encoding="application/x-tex">f : \mathbb{R} \to \mathbb{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mrel">:</span><span class="mord"><span class="mord mathbb">R</span></span><span class="mrel">→</span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span>--my point was that in this case, the identification of the derivative (thought of as a linear map) with a real number is totally canonical--and the same holds for any codomain</p>

<a name="158000728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000728" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000728">Mario Carneiro (Feb 11 2019 at 01:52)</a>:</h4>
<p>Okay, so let me make this more concrete: suppose I have the space <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><mi>F</mi></msub><mo>(</mo><mi>F</mi><mo separator="true">,</mo><mi>V</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathrm{End}_F(F,V)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathrm">E</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span> of continuous linear maps from a field <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">V</span></span></span></span>. I can define <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi><mo>:</mo><msub><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><mi>F</mi></msub><mo>(</mo><mi>F</mi><mo separator="true">,</mo><mi>V</mi><mo>)</mo><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\phi:\mathrm{End}_F(F,V)\to V</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">ϕ</span><span class="mrel">:</span><span class="mord"><span class="mord"><span class="mord mathrm">E</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.22222em;">V</span></span></span></span> by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi><mo>(</mo><mi>f</mi><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\phi(f)=f(1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">ϕ</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ψ</mi><mo>:</mo><mi>V</mi><mo>→</mo><msub><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><mi>F</mi></msub><mo>(</mo><mi>F</mi><mo separator="true">,</mo><mi>V</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\psi:V\to\mathrm{End}_F(F,V)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">ψ</span><span class="mrel">:</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mrel">→</span><span class="mord"><span class="mord"><span class="mord mathrm">E</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span> by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ψ</mi><mo>(</mo><mi>v</mi><mo>)</mo><mo>(</mo><mi>a</mi><mo>)</mo><mo>=</mo><mi>a</mi><mo>⋅</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">\psi(v)(a)=a\cdot v</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit">a</span><span class="mbin">⋅</span><span class="mord mathit" style="margin-right:0.03588em;">v</span></span></span></span>. Is this always a bijection?</p>

<a name="158000740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000740" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000740">Mario Carneiro (Feb 11 2019 at 01:53)</a>:</h4>
<p>This looks like the natural "trivial generalization" of the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="double-struck">R</mi></mrow><mo>→</mo><mrow><mi mathvariant="double-struck">R</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbb{R}\to\mathbb{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68889em;"></span><span class="strut bottom" style="height:0.68889em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathbb">R</span></span><span class="mrel">→</span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> case</p>

<a name="158000782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000782">Reid Barton (Feb 11 2019 at 01:54)</a>:</h4>
<p>yes, exactly (one direction is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>⋅</mo><mi>v</mi><mo>=</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">1 \cdot v = v</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base"><span class="mord mathrm">1</span><span class="mbin">⋅</span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03588em;">v</span></span></span></span>, and the other direction is the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span>-linearity of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>)</p>

<a name="158000784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000784" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000784">François G. Dorais (Feb 11 2019 at 01:54)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> It is canonical only if you remember to send 1 to 1, but that's not necessary for the whole thing to work so long as you keep track that 1 sends to multiplication  by _ (nonzero).</p>

<a name="158000785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000785">Reid Barton (Feb 11 2019 at 01:54)</a>:</h4>
<p>also <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span> doesn't need to be a field</p>

<a name="158000795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000795" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000795">Mario Carneiro (Feb 11 2019 at 01:55)</a>:</h4>
<p>If <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">V</span></span></span></span> is a vector space, shouldn't the base ring be a field?</p>

<a name="158000797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000797">Mario Carneiro (Feb 11 2019 at 01:55)</a>:</h4>
<p>I guess this generalizes to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><mi>R</mi></msub><mo>(</mo><mi>R</mi><mo separator="true">,</mo><mi>M</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathrm{End}_R(R,M)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathrm">E</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span> over modules</p>

<a name="158000865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000865">Mario Carneiro (Feb 11 2019 at 01:57)</a>:</h4>
<p><span class="user-mention" data-user-id="119741">@François G. Dorais</span> It's true that there are other maps like this between fdvs's, but the ring structure is what gives this construction "canonicality" since we have a canonical nonzero</p>

<a name="158000984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158000984" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158000984">Mario Carneiro (Feb 11 2019 at 02:01)</a>:</h4>
<p>If the two fields are not the same, i.e. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><mi>E</mi></msub><mo>(</mo><mi>F</mi><mo separator="true">,</mo><mi>V</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathrm{End}_E(F,V)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathrm">E</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05764em;">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span>, I don't think this works unless <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">E</span></span></span></span> is dense in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span>, so that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\psi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">ψ</span></span></span></span> can be defined by continuous extension</p>

<a name="158001029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158001029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158001029">Mario Carneiro (Feb 11 2019 at 02:02)</a>:</h4>
<p>and then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">V</span></span></span></span> needs some completeness too</p>

<a name="158013462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%23711%20Calculus/near/158013462" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/47033711Calculus.html#158013462">Patrick Massot (Feb 11 2019 at 07:58)</a>:</h4>
<p><span class="user-mention" data-user-id="119741">@François G. Dorais</span> this is one of the cases where "canonical" is perfectly well-defined by category theory.</p>


{% endraw %}
