---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/144837PRreviews/035751295archive.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/144837PRreviews/index.html">PR reviews</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html">#1295 archive</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="172386562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/172386562" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#172386562">Floris van Doorn (Aug 03 2019 at 02:06)</a>:</h4>
<p>In <a href="https://github.com/leanprover-community/mathlib/issues/1295" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/1295">#1295</a> I added a folder where we can put one-off formalization projects. I called it <code>archive/</code>, following the archive of formal proofs. If this gets accepted, it would be nice to get <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> and/or <span class="user-mention" data-user-id="110032">@Reid Barton</span>'s formalization of IMO 2019-1, and <span class="user-mention" data-user-id="110865">@Jeremy Avigad</span>'s formalization of the mutilated checkerboard. And of course for all other projects which I don't know on the top of my head.</p>

<a name="172386794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/172386794" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#172386794">Floris van Doorn (Aug 03 2019 at 02:14)</a>:</h4>
<p>We can probably add more information to the README, but we should first make some organizational decisions:</p>
<ul>
<li>Do we want to have a size limit? I would say we shouldn't put the perfectoid space project in here. I'm also don't think we want to have things like Flypitch in here (but maybe some of the basic logic files are fine?). Something with the size of the cap set problem (2k-3k LOC) should be fine though (although presumably <span class="user-mention" data-user-id="110596">@Rob Lewis</span> wants that in its own repository)</li>
<li>We might want to specifically say that we don't want anything that is under active development?</li>
</ul>
<p>What else should be added to the README?</p>

<a name="172387180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/172387180" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#172387180">Scott Morrison (Aug 03 2019 at 02:27)</a>:</h4>
<p>Can we also have a requirement that all general use lemmas have already been factored into <code>src/</code>? We really don't want this to be a "shortcut", that results in people not putting in the effort to polish up generally useful material for wide consumption.</p>

<a name="172387197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/172387197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#172387197">Floris van Doorn (Aug 03 2019 at 02:28)</a>:</h4>
<p>Yes, I added that to the README:</p>
<blockquote>
<p>When you make a pull request, do make sure that you put all lemmas which should be in mathlib in the right place (in mathlib).</p>
</blockquote>

<a name="172387416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/172387416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#172387416">Floris van Doorn (Aug 03 2019 at 02:35)</a>:</h4>
<p>Now reformulated to</p>
<blockquote>
<p>When you make a pull request, do make sure that you put all lemmas which are generally useful in right place in mathlib (in the <code>src/</code> directory).</p>
</blockquote>

<a name="172390291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/172390291" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#172390291">Johan Commelin (Aug 03 2019 at 04:13)</a>:</h4>
<p>I think it is fine to put the perfectoid project there. It just means that its folder will be empty because 100% of it is generally useful and belongs in mathlib...</p>

<a name="172391006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/172391006" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#172391006">Johan Commelin (Aug 03 2019 at 04:38)</a>:</h4>
<p>When we run <code>leanpkg build</code> locally, will that only compile <code>src/</code> or also <code>archive/</code>?</p>

<a name="172391012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/172391012" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#172391012">Johan Commelin (Aug 03 2019 at 04:38)</a>:</h4>
<p>Because I fear that we will get lots of confusion if the local build passes, but it turns out it didn't test <code>archive/</code></p>

<a name="172392357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/172392357" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#172392357">Floris van Doorn (Aug 03 2019 at 05:27)</a>:</h4>
<p><code>leanpkg build</code> will only compile <code>src/</code>.</p>
<blockquote>
<p>Because I fear that we will get lots of confusion if the local build passes, but it turns out it didn't test archive/</p>
</blockquote>
<p>If you run <code>leanpkg build</code> you are currently already building less than Travis, since Travis runs <code>leanpkg test</code>, which also builds the test folder.</p>

<a name="172392807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/172392807" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#172392807">Johan Commelin (Aug 03 2019 at 05:43)</a>:</h4>
<p>Sure, but I guess that will cause less confusion</p>

<a name="172392809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/172392809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#172392809">Johan Commelin (Aug 03 2019 at 05:43)</a>:</h4>
<p>The test are less likely to break</p>

<a name="172414742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/172414742" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#172414742">Simon Hudon (Aug 03 2019 at 17:39)</a>:</h4>
<p>Any chance we could put <code>archive</code> under <code>test</code>?</p>

<a name="172623314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/172623314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#172623314">Floris van Doorn (Aug 06 2019 at 19:58)</a>:</h4>
<blockquote>
<p>Any chance we could put <code>archive</code> under <code>test</code>?</p>
</blockquote>
<p>It feels a bit out of place to me, but if people feel strongly about <code>leanpkg test</code> also compiling the archive, I can move <code>archive</code> there.</p>

<a name="172623345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/172623345" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#172623345">Johan Commelin (Aug 06 2019 at 19:58)</a>:</h4>
<p>I agree. I think <code>archive</code> and <code>test</code> serve very different purposes.</p>

<a name="172626359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/172626359" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#172626359">Simon Hudon (Aug 06 2019 at 20:39)</a>:</h4>
<p>Alternatively, we can add a bash script <code>build_all</code> to build the library, the tests and the archive</p>

<a name="173784224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/173784224" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#173784224">Patrick Massot (Aug 21 2019 at 11:21)</a>:</h4>
<p>As an extra data point about this archive idea, as well as automation vs maintainability: I'm back to my office, trying to catch up with things, and I just tried to open <span class="user-mention" data-user-id="110865">@Jeremy Avigad</span> <a href="https://gist.github.com/avigad/1080e327ad6806884c9c5091f5c449bd" target="_blank" title="https://gist.github.com/avigad/1080e327ad6806884c9c5091f5c449bd">https://gist.github.com/avigad/1080e327ad6806884c9c5091f5c449bd</a>. And it doesn't compile with current mathlib (lean-3.4.2 branch). Of course the issue is <code>simp</code> invocations.</p>

<a name="173784335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/173784335" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#173784335">Patrick Massot (Aug 21 2019 at 11:22)</a>:</h4>
<p>I also noticed <a href="http://www.andrew.cmu.edu/user/avigad/Papers/mutilated.pdf" target="_blank" title="http://www.andrew.cmu.edu/user/avigad/Papers/mutilated.pdf">www.andrew.cmu.edu/user/avigad/Papers/mutilated.pdf</a> suffers from the usual Lean + LaTeX glitches (see the place of the reverse rewrite arrow on line 144 in the pdf).</p>

<a name="173784358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/173784358" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#173784358">Patrick Massot (Aug 21 2019 at 11:23)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Do you remember how we solved that arrow issue in your LMS paper?</p>

<a name="173784437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/173784437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#173784437">Patrick Massot (Aug 21 2019 at 11:24)</a>:</h4>
<p>Jeremy: in <a href="https://gist.github.com/avigad/1080e327ad6806884c9c5091f5c449bd#file-mutilated-lean-L134" target="_blank" title="https://gist.github.com/avigad/1080e327ad6806884c9c5091f5c449bd#file-mutilated-lean-L134">https://gist.github.com/avigad/1080e327ad6806884c9c5091f5c449bd#file-mutilated-lean-L134</a> you should learn about <code>conv_lhs</code> which is a convenient little shortcut</p>

<a name="173784796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/173784796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#173784796">Kevin Buzzard (Aug 21 2019 at 11:31)</a>:</h4>
<p>We solved it by <span class="user-mention" data-user-id="110596">@Rob Lewis</span> saying "which version of the Lean LaTeX thing we you using? The publicly available one in the GitHub repo? Don't use that, use this one which is much newer and circulates informally"</p>

<a name="173804560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/173804560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#173804560">Jeremy Avigad (Aug 21 2019 at 15:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> Thanks for this information and for the tip. I am traveling now but I'll update the notes and the proof soon and add it to the archive folder.<br>
Regarding maintainability of proofs that use automation: Isabelle's library provides strong empirical evidence that it can be done. The library is hundreds of thousands of lines long, and automation is used everywhere. Moreover, the archive of formal proofs has over 2.2 million lines. <br>
This is not to say that automation doesn't raise maintainability issues or introduce tradeoffs, but we should take the Isabelle experience into account.</p>

<a name="173805436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/173805436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#173805436">Reid Barton (Aug 21 2019 at 15:35)</a>:</h4>
<p>Isabelle favors a very <code>have</code>-heavy proof style, right?</p>

<a name="173805554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/173805554" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#173805554">Jeremy Avigad (Aug 21 2019 at 15:36)</a>:</h4>
<p>P.S. I just found this very nice talk by Larry Paulson: <br>
<a href="http://cpp2017.mpi-sws.org/Paulson.pdf" target="_blank" title="http://cpp2017.mpi-sws.org/Paulson.pdf">http://cpp2017.mpi-sws.org/Paulson.pdf</a><br>
It makes a good case that structured proofs with automation are more useful (and maybe even maintainable?) than unreadable tactic proofs.</p>

<a name="173805863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/173805863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#173805863">Rob Lewis (Aug 21 2019 at 15:40)</a>:</h4>
<p>I think the issue here is that the proofs in the mutilated chessboard proof aren't structured for automation. I see a bunch of nonterminal simp calls, which are very hard to maintain.</p>

<a name="173805947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/173805947" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#173805947">Rob Lewis (Aug 21 2019 at 15:41)</a>:</h4>
<p>(At least, they look nonterminal at a glance. I didn't open the file in VSCode.)</p>

<a name="173807530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/173807530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#173807530">Patrick Massot (Aug 21 2019 at 15:58)</a>:</h4>
<p>Rob, I guess that's exactly what broke but, in order to check, I would need to find the version of mathlib that used to make this code to work. Indeed in a proof like <code>by { simp, rw [...], simp }</code> that no longer succeeds, I have to way to tell whether the first of second (or both) simp do something different than what they used to do.</p>

<a name="173807603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/173807603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#173807603">Patrick Massot (Aug 21 2019 at 15:59)</a>:</h4>
<p>And I also love the structured proof style. The reason we can't have quite it in Lean is poor automation.</p>

<a name="173815422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/173815422" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#173815422">Jeremy Avigad (Aug 21 2019 at 17:33)</a>:</h4>
<p>O.k., you have shamed me into fixing the problem. The gist should now work with today's <code>mathlib</code>. In fact, deleting a single character fixed the problem: I had stated an auxiliary simplification lemma in terms of a value cast from <code>pnat</code>, but with a recent change,  the simplifier reduced it to a <code>nat</code>.</p>
<p>In my defense, most of the nonterminal <code>simp</code>s are things that automation should have gotten. <code>finish</code> gets one of them but freezes on some others. The instance of <code>simp; rw [foo]; simp</code> should have been <code>simp [foo]</code> but for some reason, <code>simp</code> couldn't match <code>foo</code> and <code>rw</code> could. </p>
<p>Oh, and I used one instance of <code>simp, show ...</code>. It could easily be rewritten to a <code>suffices</code> followed by a terminal <code>simp</code>, but rewriting the proof this way makes it less natural. (I guess I am arguing that <code>simp, show ...</code> should count as a terminal <code>simp</code>).</p>

<a name="173866725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/173866725" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#173866725">Patrick Massot (Aug 22 2019 at 09:36)</a>:</h4>
<blockquote>
<p>O.k., you have shamed me into fixing the problem. The gist should now work with today's <code>mathlib</code>. In fact, deleting a single character fixed the problem: I had stated an auxiliary simplification lemma in terms of a value cast from <code>pnat</code>, but with a recent change,  the simplifier reduced it to a <code>nat</code>.</p>
</blockquote>
<p>I hope it's clear the goal was not to shame anyone. I understand very well that all this only proves how far we have from the level of automation we'd like to have. I just spent a bit of time looking for obvious optimization of the proofs. First I think you could argue that mathlib misses the following general lemma:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">add_ne</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">a</span><span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="n">h</span> <span class="err">$</span> <span class="n">add_left_cancel</span> <span class="o">(</span><span class="k">show</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_zero</span><span class="o">,</span> <span class="n">h&#39;</span><span class="o">])</span>
</pre></div>


<p>Something funny with this lemma is that you also need (in the very last proof):</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_ne</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">a</span><span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="n">h</span> <span class="err">$</span> <span class="n">add_left_cancel</span> <span class="o">(</span><span class="k">show</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_zero</span><span class="o">,</span> <span class="n">h&#39;</span><span class="o">])</span>
</pre></div>


<p>Note how the proof is exactly the same sequence of letters. Yet I can't find a combination of type classes that covers both. It's probably my lack of proper understanding of semi-cancellative almost distributive mononoids with zero. Of course with a powerful programming language with duck typing we could just write the proof and get it checked at runtime...</p>
<p>Then I don't understand why some people make such a fuss about decidability instances and computability and still there are so many steps that should be <code>dec_trivial</code> but aren't. Some of them still are. For instance, in the main part of <code>card_mutilated_inter_black_squares</code>, when proving <code>¬7 = 0</code> you can replace <code>intro h, have := congr_arg fin.val h, contradiction</code> by <code>exact dec_trivial</code>. </p>
<p>In <code>card_bind_squares_inter_white_squares</code> I don't know the point of this <code>swap</code> dance. Why not writing:</p>
<div class="codehilite"><pre><span></span><span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">bind_inter</span><span class="o">,</span> <span class="n">card_bind</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">card_squares_inter_white_squares</span><span class="o">,</span> <span class="n">card_squares_inter_black_squares</span><span class="o">],</span>
  <span class="n">all_goals</span> <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">inter_right_comm</span><span class="o">,</span> <span class="err">←</span><span class="n">inter_assoc</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span> <span class="bp">;</span> <span class="n">tauto</span> <span class="o">},</span>
</pre></div>


<p>since the proof is unreadable anyway? By the way, is this last goal (solved by the last <code>{...}</code> something Isabelle automation would do?</p>

<a name="173884808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/173884808" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#173884808">Jesse Michael Han (Aug 22 2019 at 13:58)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_ne</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">a</span><span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="n">h</span> <span class="err">$</span> <span class="n">add_left_cancel</span> <span class="o">(</span><span class="k">show</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_zero</span><span class="o">,</span> <span class="n">h&#39;</span><span class="o">])</span>
</pre></div>


<p>this is the contrapositive of something which is <code>by linarith</code> (probably overkill)</p>

<a name="173902974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/173902974" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#173902974">Jeremy Avigad (Aug 22 2019 at 17:28)</a>:</h4>
<p>Thanks for the suggestions -- I'll incorporate them. I am meeting with Seul now, but for the record, here is a nice Isabelle formalization:<br>
<a href="https://github.com/avigad/arwm/blob/master/isabelle_experiments/mutilated.thy" target="_blank" title="https://github.com/avigad/arwm/blob/master/isabelle_experiments/mutilated.thy">https://github.com/avigad/arwm/blob/master/isabelle_experiments/mutilated.thy</a><br>
<a href="https://github.com/avigad/arwm/blob/master/isabelle_experiments/mutilated.pdf" target="_blank" title="https://github.com/avigad/arwm/blob/master/isabelle_experiments/mutilated.pdf">https://github.com/avigad/arwm/blob/master/isabelle_experiments/mutilated.pdf</a><br>
After the definitions, the proof is about 50 lines, as compared to about 110 in the Lean file.</p>

<a name="174037353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/174037353" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#174037353">Jeremy Avigad (Aug 24 2019 at 12:31)</a>:</h4>
<p>Since I have been obsessed with automation that last few weeks, yesterday I formalized an elementary proof of the IVT in Isabelle as well. <br>
<a href="https://github.com/avigad/arwm/blob/master/isabelle_experiments/ivt.pdf" target="_blank" title="https://github.com/avigad/arwm/blob/master/isabelle_experiments/ivt.pdf">https://github.com/avigad/arwm/blob/master/isabelle_experiments/ivt.pdf</a><br>
All the experiments, with notes, are here:<br>
<a href="https://github.com/avigad/arwm/tree/master/isabelle_experiments" target="_blank" title="https://github.com/avigad/arwm/tree/master/isabelle_experiments">https://github.com/avigad/arwm/tree/master/isabelle_experiments</a></p>

<a name="174048694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/174048694" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#174048694">Johan Commelin (Aug 24 2019 at 18:04)</a>:</h4>
<blockquote>
<p>P.S. I just found this very nice talk by Larry Paulson: <br>
<a href="http://cpp2017.mpi-sws.org/Paulson.pdf" target="_blank" title="http://cpp2017.mpi-sws.org/Paulson.pdf">http://cpp2017.mpi-sws.org/Paulson.pdf</a><br>
It makes a good case that structured proofs with automation are more useful (and maybe even maintainable?) than unreadable tactic proofs.</p>
</blockquote>
<p>In these slides I learned that HOL Light grows with some 3000 lines per month. Github just told me that in the last month mathlib grew with &gt;6000 lines. Is HOL terser, or are we growing faster?</p>

<a name="174050031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/174050031" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#174050031">Mario Carneiro (Aug 24 2019 at 18:42)</a>:</h4>
<p>Keep in mind that HOL light is almost completely one man's work</p>

<a name="174050454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/174050454" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#174050454">Patrick Massot (Aug 24 2019 at 18:55)</a>:</h4>
<p>This is not a line number competition anyway...</p>

<a name="174051595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/174051595" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#174051595">Johan Commelin (Aug 24 2019 at 19:30)</a>:</h4>
<p><span class="user-mention" data-user-id="110865">@Jeremy Avigad</span> Somewhere you wrote that you are interested in a "log of the proof discovery" (my words) and not so much the polished end-result. I've no idea how hard it is to tweak VScode, but I guess it could record Lean sessions for us. Of course you don't want to watch hours and hours of us struggling with natural number subtraction. But the logs of those sessions could potentially be analyzed by a machine. And it might give even more insight than non-polished end-results. (After all, a non-polished end-result still doesn't capture my backspaces, etc...)</p>

<a name="174055736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR%20reviews/topic/%231295%20archive/near/174055736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/144837PRreviews/035751295archive.html#174055736">Jeremy Avigad (Aug 24 2019 at 21:45)</a>:</h4>
<p>My concern was that people developing automated tools should have a realistic picture of how the tools are used and where they succeed and where they fail. The most common method of evaluation is to take an existing library, delete the proofs, and try to fill them in again automatically. There are various ways that might skew the data. For example, the existing libraries already reflect all the things we did to make the proofs work, like rewrite definitions and add supporting lemmas. It is not an indication of what we wanted to do in the first place. And it is likely that automation is succeeding on the easy tasks, not the ones where we really want the help.</p>
<p>Automatically harvesting data is a nice idea. I don't have a good sense what machine learning techniques can or cannot do, and what might work there.</p>
<p>But I think even anecdotal examples can be helpful. Experiment with an existing tool, figure out what it can and cannot do, and document the successes and failures. The reason Isabelle's automation is so good is that formalizers and tool developers worked together, and often were even the same person. So the tool developers had a clear picture what the were trying to achieve. From the few examples I have done, I am at least getting a better sense of where Sledgehammer has trouble. I'll do my best to summarize what I have learned in the talk I am preparing.</p>
<p>There is the added complication that computer scientists don't get a lot of credit for helping mathematicians. They are generally expected to support their students, and it is easier to get funded if they are verifying compilers or network security protocols or airplane control systems. But we can be grateful for the fact that there are people in CS interested in mathematical reasoning, and the least we can do is help supply them with data and examples.</p>


{% endraw %}

{% include archive_update.html %}