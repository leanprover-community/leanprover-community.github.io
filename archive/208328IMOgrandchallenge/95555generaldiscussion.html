---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/208328IMOgrandchallenge/95555generaldiscussion.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/index.html">IMO-grand-challenge</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html">general discussion</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="177153047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177153047" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177153047">Miroslav Olšák (Oct 02 2019 at 14:07)</a>:</h4>
<ol>
<li>Problems of the "find / determine" type<br>
I have collected the answers of the problems of this type from all the shortlists available on the official IMO website for a general idea how the answers can look like.<br>
<a href="http://www.olsak.net/mirek/determine-answers.txt" target="_blank" title="http://www.olsak.net/mirek/determine-answers.txt">http://www.olsak.net/mirek/determine-answers.txt</a></li>
</ol>

<a name="177153084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177153084" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177153084">Miroslav Olšák (Oct 02 2019 at 14:07)</a>:</h4>
<ol start="3">
<li>Other domains.<br>
It is well known that IMO problems are of four categories: "Geometry / Algebra / Number Theory / Combinatorics" (a friend of mine once came with a nice comparison to "Imagination / Computation / Knowledge / Thinking" :-) ). The problem statements are relatively monotonous inside a single domain unless there is a combinatorial flavour. The most difficult problems from both formalisation perspective and the problem solving perspective are imho problems from Combinatorial Geometry. I am for example curious about the formalisation of the windmill problem (2011-2, <a href="https://www.youtube.com/watch?v=M64HUIJFTZM" target="_blank" title="https://www.youtube.com/watch?v=M64HUIJFTZM">https://www.youtube.com/watch?v=M64HUIJFTZM</a>).</li>
</ol>
<div class="youtube-video message_inline_image"><a data-id="M64HUIJFTZM" href="https://www.youtube.com/watch?v=M64HUIJFTZM" target="_blank" title="https://www.youtube.com/watch?v=M64HUIJFTZM"><img src="https://i.ytimg.com/vi/M64HUIJFTZM/default.jpg"></a></div>

<a name="177153162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177153162" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177153162">Miroslav Olšák (Oct 02 2019 at 14:08)</a>:</h4>
<ol start="5">
<li>Partial points<br>
Some of the IMO problems are actually multiple (two) independent tasks, for example 2016-6 (= C7). Whether to allow partial points in such cases is worth consideration.</li>
</ol>

<a name="177243163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177243163" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177243163">Daniel Selsam (Oct 03 2019 at 13:22)</a>:</h4>
<blockquote>
<p>I am for example curious about the formalisation of the windmill problem (2011-2, <a href="https://www.youtube.com/watch?v=M64HUIJFTZM" target="_blank" title="https://www.youtube.com/watch?v=M64HUIJFTZM">https://www.youtube.com/watch?v=M64HUIJFTZM</a>).</p>
</blockquote>
<p><span class="user-mention" data-user-id="133339">@Miroslav Olšák</span> For the windmill problem, are you concerned about formalizing the statement, finding a solution, or formalizing a solution?</p>

<a name="177243625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177243625" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177243625">Daniel Selsam (Oct 03 2019 at 13:27)</a>:</h4>
<blockquote>
<p>Are we interested in formalizing olympiad-like mathematical puzzles not necessarily coming from IMO?</p>
</blockquote>
<p><span class="user-mention" data-user-id="133339">@Miroslav Olšák</span> There are many sources of problems that I think would provide valuable data for IMO, e.g. problems from national Olympiads. It is hard to say without knowing more whether your folklore list is worth the trouble of you translating it to English.</p>

<a name="177244300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177244300" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177244300">Daniel Selsam (Oct 03 2019 at 13:34)</a>:</h4>
<blockquote>
<ol start="5">
<li>Partial points<br>
Some of the IMO problems are actually multiple (two) independent tasks, for example 2016-6 (= C7). Whether to allow partial points in such cases is worth consideration.</li>
</ol>
</blockquote>
<p><span class="user-mention" data-user-id="133339">@Miroslav Olšák</span> I agree. Unfortunately, I don't see any official statement concerning the number of points for solving sub-problems of problems. One option is to say "partial credit will be given for fully formalized sub-problems according to the number of points human judges would have awarded for the same sub-problems". What do you think?</p>

<a name="177244510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177244510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177244510">Daniel Selsam (Oct 03 2019 at 13:37)</a>:</h4>
<blockquote>
<p>Because of that, I am now focused mainly on geometry, and I have translated the officialy available shortlists to a semi-formal language (parseable but without detailed semantics and not in any particular therem prover so far). So I could help a bit with this part.</p>
</blockquote>
<p><span class="user-mention" data-user-id="133339">@Miroslav Olšák</span> Nice! Can you share one example to give us a sense of the semi-formal language?</p>

<a name="177244913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177244913" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177244913">Daniel Selsam (Oct 03 2019 at 13:41)</a>:</h4>
<blockquote>
<ol>
<li>Problems of the "find / determine" type<br>
I have collected the answers of the problems of this type from all the shortlists available on the official IMO website for a general idea how the answers can look like.<br>
<a href="http://atrey.karlin.mff.cuni.cz/~mirecek/determine-answers.txt" target="_blank" title="http://atrey.karlin.mff.cuni.cz/~mirecek/determine-answers.txt">http://atrey.karlin.mff.cuni.cz/~mirecek/determine-answers.txt</a></li>
</ol>
</blockquote>
<p><span class="user-mention" data-user-id="133339">@Miroslav Olšák</span> Nice! What do you think about the current plan, of requiring human-assessment of the witnesses and only accepting witnesses that human judges would have accepted? See <a href="https://github.com/IMO-grand-challenge/formal-encoding/blob/master/design/determine.lean" target="_blank" title="https://github.com/IMO-grand-challenge/formal-encoding/blob/master/design/determine.lean">https://github.com/IMO-grand-challenge/formal-encoding/blob/master/design/determine.lean</a> for more context.</p>

<a name="177244984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177244984" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177244984">Miroslav Olšák (Oct 03 2019 at 13:42)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="133339">Miroslav Olšák</span> For the windmill problem, are you concerned about formalizing the statement, finding a solution, or formalizing a solution?</p>
</blockquote>
<p>I am not concerned that formalizing the problem statement, or formalizing the solution would be impossible, I just find it somewhat challenging, so I would like to see it. Of course, if an automated system (not designed for solving this particular problem) could find a solution of it, I would be super-impressed. However, I feel the following issue of the formalization of the problem statement. There are some facts about the problem that are so obvious (but really nontrivial to formally proof) that it is unclear whether they are actually a part of the problem statement, or a part of the solution. I mean for example "given any initial line, there is exactly one windmill process".</p>

<a name="177245552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177245552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177245552">Miroslav Olšák (Oct 03 2019 at 13:48)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="133339">Miroslav Olšák</span> I agree. Unfortunately, I don't see any official statement concerning the number of points for solving sub-problems of problems. One option is to say "partial credit will be given for fully formalized sub-problems according to the number of points human judges would have awarded for the same sub-problems". What do you think?</p>
</blockquote>
<p>It makes sense. Note that although there is no public document for the IMO marking scheme, the judges prepare it and agree on the marking scheme before checking the solutions.</p>

<a name="177248253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177248253" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177248253">Daniel Selsam (Oct 03 2019 at 14:14)</a>:</h4>
<blockquote>
<p>However, I feel the following issue of the formalization of the problem statement. There are some facts about the problem that are so obvious (but really nontrivial to formally proof) that it is unclear whether they are actually a part of the problem statement, or a part of the solution. I mean for example "given any initial line, there is exactly one windmill process".</p>
</blockquote>
<p><span class="user-mention" data-user-id="133339">@Miroslav Olšák</span> I agree that these are big challenges. One approach might be to have a DSL for geometric processes, and then to encode the windmill process as a program in the DSL. </p>
<div class="codehilite"><pre><span></span>windmill(S, s, l) =
  while true:
    l \gets rotateUntil(l, s, CLOCK_WISE, fun l =&gt; exists s&#39; \in S, s \neq s&#39; /\ on(s&#39;, l))
    s \gets choose({s&#39; \in S : s&#39; \neq s /\ on(s&#39;, l)})
</pre></div>


<p>Here it would be provable that the <code>{s' \in S : ...}</code> set always has exactly one element (since by assumption |S| &gt; 1 and no three points are collinear) and thus the process is deterministic. The key insight required to solve the problem could then be cast as discovering an invariant of the program.</p>
<p>I am not sure what kind of semantics such a hypothetical DSL would warrant, probably operational, and bottoming out into some geometric object parameterized by time. I am also not sure whether we would have already had such abstractions before the windmill year, or whether the abstractions we can build now will be good enough for future problems.</p>

<a name="177249198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177249198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177249198">Daniel Selsam (Oct 03 2019 at 14:23)</a>:</h4>
<blockquote>
<p>As far as I know, the computational methods (Wu's method / Gröbner basis / ...) are stronger than any synthetic approach, and I have heard that they are capable of solving at least some of the IMO problems<br>
...<br>
Note that I also have a parser for that, so I can tell the types of the objects, possibly convert it to other format, etc.</p>
</blockquote>
<p><span class="user-mention" data-user-id="133339">@Miroslav Olšák</span> I am very curious which existing problems can be solved by which existing tools. What do you think are the most relevant off-the-shelf tools to try?</p>

<a name="177249634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177249634" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177249634">Miroslav Olšák (Oct 03 2019 at 14:27)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="133339">Miroslav Olšák</span> Nice! What do you think about the current plan, of requiring human-assessment of the witnesses and only accepting witnesses that human judges would have accepted? See <a href="https://github.com/IMO-grand-challenge/formal-encoding/blob/master/design/determine.lean" target="_blank" title="https://github.com/IMO-grand-challenge/formal-encoding/blob/master/design/determine.lean">https://github.com/IMO-grand-challenge/formal-encoding/blob/master/design/determine.lean</a> for more context.</p>
</blockquote>
<p>Well, putting a human into the loop is fine, it just rather postpones the problem than solves it (but it may be a good thing to postpone it). I also like the idea of whitelist of allowed operations for every individual problem where the problems available so far would help us prepare templates for such whitelists. But if a problem requiring something more complex emerged, we could simply modify the whitelist to allow what is necessary without providing much hints (it is actually also putting a human to the loop but to another place).</p>

<a name="177259600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177259600" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177259600">Kevin Buzzard (Oct 03 2019 at 16:10)</a>:</h4>
<p>This looks interesting : <a href="https://mathoverflow.net/a/337705" target="_blank" title="https://mathoverflow.net/a/337705">https://mathoverflow.net/a/337705</a> . I don't know if it's good enough to solve IMO problems though</p>

<a name="177284270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177284270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177284270">Patrick Massot (Oct 03 2019 at 20:21)</a>:</h4>
<p>Maybe this conversation should move to another Zulip thread. That one is meant to be used by the Zulip AI only. More seriously, it would make it easier to find back this conversation. Miroslav, I think you can to the move by editing your first message in this thread.</p>

<a name="177284413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177284413" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177284413">Reid Barton (Oct 03 2019 at 20:22)</a>:</h4>
<p>(Miroslav, Patrick is referring to the topic "stream events" in case it's not clear)</p>

<a name="177284424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177284424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177284424">Miroslav Olšák (Oct 03 2019 at 20:22)</a>:</h4>
<p>Oh, yes, sorry, I am not so familiar with Zulip.</p>

<a name="177284617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177284617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177284617">Miroslav Olšák (Oct 03 2019 at 20:24)</a>:</h4>
<p>Now it is "hmble", any suggestion for a better name? (why does it actually require a name, I just wanted to contribute to the general discussion)</p>

<a name="177284682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177284682" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177284682">Johan Commelin (Oct 03 2019 at 20:25)</a>:</h4>
<p>Well, then call it "general discussion"</p>

<a name="177285218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177285218" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177285218">Daniel Selsam (Oct 03 2019 at 20:30)</a>:</h4>
<blockquote>
<p>I don't know, perhaps we should ask people from the community aroung automated deduction in geometry.</p>
</blockquote>
<p><span class="user-mention" data-user-id="133339">@Miroslav Olšák</span> I am most curious about which (non-synthetic) decision procedures work for which existing problems, e.g. by considering them as nonlinear real arithmetic (NRA) problems.</p>

<a name="177377100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177377100" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177377100">Joe Hendrix (Oct 04 2019 at 20:40)</a>:</h4>
<p>(deleted)</p>

<a name="177377845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177377845" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177377845">Patrick Massot (Oct 04 2019 at 20:51)</a>:</h4>
<blockquote>
<p>Well, then call it "general discussion"</p>
</blockquote>
<p>Maybe I'm not reading carefully enough, but I was under the impression there was a clear geometry thread. If this is not specific enough then it means we give up using Zulip threads.</p>

<a name="177380191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177380191" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177380191">Miroslav Olšák (Oct 04 2019 at 21:21)</a>:</h4>
<blockquote>
<blockquote>
<p>Well, then call it "general discussion"</p>
</blockquote>
<p>Maybe I'm not reading carefully enough, but I was under the impression there was a clear geometry thread. If this is not specific enough then it means we give up using Zulip threads.</p>
</blockquote>
<p>I had several remarks, only one of them is related to geometry (and I don't consider the Windmill problem related to geometry, it is rather combinatorics).</p>

<a name="177380365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177380365" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177380365">Daniel Selsam (Oct 04 2019 at 21:23)</a>:</h4>
<blockquote>
<p>I had several remarks, only one of them is related to geometry</p>
</blockquote>
<p><span class="user-mention" data-user-id="133339">@Miroslav Olšák</span> FYI the recommended style is to use different topics for each question/comment in a batch.</p>

<a name="177381547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177381547" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177381547">Miroslav Olšák (Oct 04 2019 at 21:40)</a>:</h4>
<p>By the way, the comments teaching me how to use Zulip look irrelevant from the general perspective. I suggest using rather private messages next time. By the way, can I delete at least my comments of regarding Zulip?</p>

<a name="177406559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/177406559" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#177406559">Patrick Massot (Oct 05 2019 at 09:31)</a>:</h4>
<p><span class="user-mention" data-user-id="133339">@Miroslav Olšák</span> I'm very sorry my message may have sounded a bit aggressive. I'm sure Daniel and the whole grand-challenge team is very happy to read your contributions. Experience on this forum suggests things are a bit easier if we somehow try to separate topics, but there are plenty of counterexamples. So please don't let that issue prevent you from contributing.</p>

<a name="178889560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178889560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178889560">Brando Miranda (Oct 23 2019 at 19:52)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> I am trying to understand the specifications we are trying to pin down in this community. Inspired by a question on the Intermediate Langauge stream referencing HOList and worrying about portability of the competition if things get tied down to lean, is the goal of the project also to re-implement something like HOList? How is it going to be different? </p>
<p>From the comment on that thread/stream it seems that re-implementing HOList would be a pain (I wish I understood why), but I think it would be important to understand the difference and planning things out before going out and re-implementing a complicated system like HOList. What are your thoughts?</p>

<a name="178904475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178904475" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178904475">Daniel Selsam (Oct 23 2019 at 22:53)</a>:</h4>
<blockquote>
<p>From the comment on that thread/stream it seems that re-implementing HOList would be a pain (I wish I understood why), but I think it would be important to understand the difference and planning things out before going out and re-implementing a complicated system like HOList. What are your thoughts?</p>
</blockquote>
<p>It is not hard to interface with ML systems. Lean has a tactic framework, with excellent meta-programming support, and also a foreign function interface.</p>

<a name="178908913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178908913" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178908913">Jason Rute (Oct 24 2019 at 00:06)</a>:</h4>
<blockquote>
<p>it seems that re-implementing HOList would be a pain (I wish I understood why)</p>
</blockquote>
<p><span class="user-mention" data-user-id="246156">@Brando Miranda</span> I can try to address (narrowly) what I think would need to happen to reimplement HOList in Lean.  I know at least one person here is working on it.  I don’t know what progress they have made.  I’m probably the one who said this  a “pain”.  I should probably backtrack and say it is doable with a good amount of engineering work, and I hope someone builds it!  As I think you have an ML background, I won’t try to cover up the ML terminology.</p>

<a name="178908916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178908916" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178908916">Jason Rute (Oct 24 2019 at 00:06)</a>:</h4>
<p>As I see it, the HOList projects have the following parts that would need to be reimplemented:</p>
<ol>
<li><em>A list of theorems</em> For both training and testing, one needs a list of theorems (and the full context in some nicely parsable form) to train on.</li>
<li><em>Proof recording (optional)</em> If one wants to do supervised learning, then one needs a list of proofs as well to train on.  These proofs will contain the theorem to prove (with the context) as well as the various tactics which have been applied along with their arguments.  This needs to be at some intermediate level which records the name of the tactic and the arguments (so at a higher level than type theory), but probably not at the level of the raw lean code.  I’ve heard from some in the Lean community that the tactic environment could be hacked to provide this information, but I don’t know that it has ever been done.  HOL Light has some advantages here.  It has a simpler tactic framework (I think), it is a larger library (more training data), it is written by one person mostly (so is more uniform), and HOL Light only uses tactics (whereas Lean uses a mixture of tactics and the type theoretic framework).  However, the ASTactic (CogGym) and ProverBot9001 projects also used proof recording for Coq.</li>
<li><em>An interactive environment</em> If one wants to do reinforcement learning and/or tree search, one needs to be able to quickly interact with the system.  For tree search, given a particular state, one needs to be able to try possible tactics, see what the results are and back track if needed (using for example beam search).  Also, for reinforcement learning, one needs to be able to try out a very large number of scenarios (in this case theorems, either real or synthetic, to prove).  This necessitates an even faster back-and-forth between the agent and the system.  Google rewrote HOL Light in C++ for this purpose.  (The various Coq ML projects don’t use reinforcement learning.)</li>
<li><em>A system for scoring tactics and tactic arguments</em>  Scoring the tactics can be done as a probability distribution over the tactics (computed by a neural network), but scoring the arguments to these tactics can be a bit more tricky because of the large number of possibilities.  HOList has one system for doing this.  The two Coq projects have another system.  I don’t know if either is readily adaptable to Lean.</li>
<li><em>Access to neural networks and computer power for training and evaluation</em> The agent will have to compute tactic and argument scores via (graph?) neural networks.  Therefore, it needs access to TensorFlow or PyTorch and a distributed computing system.</li>
</ol>

<a name="178908921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178908921" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178908921">Jason Rute (Oct 24 2019 at 00:06)</a>:</h4>
<p>Some further comments.  One doesn’t need proof recording.  Instead one can train solely with theorem statements and reinforcement learning.  Conversely, if one doesn’t use reinforcement learning, then one doesn’t need as much speed in the interactive environment.  Also, the tree search agent could live inside Lean (as a tactic) making FFI calls to TensorFlow, say.  Alternately it could have the agent in Python or C++.  Then it would have to guide Lean from the outside.  I don’t know which is better.</p>

<a name="178912124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178912124" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178912124">Brando Miranda (Oct 24 2019 at 01:11)</a>:</h4>
<blockquote>
<p>I know at least one person here is working on it.</p>
</blockquote>
<p>Awesome! Do you think its possible to get me in touch with them or their team? thanks!</p>

<a name="178912366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178912366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178912366">Brando Miranda (Oct 24 2019 at 01:16)</a>:</h4>
<blockquote>
<p>Google rewrote HOL Light in C++ for this purpose. (The various Coq ML projects don’t use reinforcement learning.)</p>
</blockquote>
<p>Are you saying google wrote HOL Light (the entire Theorm prover, idk if that is a lot of work or not but it sounds like it) only so that they could do RL on HOL Light? (trying to repeat it back to you to make sure I got it).</p>
<p>On a very related note, does that mean for someone to re-implement HOList to make LeanList we would need to re-implement Lean in a language that allows for high performance/speed to do RL?</p>
<p>I think the fundamental thing I don't understand is how to do  the IMO-grand-challenge without a system like HOList built already. Why wouldn't that need to be a pre-requisite?</p>

<a name="178912398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178912398" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178912398">Mario Carneiro (Oct 24 2019 at 01:16)</a>:</h4>
<p>Lean is implemented in C++ already</p>

<a name="178912414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178912414" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178912414">Mario Carneiro (Oct 24 2019 at 01:17)</a>:</h4>
<p>and high performance has always been an objective</p>

<a name="178912418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178912418" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178912418">Brando Miranda (Oct 24 2019 at 01:17)</a>:</h4>
<blockquote>
<p>Lean is implemented in C++ already</p>
</blockquote>
<p>So its fast enough to do Reinforcement Learning (RL) on it already? Is that what your saying?</p>

<a name="178912474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178912474" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178912474">Mario Carneiro (Oct 24 2019 at 01:18)</a>:</h4>
<p>I have no idea what specifically is required for that, but FFI should be sufficient</p>

<a name="178912485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178912485" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178912485">Brando Miranda (Oct 24 2019 at 01:18)</a>:</h4>
<blockquote>
<p>I have no idea what specifically is required for that, but FFI should be sufficient</p>
</blockquote>
<p>what does FFI mean?</p>

<a name="178912491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178912491" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178912491">Mario Carneiro (Oct 24 2019 at 01:18)</a>:</h4>
<p>foreign function interface, i.e. calling functions in other languages</p>

<a name="178912501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178912501" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178912501">Mario Carneiro (Oct 24 2019 at 01:19)</a>:</h4>
<p>I am also curious about "Google rewrote HOL Light"</p>

<a name="178912586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178912586" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178912586">Brando Miranda (Oct 24 2019 at 01:20)</a>:</h4>
<p>Im curious, for Foreign Function Interface (FFI), is Lean's faster than Coq?</p>

<a name="178912611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178912611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178912611">Mario Carneiro (Oct 24 2019 at 01:21)</a>:</h4>
<p>Lean 3 got an FFI only in the community version, and I haven't used Lean 4's</p>

<a name="178912667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178912667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178912667">Mario Carneiro (Oct 24 2019 at 01:22)</a>:</h4>
<p>I don't see any reason why FFI should be very slow</p>

<a name="178912669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178912669" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178912669">Reid Barton (Oct 24 2019 at 01:22)</a>:</h4>
<p>I'm sure Lean 4's will be fast.</p>

<a name="178912681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178912681" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178912681">Mario Carneiro (Oct 24 2019 at 01:22)</a>:</h4>
<p>I guess marshaling of large objects might be a performance penalty</p>

<a name="178912697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178912697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178912697">Brando Miranda (Oct 24 2019 at 01:23)</a>:</h4>
<p>Is an Foreign Function Interface (FFI), bi-directional? or is it only powerful from within Lean to say Python? What about the reverse?</p>

<a name="178912750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178912750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178912750">Mario Carneiro (Oct 24 2019 at 01:24)</a>:</h4>
<p>The only way I am aware of for other languages to talk to lean is through the server mode, which uses JSON for message passing</p>

<a name="178912755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178912755" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178912755">Mario Carneiro (Oct 24 2019 at 01:24)</a>:</h4>
<p>I guess you could also try literally linking with lean as a library, but I've never seen that done and I have no idea if it's doable</p>

<a name="178912866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178912866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178912866">Brando Miranda (Oct 24 2019 at 01:27)</a>:</h4>
<p>How does SerAPI (<a href="https://github.com/ejgallego/coq-serapi" target="_blank" title="https://github.com/ejgallego/coq-serapi">https://github.com/ejgallego/coq-serapi</a>) compare to Lean's foreign function interface (ffi)? Or are they totally different?</p>

<a name="178913034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178913034" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178913034">Reid Barton (Oct 24 2019 at 01:30)</a>:</h4>
<p>It looks like something different</p>

<a name="178913056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178913056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178913056">Bryan Gin-ge Chen (Oct 24 2019 at 01:31)</a>:</h4>
<p>SerAPI looks more like Lean's server mode, at least from my quick skim of the Github readme. At least all of Lean's editor integration is done via <code>lean --server</code>.</p>

<a name="178913109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178913109" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178913109">Bryan Gin-ge Chen (Oct 24 2019 at 01:32)</a>:</h4>
<p>Though as Mario said, the Lean server mode uses JSON and it looks like SerAPI is doing something much more sophisticated.</p>

<a name="178913123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178913123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178913123">Reid Barton (Oct 24 2019 at 01:33)</a>:</h4>
<p>The Lean FFI lets you call C functions from a compiled Lean program. For example <a href="https://github.com/leanprover/lean4/blob/master/library/Init/System/IO.lean#L115" target="_blank" title="https://github.com/leanprover/lean4/blob/master/library/Init/System/IO.lean#L115">handle.close</a> is implemented by <a href="https://github.com/leanprover/lean4/blob/faf7d7daf60413b74120cdcecda455f25f8210aa/src/runtime/io.cpp#L124" target="_blank" title="https://github.com/leanprover/lean4/blob/faf7d7daf60413b74120cdcecda455f25f8210aa/src/runtime/io.cpp#L124">lean_io_prim_handle_close</a> (okay, bad example!)</p>

<a name="178913144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178913144" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178913144">Reid Barton (Oct 24 2019 at 01:33)</a>:</h4>
<p>or <a href="https://github.com/leanprover/lean4/blob/master/library/Init/Data/Int/Basic.lean#L49" target="_blank" title="https://github.com/leanprover/lean4/blob/master/library/Init/Data/Int/Basic.lean#L49">Int.add</a> is implemented by <a href="https://github.com/leanprover/lean4/blob/870db93c8e6f75ce3a1facbb0c494b1afad7c1f5/src/runtime/lean.h#L1359" target="_blank" title="https://github.com/leanprover/lean4/blob/870db93c8e6f75ce3a1facbb0c494b1afad7c1f5/src/runtime/lean.h#L1359">lean_int_add</a></p>

<a name="178913214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178913214" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178913214">Mario Carneiro (Oct 24 2019 at 01:34)</a>:</h4>
<p>can you pass or return objects?</p>

<a name="178913237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178913237" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178913237">Reid Barton (Oct 24 2019 at 01:35)</a>:</h4>
<p>Like <code>Int</code>s? <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span></p>

<a name="178913252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178913252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178913252">Reid Barton (Oct 24 2019 at 01:35)</a>:</h4>
<p>though probably <code>Int</code> is itself some kind of magic when compiled</p>

<a name="178913269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178913269" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178913269">Mario Carneiro (Oct 24 2019 at 01:35)</a>:</h4>
<p>As long as there is no message passing, I guess there is no reason for much performance overhead with the FFI; total runtime should be dominated by the C function itself</p>

<a name="178913332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178913332" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178913332">Mario Carneiro (Oct 24 2019 at 01:36)</a>:</h4>
<p>but if you have some huge array you have to pass in, that could hurt if the FFI layer isn't done properly</p>

<a name="178913536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178913536" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178913536">Reid Barton (Oct 24 2019 at 01:40)</a>:</h4>
<p>Based on the other performance engineering that has already gone into Lean 4, I'm confident that it will be at least possible to do efficient FFI</p>

<a name="178913548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178913548" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178913548">Reid Barton (Oct 24 2019 at 01:40)</a>:</h4>
<p>The <code>@&amp;</code> in the type of <code>Int.add</code> means that the argument is borrowed, I think</p>

<a name="178913638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178913638" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178913638">Reid Barton (Oct 24 2019 at 01:42)</a>:</h4>
<p><a href="https://github.com/leanprover/lean4/blob/master/library/Init/Data/Array/Basic.lean#L75" target="_blank" title="https://github.com/leanprover/lean4/blob/master/library/Init/Data/Array/Basic.lean#L75">https://github.com/leanprover/lean4/blob/master/library/Init/Data/Array/Basic.lean#L75</a> makes me think you can do zero-copy FFI with <code>Array</code> (assuming the C side is well-behaved of course)</p>

<a name="178913665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178913665" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178913665">Reid Barton (Oct 24 2019 at 01:43)</a>:</h4>
<p>It would be cool if there was an FFI to Rust that could cooperate with the Rust types</p>

<a name="178913672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178913672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178913672">Reid Barton (Oct 24 2019 at 01:43)</a>:</h4>
<p>although I have no idea whether that is even possible</p>

<a name="178913728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178913728" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178913728">Brando Miranda (Oct 24 2019 at 01:44)</a>:</h4>
<p>Is this High Performance conversation with the foreign function interface (FFI) the reason Coq projects (CoqGym, gamepad, etc) do not do Reinforcement Learning (RL)? Anyone know?</p>

<a name="178913994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178913994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178913994">Reid Barton (Oct 24 2019 at 01:51)</a>:</h4>
<p>I don't know the answer to that, but this FFI business is relevant because it means it is actually viable to build your ML system in Lean, which gives you direct access to the Lean tactic state and so on as well. For other theorem provers, you'd want to use a different programming language and then you have the problem of importing/exporting data like the tactic state. (Although I'm not sure why you couldn't just use OCaml as the host language for the theorem provers written in it.)</p>

<a name="178915602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178915602" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178915602">Brando Miranda (Oct 24 2019 at 02:28)</a>:</h4>
<p>Well, most serious ML researchers use python, so thats why, I believe most of us don't know OCaml (I'm learning it myself now thought cuz I predicted it might be useful as you have pointed out, but even if I write my ML in OCaml then it means little people can build on it if its all in OCaml)</p>

<a name="178915705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178915705" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178915705">Brando Miranda (Oct 24 2019 at 02:30)</a>:</h4>
<blockquote>
<p>but this FFI business is relevant because it means it is actually viable to build your ML system in Lean, which gives you direct access to the Lean tactic state and so on as well.</p>
</blockquote>
<p>Oh interesting! But would that mean I can build an ML system inside of Lean or inside of Python?</p>

<a name="178915783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178915783" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178915783">Brando Miranda (Oct 24 2019 at 02:32)</a>:</h4>
<blockquote>
<p>For other theorem provers, you'd want to use a different programming language and then you have the problem of importing/exporting data like the tactic state.</p>
</blockquote>
<p>Do you mind expanding what this means? In particular, why does one need an external programming language for most ITPs? (perhaps a few examples would be nice) Also, why isn't this a problem in Lean? Is it because Lean is a programming language itself or because of the foreign function interface (FFI)?</p>
<p>(Perhaps I will go and play with Lean's foreign function interface (FFI) so that its less wishy-washy in my head and get my hands dirty).</p>

<a name="178915898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178915898" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178915898">Jason Rute (Oct 24 2019 at 02:35)</a>:</h4>
<p>As for rewriting HOL light in C++.  I tried to look it up.  It seems that in <a href="https://arxiv.org/pdf/1904.03241.pdf" target="_blank" title="https://arxiv.org/pdf/1904.03241.pdf">the first HOList paper</a> and <a href="https://sites.google.com/view/holist/home" target="_blank" title="https://sites.google.com/view/holist/home">the website</a> mention that their modified form of HOL Light is called DeepHOL.  I think looking at the code they seemed to have just rewritten the kernel in C++, but I am not certain.  The whole thing is usable as a docker container where one can treat it as a black box theorem prover interface.  (See the website for how to use it.)</p>

<a name="178916069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178916069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178916069">Reid Barton (Oct 24 2019 at 02:39)</a>:</h4>
<p>Other theorem provers (including Lean 3, really) either aren't programming languages at all, or aren't adequate as programming languages for the task (though I must say I don't understand the situation with Coq, in particular)</p>

<a name="178916196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178916196" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178916196">Jason Rute (Oct 24 2019 at 02:43)</a>:</h4>
<p>I think one would need the following in a project like this.  </p>
<ul>
<li>A reinforcement learning master algorithm which decides which problems to try to attempt, tells the agent to try to solve them, records the results, and uses these results to train the neural network.  This would also probably be a heavily parallelized application.</li>
<li>A search algorithm which tries to solve a particular problem (repeatedly querying a neural network as an oracle).</li>
<li>The part which actually runs the neural network.  (And for speed it probably needs to batch up calls to the neural network and send them together to make efficient use of the GPU.</li>
<li>The part which trains the neural network.</li>
</ul>
<p>I think the last two need to be in Python or C++.  The tree search agent could be in Lean with FFI to the part which calls the network, but I don't know how well a purely functional language  does with (non-depth-first) tree search.  The overall master agent could be written in lean, but I assume it would make more sense in something else.</p>

<a name="178916279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178916279" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178916279">Jason Rute (Oct 24 2019 at 02:45)</a>:</h4>
<p>Also, I guess speed doesn't matter as much when you have massive parallelism.  (At my job, when we need something done fast, we just reserve more AWS instances.  [Well in theory.  In practice there always seems to be a bottle neck or it is too expensive.])</p>

<a name="178945994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178945994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178945994">Jason Rute (Oct 24 2019 at 12:24)</a>:</h4>
<p>I thought a bit more about tree search algorithms in Lean.  In general, reasonably efficient search algorithms can be implemented with maps (hash tables or other lookup data structures) and priority queues (heaps).  I know Lean 3 doesn't have a priority queue/heap but I found a good one in the book <a href="https://www.amazon.com/Purely-Functional-Data-Structures-Okasaki/dp/0521663504" target="_blank" title="https://www.amazon.com/Purely-Functional-Data-Structures-Okasaki/dp/0521663504">Purely Functional Data Structures</a>.  A few weeks ago I tried implementing both their BinomialHeap and SplayHeap in Lean.  The SplayHeap is about an order of magnitude faster than the Binomial Heap and can do heap sort in Lean as fast as Lean's merge sort.  (I noticed Lean 4 implements BinomialHeaps in the base library, and I wonder if SplayHeaps would be better.)  So maybe if Lean is decked out with the fastest purely functional fastest data structures (or uses FFI to call non-functional C++ data structures), then it wouldn't be a large bottleneck to have the search agent live in Lean.  Then one would have a powerful fast search tactic in Lean (which could be guided by FFI calls to a pre-trained neural network).</p>

<a name="178955075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/178955075" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#178955075">Brando Miranda (Oct 24 2019 at 14:07)</a>:</h4>
<blockquote>
<p>Then one would have a powerful fast search tactic in Lean (which could be guided by FFI calls to a pre-trained neural network).</p>
</blockquote>
<p>What worries me is the "pre-trained" neural net (NN) part. I think if Lean is going to be used besides just a theorem prover, it should allow for training of the NN. Also, another thing to consider is that its going to be hard for people to adopt the challenge or ITP Lean environment/dataset if it all lives in a new programming language that is not "standard" like python. I dont think its going to be able to kick off like the famous large-scale computer vision competition/dataset (ImageNet). It has to be taken into account that if every competitor is forced to learn a new programming paradigm (like functional programming (fp)), note this isn't only a new programming language, it might take some time to people really use it (or perhaps people won't). It takes some time to get good at a new programming language, specially if its a new paradigm. Having things in Python imho will make any ITP challenge more likely to thrive.</p>

<a name="179011212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/179011212" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#179011212">Jason Rute (Oct 25 2019 at 00:21)</a>:</h4>
<p><span class="user-mention" data-user-id="246156">@Brando Miranda</span> I think in some sense one needs both (to (1) be able to run a search algorithm inside Lean with a NN and (2) guide Lean from the outside in something like Python).  Setting aside the IMO challenge and just thinking about improving Lean, from the perspective of a Lean user, they want whatever system one is building to be usable in Lean.  And this is really a problem with the other tools out there.  I don't know if any of the AI/ITP systems currently out there are usable and useful to the practitioners of that ITP system.  However, if Lean had a HOList-like tactic called <code>lean_ist</code> (which admittedly would involve some additional setup), then they could write <code>by lean_ist</code>.  The system would behave similar to the <code>library_search</code> tactic, outputting a proof which can be pasted into Lean.</p>

<a name="179011250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/179011250" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#179011250">Jason Rute (Oct 25 2019 at 00:21)</a>:</h4>
<p>On the flip side, something that inhibits the growth of these AI for ITP systems is that it is a major engineering feat to link your AI library to your theorem prover (and just as large of a feat to learn the intricacies of the logic).  One thing that has really increased neural network research progress has been environments which are easy to spin up and play with.  These "gym" environments allow you apply the same training algorithm to many different problems which have the same interface.  I think a very useful research project would be the following:  Go through the other AI for theorem proving projects out there, and find a common gym-like interface for interactive theorem provers and related systems, including tableau calculus, constraint solvers, QBF solvers, SMT solvers with tactics, non-classical proof systems.  (I can point one to over a dozen papers, each in a separate system.)   As far as I see they have the following uniform framework:</p>
<ul>
<li>A term and formula language</li>
<li>A local goal state: What one is trying to prove at the moment (as an ordered list of formulas in some formal language)</li>
<li>Premise List: all the possible previously proven theorem statements one could use (which needs to be significantly narrowed down in a process called “premise selection”)</li>
<li>Tactics or inference rules: a fixed finite set of rules one can apply to ones current goal state</li>
<li>Tactic parameters: the possible parameters that can be added to the above tactics.  (This is by far the most inconsistent and flexible part of the framework.  These parameters can include numbers, terms, and premises from the premise list.)</li>
<li>a training and test set: formulas to prove (and possibly proofs for supervised learning)</li>
<li>application: one needs to be able to quickly apply a rule/tactic</li>
<li>persistence/backtracking: So that any tree search algorithm can be applied, one needs a notion of backtracking.  (Practically, this means that states need to be persistent.  If one applies a tactic it creates a new state, without changing the old state.  Think immutable data structures.)</li>
</ul>

<a name="179011267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/179011267" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#179011267">Jason Rute (Oct 25 2019 at 00:21)</a>:</h4>
<p>Now not all systems use all of the above.  A simple logical system, e.g. QBFs, may not use premise selection or tactic parameters.   A fully automatic system (e.g. an ATP like E-prover) may only have one tactic (solve) and the challenge is just premise selection.  Some systems also don’t have the backtracking, but that severely limits how effectively one can search.</p>

<a name="179011311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/179011311" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#179011311">Jason Rute (Oct 25 2019 at 00:22)</a>:</h4>
<p>Now HOList has basically created a system like this in DeepHOL (although not very well documented) which they make easier to use by burying it in a docker container, so it just becomes a black box (a gym).  I also think they had to do a lot of work to make the persistence/backtracking thing work, but that is also not documented well.  I think the CoqGym and GamePad systems also try to do something similar for Coq.  In some systems like MetaMath, it shouldn’t be terribly hard to just rewrite the logic to make such an environment.  <strong>The question is, can Lean be abstracted into a system like this which is fast (and more importantly, it satisfies the persistence/backtracking requirement).</strong></p>

<a name="179011320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/179011320" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#179011320">Jason Rute (Oct 25 2019 at 00:22)</a>:</h4>
<p>Getting back to the IMO challenge, I feel the goal is different than developing a training algorithm for an arbitrary neural theorem prover.  However, I agree that it isn’t clear if this project will attract those outside of the established Lean community or Microsoft Research because of the barrier to entry.  However, you are here @Brando, so maybe it is working. :)</p>

<a name="179011638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/179011638" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#179011638">Mario Carneiro (Oct 25 2019 at 00:27)</a>:</h4>
<p>lean has always had a backtracking tactic state</p>

<a name="179011649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/179011649" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#179011649">Mario Carneiro (Oct 25 2019 at 00:27)</a>:</h4>
<p>speed might be an issue, but possibly lean 4 has solved that problem</p>

<a name="179011742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/179011742" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#179011742">Jason Rute (Oct 25 2019 at 00:28)</a>:</h4>
<p>But is it useable from the outside.  Could it be wrapped in a black box with a set number of tactics?  (So from the outside it is just like a chess board with a set number of possible moves?)</p>

<a name="179011962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/179011962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#179011962">Mario Carneiro (Oct 25 2019 at 00:32)</a>:</h4>
<p>I would really like a C++ API for doing this</p>

<a name="179011991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/208328-IMO-grand-challenge/topic/general%20discussion/near/179011991" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/208328IMOgrandchallenge/95555generaldiscussion.html#179011991">Mario Carneiro (Oct 25 2019 at 00:33)</a>:</h4>
<p>You can do it with lean --server but there is far too much overhead involved</p>


{% endraw %}

{% include archive_update.html %}