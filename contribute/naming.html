<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="https://leanprover-community.github.io//css/lean.css" >
  <link rel="shortcut icon" href="https://leanprover-community.github.io//img/favicon.ico">
  <link rel="search" type="application/opensearchdescription+xml" title="mathlib docs" href="https://leanprover-community.github.io//opensearch.xml">
  <link href="https://fonts.googleapis.com/css2?family=Merriweather&family=Open+Sans&family=Source+Code+Pro:wght@400;600&display=swap" rel="stylesheet">
    

	<script>
                function buildShortcutsForStructures(names) {
                        const o = {}
                        names.forEach(name => o[name] = `\\mathbb\{${name}\}`)
                        return o
                }
		MathJax = {
			  tex: {
                                  macros: {
                                          ...buildShortcutsForStructures(["R", "Q", "Z", "N", "C"]),
                                  },
				      inlineMath: [['$', '$'], ['\\(', '\\)']]
				    },
		};
	</script>
	<script type="text/javascript" id="MathJax-script" async
		  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
	</script>

	<title>Mathlib naming conventions</title>
  </head>
  <body>
  <nav class="navbar navbar-expand-lg navbar-light bg-gradient-light d-md-none">
    <div class="d-flex flex-grow-1">
		<a class="navbar-brand" href="https://leanprover-community.github.io/index.html">Lean Community
    </a>
    </div>

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </nav>

<div id="mainbox">

  <main>
    
<h1 id="mathlib-naming-conventions" class="markdown-heading">Mathlib naming conventions <a class="hover-link" href="#mathlib-naming-conventions">#</a></h1>
<p>This guide is written for Lean 4.</p>
<h2 id="file-names" class="markdown-heading">File names <a class="hover-link" href="#file-names">#</a></h2>
<p><code>.lean</code> files in mathlib should generally be named in <code>UpperCamelCase</code>.
A (very rare) exception are files named after some specifically lower-cased object, e.g. <code>lp.lean</code> for a file specifically about the space $\ell_p$ (and not $L^p$).
Such exceptions should be discussed on Zulip first.</p>
<h2 id="general-conventions" class="markdown-heading">General conventions <a class="hover-link" href="#general-conventions">#</a></h2>
<p>Unlike Lean 3, in which the convention was that all declarations used <code>snake_case</code>,
in mathlib under Lean 4 we use a combination of <code>snake_case</code>, <code>lowerCamelCase</code> and
<code>UpperCamelCase</code> according to the following naming scheme.</p>
<ol>
<li>Terms of <code>Prop</code>s (e.g. proofs, theorem names) use <code>snake_case</code>.</li>
<li><code>Prop</code>s and <code>Type</code>s (or <code>Sort</code>) (inductive types, structures, classes) are in <code>UpperCamelCase</code>.
There are some rare exceptions: some fields of structures are currently wrongly lower-cased (see the example for the class <code>LT</code> below).</li>
<li>Functions are named the same way as their return values (e.g. a function of type <code>A → B → C</code> is named as though it is a term of type <code>C</code>).</li>
<li>All other terms of <code>Type</code>s (basically anything else) are in <code>lowerCamelCase</code>.</li>
<li>When something named with <code>UpperCamelCase</code> is part of something named with <code>snake_case</code>, it is referenced in <code>lowerCamelCase</code>.</li>
<li>Acronyms like <code>LE</code> are written upper-/lowercase as a group, depending on what the first character would be.</li>
<li>Rules 1-6 apply to fields of a structure or constructors of an inductive type in the same way.</li>
</ol>
<p>There are some rare exceptions to preserve local naming symmetry: e.g., we use <code>Ne</code> rather than <code>NE</code> to follow the example of <code>Eq</code>; <code>outParam</code> has a <code>Sort</code> output but is not <code>UpperCamelCase</code>. Some other exceptions include intervals (<code>Set.Icc</code>, <code>Set.Iic</code>, etc.), where the <code>I</code>
is capitalized despite the fact that it should be <code>lowerCamelCase</code> according to the convention. Any such exceptions should be discussed on Zulip.</p>
<h3 id="examples" class="markdown-heading">Examples <a class="hover-link" href="#examples">#</a></h3>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="c1">-- follows rule 2</span>
<span class="kd">structure</span><span class="w"> </span><span class="n">OneHom</span><span class="w"> </span><span class="o">(</span><span class="n">M</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">_</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">N</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">_</span><span class="o">)</span><span class="w"> </span><span class="o">[</span><span class="n">One</span><span class="w"> </span><span class="n">M</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">One</span><span class="w"> </span><span class="n">N</span><span class="o">]</span><span class="w"> </span><span class="n">where</span>
<span class="w">  </span><span class="n">toFun</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="bp">→</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="c1">-- follows rule 4 via rule 3 and rule 7</span>
<span class="w">  </span><span class="n">map_one&#39;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">toFun</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- follows rule 1 via rule 7</span>

<span class="c1">-- follows rule 2 via rule 3</span>
<span class="kd">class</span><span class="w"> </span><span class="n">CoeIsOneHom</span><span class="w"> </span><span class="o">[</span><span class="n">One</span><span class="w"> </span><span class="n">M</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">One</span><span class="w"> </span><span class="n">N</span><span class="o">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="n">where</span>
<span class="w">  </span><span class="n">coe_one</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="bp">↑</span><span class="o">(</span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">M</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">N</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- follows rule 1 via rule 6</span>

<span class="c1">-- follows rule 1 via rule 3</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">map_one</span><span class="w"> </span><span class="o">[</span><span class="n">OneHomClass</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="n">N</span><span class="o">]</span><span class="w"> </span><span class="o">(</span><span class="n">f</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>

<span class="c1">-- follows rules 1 and 5</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">MonoidHom.toOneHom_injective</span><span class="w"> </span><span class="o">[</span><span class="n">MulOneClass</span><span class="w"> </span><span class="n">M</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">MulOneClass</span><span class="w"> </span><span class="n">N</span><span class="o">]</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">Function.Injective</span><span class="w"> </span><span class="o">(</span><span class="n">MonoidHom.toOneHom</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="n">M</span><span class="w"> </span><span class="bp">→*</span><span class="w"> </span><span class="n">N</span><span class="o">)</span><span class="w"> </span><span class="bp">→</span><span class="w"> </span><span class="n">OneHom</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="n">N</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="c1">-- manual align is needed due to `lowerCamelCase` with several words inside `snake_case`</span>
<span class="bp">#</span><span class="n">align</span><span class="w"> </span><span class="n">monoid_hom.to_one_hom_injective</span><span class="w"> </span><span class="n">MonoidHom.toOneHom_injective</span>

<span class="c1">-- follows rule 2</span>
<span class="kd">class</span><span class="w"> </span><span class="n">HPow</span><span class="w"> </span><span class="o">(</span><span class="n">α</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">β</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">v</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">γ</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">w</span><span class="o">)</span><span class="w"> </span><span class="n">where</span>
<span class="w">  </span><span class="n">hPow</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">α</span><span class="w"> </span><span class="bp">→</span><span class="w"> </span><span class="n">β</span><span class="w"> </span><span class="bp">→</span><span class="w"> </span><span class="n">γ</span><span class="w"> </span><span class="c1">-- follows rule 3 via rule 6; note that rule 5 does not apply</span>

<span class="c1">-- follows rules 2 and 6</span>
<span class="kd">class</span><span class="w"> </span><span class="n">LT</span><span class="w"> </span><span class="o">(</span><span class="n">α</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">)</span><span class="w"> </span><span class="n">where</span>
<span class="w">  </span><span class="n">lt</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">α</span><span class="w"> </span><span class="bp">→</span><span class="w"> </span><span class="n">α</span><span class="w"> </span><span class="bp">→</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="c1">-- this is an exception to rule 2</span>

<span class="c1">-- follows rules 2 (for `Semifield`) and 4 (for `toIsField`)</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">Semifield.toIsField</span><span class="w"> </span><span class="o">(</span><span class="n">R</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">)</span><span class="w"> </span><span class="o">[</span><span class="n">Semifield</span><span class="w"> </span><span class="n">R</span><span class="o">]</span><span class="w"> </span><span class="o">:</span>
<span class="w">    </span><span class="n">IsField</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="c1">-- follows rule 2</span>

<span class="c1">-- follows rules 1 and 6</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">gt_iff_lt</span><span class="w"> </span><span class="o">[</span><span class="n">LT</span><span class="w"> </span><span class="n">α</span><span class="o">]</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">α</span><span class="o">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">↔</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>

<span class="c1">-- follows rule 2; `Ne` is an exception to rule 6</span>
<span class="kd">class</span><span class="w"> </span><span class="n">NeZero</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>

<span class="c1">-- follows rules 1 and 5</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">neZero_iff</span><span class="w"> </span><span class="o">{</span><span class="n">R</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">_</span><span class="o">}</span><span class="w"> </span><span class="o">[</span><span class="n">Zero</span><span class="w"> </span><span class="n">R</span><span class="o">]</span><span class="w"> </span><span class="o">{</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">R</span><span class="o">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">NeZero</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">↔</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">≠</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="c1">-- manual align is needed due to `lowerCamelCase` with several words inside `snake_case`</span>
<span class="bp">#</span><span class="n">align</span><span class="w"> </span><span class="n">ne_zero_iff</span><span class="w"> </span><span class="n">neZero_iff</span>
</code></pre></div>
</div>

<h3 id="names-of-symbols" class="markdown-heading">Names of symbols <a class="hover-link" href="#names-of-symbols">#</a></h3>
<p>When translating the statements of theorems into words, the following dictionary is often used.</p>
<h4 id="logic" class="markdown-heading">Logic <a class="hover-link" href="#logic">#</a></h4>
<table>
<thead>
<tr>
<th align="left">symbol</th>
<th align="left">shortcut</th>
<th align="left">name</th>
<th align="left">notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>∨</code></td>
<td align="left"><code>\or</code></td>
<td align="left"><code>or</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>∧</code></td>
<td align="left"><code>\and</code></td>
<td align="left"><code>and</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>→</code></td>
<td align="left"><code>\r</code></td>
<td align="left"><code>of</code> / <code>imp</code></td>
<td align="left">the conclusion is stated first and the hypotheses are often omitted</td>
</tr>
<tr>
<td align="left"><code>↔</code></td>
<td align="left"><code>\iff</code></td>
<td align="left"><code>iff</code></td>
<td align="left">sometimes omitted along with the right hand side of the iff</td>
</tr>
<tr>
<td align="left"><code>¬</code></td>
<td align="left"><code>\n</code></td>
<td align="left"><code>not</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>∃</code></td>
<td align="left"><code>\ex</code></td>
<td align="left"><code>exists</code> / <code>bex</code></td>
<td align="left"><code>bex</code> stands for &quot;bounded exists&quot;</td>
</tr>
<tr>
<td align="left"><code>∀</code></td>
<td align="left"><code>\fo</code></td>
<td align="left"><code>all</code> / <code>forall</code> / <code>ball</code></td>
<td align="left"><code>ball</code> stands for &quot;bounded forall&quot;</td>
</tr>
<tr>
<td align="left"><code>=</code></td>
<td align="left"></td>
<td align="left"><code>eq</code></td>
<td align="left">often omitted</td>
</tr>
<tr>
<td align="left"><code>≠</code></td>
<td align="left"><code>\ne</code></td>
<td align="left"><code>ne</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>∘</code></td>
<td align="left"><code>\o</code></td>
<td align="left"><code>comp</code></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p><code>ball</code> and <code>bex</code> are still used in Lean core, but should not be used in mathlib.</p>
<h4 id="set" class="markdown-heading">Set <a class="hover-link" href="#set">#</a></h4>
<table>
<thead>
<tr>
<th align="left">symbol</th>
<th align="left">shortcut</th>
<th align="left">name</th>
<th align="left">notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>∈</code></td>
<td align="left"><code>\in</code></td>
<td align="left"><code>mem</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>∉</code></td>
<td align="left"><code>\notin</code></td>
<td align="left"><code>notMem</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>∪</code></td>
<td align="left"><code>\cup</code></td>
<td align="left"><code>union</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>∩</code></td>
<td align="left"><code>\cap</code></td>
<td align="left"><code>inter</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>⋃</code></td>
<td align="left"><code>\bigcup</code></td>
<td align="left"><code>iUnion</code> / <code>biUnion</code></td>
<td align="left"><code>i</code> for &quot;indexed&quot;, <code>bi</code> for &quot;bounded indexed&quot;</td>
</tr>
<tr>
<td align="left"><code>⋂</code></td>
<td align="left"><code>\bigcap</code></td>
<td align="left"><code>iInter</code> / <code>biInter</code></td>
<td align="left"><code>i</code> for &quot;indexed&quot;, <code>bi</code> for &quot;bounded indexed&quot;</td>
</tr>
<tr>
<td align="left"><code>⋃₀</code></td>
<td align="left"><code>\bigcup\0</code></td>
<td align="left"><code>sUnion</code></td>
<td align="left"><code>s</code> for &quot;set&quot;</td>
</tr>
<tr>
<td align="left"><code>⋂₀</code></td>
<td align="left"><code>\bigcap\0</code></td>
<td align="left"><code>sInter</code></td>
<td align="left"><code>s</code> for &quot;set&quot;</td>
</tr>
<tr>
<td align="left"><code>\</code></td>
<td align="left"><code>\\</code></td>
<td align="left"><code>sdiff</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>ᶜ</code></td>
<td align="left"><code>\^c</code></td>
<td align="left"><code>compl</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>{x | p x}</code></td>
<td align="left"></td>
<td align="left"><code>setOf</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>{x}</code></td>
<td align="left"></td>
<td align="left"><code>singleton</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>{x, y}</code></td>
<td align="left"></td>
<td align="left"><code>pair</code></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<h4 id="algebra" class="markdown-heading">Algebra <a class="hover-link" href="#algebra">#</a></h4>
<table>
<thead>
<tr>
<th align="left">symbol</th>
<th align="left">shortcut</th>
<th align="left">name</th>
<th align="left">notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>0</code></td>
<td align="left"></td>
<td align="left"><code>zero</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>+</code></td>
<td align="left"></td>
<td align="left"><code>add</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>-</code></td>
<td align="left"></td>
<td align="left"><code>neg</code> / <code>sub</code></td>
<td align="left"><code>neg</code> for the unary function, <code>sub</code> for the binary function</td>
</tr>
<tr>
<td align="left"><code>1</code></td>
<td align="left"></td>
<td align="left"><code>one</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>*</code></td>
<td align="left"></td>
<td align="left"><code>mul</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>^</code></td>
<td align="left"></td>
<td align="left"><code>pow</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>/</code></td>
<td align="left"></td>
<td align="left"><code>div</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>•</code></td>
<td align="left"><code>\bu</code></td>
<td align="left"><code>smul</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>⁻¹</code></td>
<td align="left"><code>\-1</code></td>
<td align="left"><code>inv</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>⅟</code></td>
<td align="left"><code>\frac1</code></td>
<td align="left"><code>invOf</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>∣</code></td>
<td align="left"><code>\|</code></td>
<td align="left"><code>dvd</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>∑</code></td>
<td align="left"><code>\sum</code></td>
<td align="left"><code>sum</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>∏</code></td>
<td align="left"><code>\prod</code></td>
<td align="left"><code>prod</code></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<h4 id="lattices" class="markdown-heading">Lattices <a class="hover-link" href="#lattices">#</a></h4>
<table>
<thead>
<tr>
<th align="left">symbol</th>
<th align="left">shortcut</th>
<th align="left">name</th>
<th align="left">notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>&lt;</code></td>
<td align="left"></td>
<td align="left"><code>lt</code> / <code>gt</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>≤</code></td>
<td align="left"><code>\le</code></td>
<td align="left"><code>le</code> / <code>ge</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>⊔</code></td>
<td align="left"><code>\sup</code></td>
<td align="left"><code>sup</code></td>
<td align="left">a binary operator</td>
</tr>
<tr>
<td align="left"><code>⊓</code></td>
<td align="left"><code>\inf</code></td>
<td align="left"><code>inf</code></td>
<td align="left">a binary operator</td>
</tr>
<tr>
<td align="left"><code>⨆</code></td>
<td align="left"><code>\supr</code></td>
<td align="left"><code>iSup</code> / <code>biSup</code> / <code>ciSup</code></td>
<td align="left"><code>c</code> for &quot;conditionally complete&quot;</td>
</tr>
<tr>
<td align="left"><code>⨅</code></td>
<td align="left"><code>\infi</code></td>
<td align="left"><code>iInf</code> / <code>biInf</code> / <code>ciInf</code></td>
<td align="left"><code>c</code> for &quot;conditionally complete&quot;</td>
</tr>
<tr>
<td align="left"><code>⊥</code></td>
<td align="left"><code>\bot</code></td>
<td align="left"><code>bot</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>⊤</code></td>
<td align="left"><code>\top</code></td>
<td align="left"><code>top</code></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>The symbols <code>≤</code> and <code>&lt;</code> have a special naming convention.
In mathlib, we almost always use <code>≤</code> and <code>&lt;</code> instead of <code>≥</code> and <code>&gt;</code>, so we can use both <code>le</code>/<code>lt</code> and <code>ge</code>/<code>gt</code> for naming <code>≤</code> and <code>&lt;</code>.
There are a few reasons to use <code>ge</code>/<code>gt</code>:</p>
<ol>
<li>We use <code>ge</code>/<code>gt</code> if the arguments to <code>≤</code> or <code>&lt;</code> appear in different orders.
We use <code>le</code>/<code>lt</code> for the first occurrence of <code>≤</code>/<code>&lt;</code> in the theorem name,
and then <code>ge</code>/<code>gt</code> indicates that the arguments are swapped.</li>
<li>We use <code>ge</code>/<code>gt</code> to match the argument order of another relation, such as <code>=</code> or <code>≠</code>.</li>
<li>We use <code>ge</code>/<code>gt</code> to describe the <code>≤</code> or <code>&lt;</code> relation with its arguments swapped.</li>
<li>We use <code>ge</code>/<code>gt</code> if the second argument to <code>≤</code> or <code>&lt;</code> is 'more variable'.</li>
</ol>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="c1">-- follows rule 1</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">lt_iff_le_not_ge</span><span class="w"> </span><span class="o">[</span><span class="n">Preorder</span><span class="w"> </span><span class="n">α</span><span class="o">]</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">α</span><span class="o">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&lt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">↔</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">≤</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">∧</span><span class="w"> </span><span class="bp">¬</span><span class="n">b</span><span class="w"> </span><span class="bp">≤</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">not_le_of_gt</span><span class="w"> </span><span class="o">[</span><span class="n">Preorder</span><span class="w"> </span><span class="n">α</span><span class="o">]</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">α</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&lt;</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">¬</span><span class="n">b</span><span class="w"> </span><span class="bp">≤</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">LT.lt.not_ge</span><span class="w"> </span><span class="o">[</span><span class="n">Preorder</span><span class="w"> </span><span class="n">α</span><span class="o">]</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">α</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&lt;</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">¬</span><span class="n">b</span><span class="w"> </span><span class="bp">≤</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>

<span class="c1">-- follows rule 2</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">Eq.ge</span><span class="w"> </span><span class="o">[</span><span class="n">Preorder</span><span class="w"> </span><span class="n">α</span><span class="o">]</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">α</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">≤</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">ne_of_gt</span><span class="w"> </span><span class="o">[</span><span class="n">Preorder</span><span class="w"> </span><span class="n">α</span><span class="o">]</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">α</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&lt;</span><span class="w"> </span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">≠</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>

<span class="c1">-- follows rule 3</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">ge_trans</span><span class="w"> </span><span class="o">[</span><span class="n">Preorder</span><span class="w"> </span><span class="n">α</span><span class="o">]</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">α</span><span class="o">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">≤</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">→</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="bp">≤</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">→</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="bp">≤</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>

<span class="c1">-- follows rule 4</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">le_of_forall_gt</span><span class="w"> </span><span class="o">[</span><span class="n">LinearOrder</span><span class="w"> </span><span class="n">α</span><span class="o">]</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">α</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">H</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">∀</span><span class="w"> </span><span class="o">(</span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">α</span><span class="o">),</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&lt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="bp">→</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&lt;</span><span class="w"> </span><span class="n">c</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">≤</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
</code></pre></div>
</div>

<h3 id="dots" class="markdown-heading">Dots <a class="hover-link" href="#dots">#</a></h3>
<p>Dots are used for namespaces, and also for automatically generated names
like recursors, eliminators and structure projections. They can also be
introduced manually, for example, where projector notation is
useful. Thus they are used in all of the following situations.</p>
<p>Note: since <code>And</code> is a (binary function into) <code>Prop</code>, it is <code>UpperCamelCased</code>
according to the naming conventions, and so its namespace is <code>And.*</code>.
This may seem at odds with the dictionary <code>∧</code> --&gt; <code>and</code> but because
upper camel case types get lower camel cased when they appear in names
of theorems, the dictionary is still valid in general. The same applies to
<code>Or</code>, <code>Iff</code>, <code>Not</code>, <code>Eq</code>, <code>HEq</code>, <code>Ne</code>, etc.</p>
<p>Intro, elim, and destruct rules for logical connectives, whether they
are automatically generated or not:</p>
<ul>
<li><code>And.intro</code></li>
<li><code>And.elim</code></li>
<li><code>And.left</code></li>
<li><code>And.right</code></li>
<li><code>Or.inl</code></li>
<li><code>Or.inr</code></li>
<li><code>Or.intro_left</code></li>
<li><code>Or.intro_right</code></li>
<li><code>Iff.intro</code></li>
<li><code>Iff.elim</code></li>
<li><code>Iff.mp</code></li>
<li><code>Iff.mpr</code></li>
<li><code>Not.intro</code></li>
<li><code>Not.elim</code></li>
<li><code>Eq.refl</code></li>
<li><code>Eq.rec</code></li>
<li><code>Eq.subst</code></li>
<li><code>HEq.refl</code></li>
<li><code>HEq.rec</code></li>
<li><code>HEq.subst</code></li>
<li><code>Exists.intro</code></li>
<li><code>Exists.elim</code></li>
<li><code>True.intro</code></li>
<li><code>False.elim</code></li>
</ul>
<p>Places where projection notation is useful, for example:</p>
<ul>
<li><code>And.symm</code></li>
<li><code>Or.symm</code></li>
<li><code>Or.resolve_left</code></li>
<li><code>Or.resolve_right</code></li>
<li><code>Eq.symm</code></li>
<li><code>Eq.trans</code></li>
<li><code>HEq.symm</code></li>
<li><code>HEq.trans</code></li>
<li><code>Iff.symm</code></li>
<li><code>Iff.refl</code></li>
</ul>
<p>It is useful to use dot notation even for types which are not
inductive types. For instance, we use:</p>
<ul>
<li><code>LE.trans</code></li>
<li><code>LT.trans_le</code></li>
<li><code>LE.trans_lt</code></li>
</ul>
<h3 id="axiomatic-descriptions" class="markdown-heading">Axiomatic descriptions <a class="hover-link" href="#axiomatic-descriptions">#</a></h3>
<p>Some theorems are described using axiomatic names, rather than
describing their conclusions.</p>
<ul>
<li><code>def</code>  (for unfolding a definition)</li>
<li><code>refl</code></li>
<li><code>irrefl</code></li>
<li><code>symm</code></li>
<li><code>trans</code></li>
<li><code>antisymm</code></li>
<li><code>asymm</code></li>
<li><code>congr</code></li>
<li><code>comm</code></li>
<li><code>assoc</code></li>
<li><code>left_comm</code></li>
<li><code>right_comm</code></li>
<li><code>mul_left_cancel</code></li>
<li><code>mul_right_cancel</code></li>
<li><code>inj</code>  (injective)</li>
</ul>
<h3 id="variable-conventions" class="markdown-heading">Variable conventions <a class="hover-link" href="#variable-conventions">#</a></h3>
<ul>
<li><code>u</code>, <code>v</code>, <code>w</code>, ... for universes</li>
<li><code>α</code>, <code>β</code>, <code>γ</code>, ... for generic types</li>
<li><code>a</code>, <code>b</code>, <code>c</code>, ... for propositions</li>
<li><code>x</code>, <code>y</code>, <code>z</code>, ... for elements of a generic type</li>
<li><code>h</code>, <code>h₁</code>, ...     for assumptions</li>
<li><code>p</code>, <code>q</code>, <code>r</code>, ... for predicates and relations</li>
<li><code>s</code>, <code>t</code>, ...      for lists</li>
<li><code>s</code>, <code>t</code>, ...      for sets</li>
<li><code>m</code>, <code>n</code>, <code>k</code>, ... for natural numbers</li>
<li><code>i</code>, <code>j</code>, <code>k</code>, ... for integers</li>
</ul>
<p>Types with a mathematical content are expressed with the usual
mathematical notation, often with an upper case letter
(<code>G</code> for a group, <code>R</code> for a ring, <code>K</code> or <code>𝕜</code> for a field, <code>E</code> for a vector space, ...).
This convention is not followed in older files, where greek letters are used
for all types. Pull requests renaming type variables in these files are welcome.</p>
<h2 id="identifiers-and-theorem-names" class="markdown-heading">Identifiers and theorem names <a class="hover-link" href="#identifiers-and-theorem-names">#</a></h2>
<p>We adopt the following naming guidelines to make it easier for users
to guess the name of a theorem or find it using tab completion. Common
&quot;axiomatic&quot; properties of an operation like conjunction or
disjunction are put in a namespace that begins with the name of the
operation:</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="n">Mathlib.Logic.Basic</span>

<span class="k">#check</span><span class="w"> </span><span class="n">And.comm</span>
<span class="k">#check</span><span class="w"> </span><span class="n">Or.comm</span>
</code></pre></div>
</div>

<p>In particular, this includes <code>intro</code> and <code>elim</code> operations for logical
connectives, and properties of relations:</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="n">Mathlib.Logic.Basic</span>

<span class="k">#check</span><span class="w"> </span><span class="n">And.intro</span>
<span class="k">#check</span><span class="w"> </span><span class="n">And.elim</span>
<span class="k">#check</span><span class="w"> </span><span class="n">Or.intro_left</span>
<span class="k">#check</span><span class="w"> </span><span class="n">Or.intro_right</span>
<span class="k">#check</span><span class="w"> </span><span class="n">Or.elim</span>

<span class="k">#check</span><span class="w"> </span><span class="n">Eq.refl</span>
<span class="k">#check</span><span class="w"> </span><span class="n">Eq.symm</span>
<span class="k">#check</span><span class="w"> </span><span class="n">Eq.trans</span>
</code></pre></div>
</div>

<p>Note however we do not do this for axiomatic logical and arithmetic operations.</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="n">Mathlib.Algebra.Group.Basic</span>

<span class="k">#check</span><span class="w"> </span><span class="n">and_assoc</span>
<span class="k">#check</span><span class="w"> </span><span class="n">mul_comm</span>
<span class="k">#check</span><span class="w"> </span><span class="n">mul_assoc</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">mul_left_cancel</span><span class="w">  </span><span class="c1">-- multiplication is left cancelative</span>
</code></pre></div>
</div>

<p>For the most part, however, we rely on descriptive names. Often the
name of theorem simply describes the conclusion:</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="n">Mathlib.Algebra.Ring.Basic</span>
<span class="kn">open</span><span class="w"> </span><span class="n">Nat</span>
<span class="k">#check</span><span class="w"> </span><span class="n">succ_ne_zero</span>
<span class="k">#check</span><span class="w"> </span><span class="n">mul_zero</span>
<span class="k">#check</span><span class="w"> </span><span class="n">mul_one</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">sub_add_eq_add_sub</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">le_iff_lt_or_eq</span>
</code></pre></div>
</div>

<p>If only a prefix of the description is enough to convey the meaning,
the name may be made even shorter:</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="n">Mathlib.Algebra.Ring.Basic</span>

<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">neg_neg</span>
<span class="k">#check</span><span class="w"> </span><span class="n">Nat.pred_succ</span>
</code></pre></div>
</div>

<p>When an operation is written as infix, the theorem names follow
suit. For example, we write <code>neg_mul_neg</code> rather than <code>mul_neg_neg</code> to
describe the pattern <code>-a * -b</code>.</p>
<p>Sometimes, to disambiguate the name of theorem or better convey the
intended reference, it is necessary to describe some of the
hypotheses. The word &quot;of&quot; is used to separate these hypotheses:</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="n">Mathlib.Algebra.Order.Monoid.Lemmas</span>

<span class="kn">open</span><span class="w"> </span><span class="n">Nat</span>

<span class="k">#check</span><span class="w"> </span><span class="n">lt_of_succ_le</span>
<span class="k">#check</span><span class="w"> </span><span class="n">lt_of_not_ge</span>
<span class="k">#check</span><span class="w"> </span><span class="n">lt_of_le_of_ne</span>
<span class="k">#check</span><span class="w"> </span><span class="n">add_lt_add_of_lt_of_le</span>
</code></pre></div>
</div>

<p>The hypotheses are listed in the order they appear, <em>not</em> reverse
order. For example, the theorem <code>A → B → C</code> would be named
<code>C_of_A_of_B</code>.</p>
<p>Sometimes abbreviations or alternative descriptions are easier to work
with. For example, we use <code>pos</code>, <code>neg</code>, <code>nonpos</code>, <code>nonneg</code> rather than
<code>zero_lt</code>, <code>lt_zero</code>, <code>le_zero</code>, and <code>zero_le</code>.</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="n">Mathlib.Algebra.Order.Monoid.Lemmas</span>
<span class="kn">import</span><span class="w"> </span><span class="n">Mathlib.Algebra.Order.Ring.Lemmas</span>

<span class="kn">open</span><span class="w"> </span><span class="n">Nat</span>

<span class="k">#check</span><span class="w"> </span><span class="n">mul_pos</span>
<span class="k">#check</span><span class="w"> </span><span class="n">mul_nonpos_of_nonneg_of_nonpos</span>
<span class="k">#check</span><span class="w"> </span><span class="n">add_lt_of_lt_of_nonpos</span>
<span class="k">#check</span><span class="w"> </span><span class="n">add_lt_of_nonpos_of_lt</span>
</code></pre></div>
</div>

<p>These conventions are not perfect. They cannot distinguish compound
expressions up to associativity, or repeated occurrences in a
pattern. For that, we make do as best we can. For example, <code>a + b - b = a</code>
could be named either <code>add_sub_self</code> or <code>add_sub_cancel</code>.</p>
<p>Sometimes the word &quot;left&quot; or &quot;right&quot; is helpful to describe variants
of a theorem.</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="n">Mathlib.Algebra.Order.Monoid.Lemmas</span>
<span class="kn">import</span><span class="w"> </span><span class="n">Mathlib.Algebra.Order.Ring.Lemmas</span>

<span class="kn">open</span><span class="w"> </span><span class="n">Nat</span>

<span class="k">#check</span><span class="w"> </span><span class="n">add_le_add_left</span>
<span class="k">#check</span><span class="w"> </span><span class="n">add_le_add_right</span>
<span class="k">#check</span><span class="w"> </span><span class="n">le_of_mul_le_mul_left</span>
<span class="k">#check</span><span class="w"> </span><span class="n">le_of_mul_le_mul_right</span>
</code></pre></div>
</div>

<p>When referring to a namespaced definition in a lemma name not in the
same namespace, the definition should have its namespace removed. If
the definition name is unambiguous without its namespace, it can be
used as is. Else, the namespace is prepended back to it in
<code>lowerCamelCase</code>. This is to ensure that <code>_</code>-separated strings in a
lemma name correspond to a definition name or connective.</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="n">Mathlib.Data.Int.Cast.Basic</span>
<span class="kn">import</span><span class="w"> </span><span class="n">Mathlib.Data.Nat.Cast.Basic</span>
<span class="kn">import</span><span class="w"> </span><span class="n">Mathlib.Topology.Constructions</span>

<span class="k">#check</span><span class="w"> </span><span class="n">Prod.fst</span>
<span class="k">#check</span><span class="w"> </span><span class="n">continuous_fst</span>

<span class="k">#check</span><span class="w"> </span><span class="n">Nat.cast</span>
<span class="k">#check</span><span class="w"> </span><span class="n">map_natCast</span>
<span class="k">#check</span><span class="w"> </span><span class="n">Int.cast_natCast</span>
</code></pre></div>
</div>

<h2 id="naming-of-structural-lemmas" class="markdown-heading">Naming of structural lemmas <a class="hover-link" href="#naming-of-structural-lemmas">#</a></h2>
<p>We are trying to standardize certain naming patterns for structural lemmas.</p>
<h3 id="extensionality" class="markdown-heading">Extensionality <a class="hover-link" href="#extensionality">#</a></h3>
<p>A lemma of the form <code>(∀ x, f x = g x) → f = g</code> should be named <code>.ext</code>,
and labelled with the <code>@[ext]</code> attribute.
Often this type of lemma can be generated automatically by putting the
<code>@[ext]</code> attribute on a structure.
(However an automatically generated lemma will always be written in terms
of the structure projections, and often there is a better statement,
e.g. using coercions, that should be written by hand then marked with <code>@[ext]</code>.)</p>
<p>A lemma of the form <code>f = g ↔ ∀ x, f x = g x</code> should be named <code>.ext_iff</code>.</p>
<h3 id="injectivity" class="markdown-heading">Injectivity <a class="hover-link" href="#injectivity">#</a></h3>
<p>Where possible, injectivity lemmas should be written in terms of an
<code>Function.Injective f</code> conclusion which use the full word <code>injective</code>, typically as <code>f_injective</code>.
The form <code>injective_f</code> still appears often in mathlib.</p>
<p>In addition to these, a variant should usually be provided as a bidirectional implication,
e.g. as <code>f x = f y ↔ x = y</code>, which can be obtained from <code>Function.Injective.eq_iff</code>.
Such lemmas should be named <code>f_inj</code>
(although if they are in an appropriate namespace <code>.inj</code> is good too).
Bidirectional injectivity lemmas are often good candidates for <code>@[simp]</code>.
There are still many unidirectional implications named <code>inj</code> in mathlib,
and it is reasonable to update and replace these as you come across them.</p>
<p>Note however that constructors for inductive types have
automatically generated unidirectional implications, named <code>.inj</code>,
and there is no intention to change this.
When such an automatically generated lemma already exists,
and a bidirectional lemma is needed, it may be named <code>.inj_iff</code>.</p>
<p>An injectivity lemma that uses &quot;left&quot; or &quot;right&quot; should refer to the
argument that &quot;changes&quot;. For example, a lemma with the statement
<code>a - b = a - c ↔ b = c</code> could be called <code>sub_right_inj</code>.</p>
<h3 id="induction-and-recursion-principles" class="markdown-heading">Induction and recursion principles <a class="hover-link" href="#induction-and-recursion-principles">#</a></h3>
<p>Induction/recursion principles are ways to construct data or proofs for all elements of some type <code>T</code>,
by providing ways to construct this data or proof in more constrained specific contexts.
These principles should be phrased to accept a <code>motive</code> argument,
which declares what property we are proving or what data we are constructing for all <code>T</code>.
When the motive eliminates into <code>Prop</code>, it is an induction principle, and the name should contain
<code>induction</code>. On the other hand, when the motive eliminates into <code>Sort u</code> or <code>Type u</code>,
it is a recursive principle, and the name should contain <code>rec</code> instead.</p>
<p>Additionally, the name should contain <code>on</code> iff in the argument order, the value comes before the constructions.</p>
<p>The following table summarizes these naming conventions:</p>
<table>
<thead>
<tr>
<th align="left">motive eliminates into:</th>
<th align="left"><code>Prop</code></th>
<th align="left"><code>Sort u</code> or <code>Type u</code></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">value first</td>
<td align="left"><code>T.induction_on</code></td>
<td align="left"><code>T.recOn</code></td>
</tr>
<tr>
<td align="left">constructions first</td>
<td align="left"><code>T.induction</code></td>
<td align="left"><code>T.rec</code></td>
</tr>
</tbody>
</table>
<p>Variation on these names are acceptable when necessary (e.g. for disambiguation).</p>
<h3 id="predicates-as-suffixes" class="markdown-heading">Predicates as suffixes <a class="hover-link" href="#predicates-as-suffixes">#</a></h3>
<p>Most predicates should be added as prefixes. Eg <code>IsClosed (Icc a b)</code> should be called <code>isClosed_Icc</code>, not <code>Icc_isClosed</code>.</p>
<p>Some widely used predicates don't follow this rule. Those are the predicates that are analogous to an atom already suffixed by the naming convention. Here is a non-exhaustive list:</p>
<ul>
<li>We use <code>_inj</code> for <code>f a = f b ↔ a = b</code>, so we also use <code>_injective</code> for <code>Injective f</code>, <code>_surjective</code> for <code>Surjective f</code>, <code>_bijective</code> for <code>Bijective f</code>...</li>
<li>We use <code>_mono</code> for <code>a ≤ b → f a ≤ f b</code> and <code>_anti</code> for <code>a ≤ b → f b ≤ f a</code>, so we also use <code>_monotone</code> for <code>Monotone f</code>, <code>_antitone</code> for <code>Antitone f</code>, <code>_strictMono</code> for <code>StrictMono f</code>, <code>_strictAnti</code> for <code>StrictAnti f</code>, etc...</li>
</ul>
<p>Predicates as suffixes can be preceded by either <code>_left</code> or <code>_right</code> to signify
that a binary operation is left- or right-monotone.
For example, <code>mul_left_monotone : Monotone (· * a)</code> proves left-monotonicity of multiplication
and not monotonicity of left-multiplication.</p>
<h3 id="prop-valued-classes" class="markdown-heading">Prop-valued classes <a class="hover-link" href="#prop-valued-classes">#</a></h3>
<p>Mathlib has many <code>Prop</code>-valued classes and other definitions. For example &quot;let $R$ be a
topological ring&quot; is written <code>variable (R : Type*) [Ring R] [TopologicalSpace R] [IsTopologicalRing R]</code>
and &quot;let $G$ be a group and let $H$ be a normal subgroup&quot; is written
<code>variable (G : Type*) [Group G] (H : Subgroup G) [Normal H]</code>. Here <code>IsTopologicalRing R</code>
and <code>Normal H</code> are not extra data, but are extra assumptions on data we have already.</p>
<p>Mathlib currently strives towards the following naming convention for these <code>Prop</code>-valued
classes. If the class is a noun then its name should begin with <code>Is</code>. If however is it an adjective
then its name does not need to begin with an <code>Is</code>. So for example <code>IsNormal</code> would be acceptable
for the &quot;normal subgroup&quot; typeclass, but <code>Normal</code> is also fine; we might say &quot;assume the subgroup
<code>H</code> is normal&quot; in informal language. However <code>IsTopologicalRing</code> is
preferred for the &quot;topological ring&quot; typeclass, as we do not say &quot;assume the ring <code>R</code> is
topological&quot; informally.</p>
<h3 id="unexpanded-and-expanded-forms-of-functions" class="markdown-heading">Unexpanded and expanded forms of functions <a class="hover-link" href="#unexpanded-and-expanded-forms-of-functions">#</a></h3>
<p>The multiplication of two functions <code>f</code> and <code>g</code> can be denoted equivalently as
<code>f * g</code> or <code>fun x ↦ f x * g x</code>. These expressions are definitionally equal, but not syntactically (and they don't
share the same key in indexing trees), which means that tools like <code>rw</code>, <code>fun_prop</code> or <code>apply?</code>
will not use a theorem with one form on an expression with the other form. Therefore, it is
sometimes convenient to have variants of the statements using the two forms. If one needs to
distinguish between them, statements involving the first unexpanded form are written using just <code>mul</code>,
while statements using the second expanded form should instead use <code>fun_mul</code>. If there is no need to
disambiguate because a lemma is given using only the expanded form, the prefix <code>fun_</code> is not required.</p>
<p>For instance, the fact that the multiplication of two continuous functions is continuous is</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">theorem</span><span class="w"> </span><span class="n">Continuous.fun_mul</span><span class="w"> </span><span class="o">(</span><span class="n">hf</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Continuous</span><span class="w"> </span><span class="n">f</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">hg</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Continuous</span><span class="w"> </span><span class="n">g</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Continuous</span><span class="w"> </span><span class="k">fun</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">↦</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">x</span>
</code></pre></div>
</div>

<p>and</p>
<div class="codehilite"><div class="codehilite"><pre><span></span><code><span class="kd">theorem</span><span class="w"> </span><span class="n">Continuous.mul</span><span class="w"> </span><span class="o">(</span><span class="n">hf</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Continuous</span><span class="w"> </span><span class="n">f</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">hg</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Continuous</span><span class="w"> </span><span class="n">g</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Continuous</span><span class="w"> </span><span class="o">(</span><span class="n">f</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">g</span><span class="o">)</span>
</code></pre></div>
</div>

<p>Both theorems deserve tagging with the <code>fun_prop</code> attribute.</p>
<p>The same goes for addition, subtraction, negation, powers and compositions of functions.</p>

  </main>

    <nav id="navbar" class="d-md-block bg-light sidebar collapse navbar-light pb-4">
      <div class="d-none d-md-block mt-4"><a class="navbar-brand" href="https://leanprover-community.github.io/index.html">Lean Community</a></div>
      
        <h6 class="sidebar-heading mt-4">Community</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover.zulipchat.com/">Zulip chat</a></li>
        
          <li class="nav-item col-12"><a href="https://github.com/leanprover-community/mathlib4">GitHub</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/blog">Blog</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/meet.html">Community information</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/meet.html#community-guidelines">Community guidelines</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/teams.html">Teams</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/papers.html">Papers about Lean</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/lean_projects.html">Projects using Lean</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/teaching/index.html">Teaching using Lean</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/events.html">Events</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Use Lean</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://live.lean-lang.org/">Online version (no installation)</a></li>
        
          <li class="nav-item col-12"><a href="https://docs.lean-lang.org/lean4/doc/quickstart.html">Install Lean</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/get_started.html">More options</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Documentation</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/learn.html">Learning resources (start here)</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mathlib4_docs">API documentation</a></li>
        
          <li class="nav-item col-12"><a href="https://loogle.lean-lang.org/">Declaration search (Loogle)</a></li>
        
          <li class="nav-item col-12"><a href="https://lean-lang.org/doc/reference/latest/">Language reference</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mathlib-manual/html-multi/">Tactic list</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/extras/calc.html">Calc mode</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/extras/conv.html">Conv mode</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/extras/simp.html">Simplifier</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/extras/well_founded_recursion.html">Well-founded recursion</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/extras/speedup.html">Speeding up Lean files</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/extras/pitfalls.html">Pitfalls and common mistakes</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mwe.html">About MWEs</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/glossary.html">Glossary</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Library overviews</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mathlib-overview.html">Library overview</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/undergrad.html">Undergraduate maths</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/100.html">Wiedijk's 100 theorems</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/1000.html">1000+ theorems</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Theories</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/naturals.html">Natural Numbers</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/linear_algebra.html">Linear Algebra</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/sets.html">Sets and finite sets</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/topology.html">Topology</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/category_theory.html">Category Theory</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Contributing</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/index.html">Pull request lifecycle</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/git.html">Git Guide for Mathlib4 Contributors</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/naming.html">Naming conventions</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/style.html">Code style guideline</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/doc.html">Documentation style</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/commit.html">Commit conventions</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/pr-review.html">Pull request review guide</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mathlib_stats.html">Contribution statistics</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/tags_and_branches.html">Tags and branches</a></li>
        </ul>
      
    </nav>

</div>


  <nav class="footer navbar navbar-expand-lg navbar-light bg-light justify-content-end">
  <ul class="nav">
    <li class="nav-item">
      <a class="nav-link active" href="https://github.com/leanprover-community/leanprover-community.github.io/blob/lean4/templates/contribute/naming.md">Suggest edits to this page on GitHub</a>
    </li>
  </ul>
  </nav>

    <script src="https://code.jquery.com/jquery-3.5.1.min.js"
      integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
      crossorigin="anonymous"></script>
    <script src="https://leanprover-community.github.io//js/bootstrap.min.js"></script>
    <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
      mermaid.initialize({ startOnLoad: true });
    </script>
    
  </body>
</html>