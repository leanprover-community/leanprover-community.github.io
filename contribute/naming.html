<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="https://leanprover-community.github.io//css/lean.css" >
  <link rel="shortcut icon" href="https://leanprover-community.github.io//img/favicon.ico">
<link href="https://fonts.googleapis.com/css2?family=Merriweather&family=Open+Sans&family=Source+Code+Pro:wght@400;600&display=swap" rel="stylesheet">
    

	<script>
                function buildShortcutsForStructures(names) {
                        const o = {}
                        names.forEach(name => o[name] = `\\mathbb\{${name}\}`)
                        return o
                }
		MathJax = {
			  tex: {
                                  macros: {
                                          ...buildShortcutsForStructures(["R", "Q", "Z", "N", "C"]),
                                  },
				      inlineMath: [['$', '$'], ['\\(', '\\)']]
				    },
		};
	</script>
	<script type="text/javascript" id="MathJax-script" async
		  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
	</script>

	<title>Mathlib naming conventions</title>
  </head>
  <body>
  <nav class="navbar navbar-expand-lg navbar-light bg-gradient-light d-md-none">
    <div class="d-flex flex-grow-1">
		<a class="navbar-brand" href="https://leanprover-community.github.io/index.html">Lean Community
    </a>
    </div>

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </nav>

<div id="mainbox">

  <main>
	  
<h1 id="mathlib-naming-conventions" class="markdown-heading">Mathlib naming conventions <a class="hover-link" href="#mathlib-naming-conventions">#</a></h1>
<p>Author: <a href="http://www.andrew.cmu.edu/user/avigad">Jeremy Avigad</a></p>
<h3 id="names-of-symbols" class="markdown-heading">Names of symbols <a class="hover-link" href="#names-of-symbols">#</a></h3>
<p>When translating the statements of theorems into words, this dictionary is often used:</p>
<p>Logic:</p>
<table>
<thead>
<tr>
<th align="left">symbol</th>
<th align="left">shortcut</th>
<th align="left">name</th>
<th align="left">notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>‚à®</code></td>
<td align="left"><code>\or</code></td>
<td align="left"><code>or</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‚àß</code></td>
<td align="left"><code>\and</code></td>
<td align="left"><code>and</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‚Üí</code></td>
<td align="left"><code>\r</code></td>
<td align="left"><code>of</code></td>
<td align="left">the conclusion is stated first and the hypotheses are often omitted</td>
</tr>
<tr>
<td align="left"><code>‚Üî</code></td>
<td align="left"><code>\iff</code></td>
<td align="left"><code>iff</code></td>
<td align="left">sometimes omitted along with the right hand side of the iff</td>
</tr>
<tr>
<td align="left"><code>¬¨</code></td>
<td align="left"><code>\n</code></td>
<td align="left"><code>not</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‚àÉ</code></td>
<td align="left"><code>\ex</code></td>
<td align="left"><code>exists</code> / <code>bex</code></td>
<td align="left"><code>bex</code> stands for &quot;bounded exists&quot;</td>
</tr>
<tr>
<td align="left"><code>‚àÄ</code></td>
<td align="left"><code>\fo</code></td>
<td align="left"><code>all</code> / <code>forall</code> / <code>ball</code></td>
<td align="left"><code>ball</code> stands for &quot;bounded forall&quot;</td>
</tr>
<tr>
<td align="left"><code>=</code></td>
<td align="left"></td>
<td align="left"><code>eq</code></td>
<td align="left">often omitted</td>
</tr>
<tr>
<td align="left"><code>‚â†</code></td>
<td align="left"><code>\ne</code></td>
<td align="left"><code>ne</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‚àò</code></td>
<td align="left"><code>\o</code></td>
<td align="left"><code>comp</code></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>Set:</p>
<table>
<thead>
<tr>
<th align="left">symbol</th>
<th align="left">shortcut</th>
<th align="left">name</th>
<th align="left">notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>‚àà</code></td>
<td align="left"><code>\in</code></td>
<td align="left"><code>mem</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‚à™</code></td>
<td align="left"><code>\cup</code></td>
<td align="left"><code>union</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‚à©</code></td>
<td align="left"><code>\cap</code></td>
<td align="left"><code>inter</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‚ãÉ</code></td>
<td align="left"><code>\bigcup</code></td>
<td align="left"><code>Union</code> / <code>bUnion</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‚ãÇ</code></td>
<td align="left"><code>\bigcap</code></td>
<td align="left"><code>Inter</code> / <code>bInter</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\</code></td>
<td align="left"><code>\\</code></td>
<td align="left"><code>sdiff</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>·∂ú</code></td>
<td align="left"><code>\^c</code></td>
<td align="left"><code>compl</code></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>Algebra:</p>
<table>
<thead>
<tr>
<th align="left">symbol</th>
<th align="left">shortcut</th>
<th align="left">name</th>
<th align="left">notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>0</code></td>
<td align="left"></td>
<td align="left"><code>zero</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>+</code></td>
<td align="left"></td>
<td align="left"><code>add</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>-</code></td>
<td align="left"></td>
<td align="left"><code>neg</code> / <code>sub</code></td>
<td align="left"><code>neg</code> for the unary function, <code>sub</code> for the binary function</td>
</tr>
<tr>
<td align="left"><code>1</code></td>
<td align="left"></td>
<td align="left"><code>one</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>*</code></td>
<td align="left"></td>
<td align="left"><code>mul</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>^</code></td>
<td align="left"></td>
<td align="left"><code>pow</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>/</code></td>
<td align="left"></td>
<td align="left"><code>div</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‚Ä¢</code></td>
<td align="left"><code>\bu</code></td>
<td align="left"><code>smul</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‚Åª¬π</code></td>
<td align="left"><code>\-1</code></td>
<td align="left"><code>inv</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‚à£</code></td>
<td align="left"><code>\|</code></td>
<td align="left"><code>dvd</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‚àë</code></td>
<td align="left"><code>\sum</code></td>
<td align="left"><code>sum</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‚àè</code></td>
<td align="left"><code>\prod</code></td>
<td align="left"><code>prod</code></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>Lattices:</p>
<table>
<thead>
<tr>
<th align="left">symbol</th>
<th align="left">shortcut</th>
<th align="left">name</th>
<th align="left">notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>&lt;</code></td>
<td align="left"></td>
<td align="left"><code>lt</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‚â§</code></td>
<td align="left"><code>\le</code></td>
<td align="left"><code>le</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‚äî</code></td>
<td align="left"><code>\sup</code></td>
<td align="left"><code>sup</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‚äì</code></td>
<td align="left"><code>\inf</code></td>
<td align="left"><code>inf</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‚®Ü</code></td>
<td align="left"><code>\Sup</code></td>
<td align="left"><code>Sup</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‚®Ö</code></td>
<td align="left"><code>\Inf</code></td>
<td align="left"><code>Inf</code></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<h3 id="general-conventions" class="markdown-heading">General conventions <a class="hover-link" href="#general-conventions">#</a></h3>
<p>Identifiers are generally lower case with underscores. For the most
part, we rely on descriptive names. Often the name of theorem simply
describes the conclusion:</p>
<ul>
<li><code>succ_ne_zero</code></li>
<li><code>mul_zero</code></li>
<li><code>mul_one</code></li>
<li><code>sub_add_eq_add_sub</code></li>
<li><code>le_iff_lt_or_eq</code></li>
</ul>
<p>If only a prefix of the description is enough to convey the meaning,
the name may be made even shorter:</p>
<ul>
<li><code>neg_neg</code></li>
<li><code>pred_succ</code></li>
</ul>
<p>Sometimes, to disambiguate the name of theorem or better convey the
intended reference, it is necessary to describe some of the
hypotheses. The word &quot;of&quot; is used to separate these hypotheses:</p>
<ul>
<li><code>lt_of_succ_le</code></li>
<li><code>lt_of_not_ge</code></li>
<li><code>lt_of_le_of_ne</code></li>
<li><code>add_lt_add_of_lt_of_le</code></li>
</ul>
<p>Sometimes abbreviations or alternative descriptions are easier to work
with. For example, we use <code>pos</code>, <code>neg</code>, <code>nonpos</code>, <code>nonneg</code> rather than
<code>zero_lt</code>, <code>lt_zero</code>, <code>le_zero</code>, and <code>zero_le</code>.</p>
<ul>
<li><code>mul_pos</code></li>
<li><code>mul_nonpos_of_nonneg_of_nonpos</code></li>
<li><code>add_lt_of_lt_of_nonpos</code></li>
<li><code>add_lt_of_nonpos_of_lt</code></li>
</ul>
<p>Sometimes the word &quot;left&quot; or &quot;right&quot; is helpful to describe variants
of a theorem.</p>
<ul>
<li><code>add_le_add_left</code></li>
<li><code>add_le_add_right</code></li>
<li><code>le_of_mul_le_mul_left</code></li>
<li><code>le_of_mul_le_mul_right</code></li>
</ul>
<p>An injectivity lemma that uses &quot;left&quot; or &quot;right&quot; should refer to the
argument that &quot;changes&quot;. For example, a lemma with the statement
<code>a - b = a - c ‚Üî b = c</code> could be called <code>sub_right_inj</code>.</p>
<p>We can also use the word &quot;self&quot; to indicate a repeated argument:</p>
<ul>
<li><code>mul_inv_self</code></li>
<li><code>neg_add_self</code></li>
</ul>
<h3 id="dots" class="markdown-heading">Dots <a class="hover-link" href="#dots">#</a></h3>
<p>Dots are used for namespaces, and also for automatically generated names
like recursors, eliminators and structure projections. They can also be
introduced manually, for example, where projector notation is
useful. Thus they are used in all of the following situations.</p>
<p>Intro, elim, and destruct rules for logical connectives, whether they
are automatically generated or not:</p>
<ul>
<li><code>and.intro</code></li>
<li><code>and.elim</code></li>
<li><code>and.left</code></li>
<li><code>and.right</code></li>
<li><code>or.inl</code></li>
<li><code>or.inr</code></li>
<li><code>or.intro_left</code></li>
<li><code>or.intro_right</code></li>
<li><code>iff.intro</code></li>
<li><code>iff.elim</code></li>
<li><code>iff.mp</code></li>
<li><code>iff.mpr</code></li>
<li><code>not.intro</code></li>
<li><code>not.elim</code></li>
<li><code>eq.refl</code></li>
<li><code>eq.rec</code></li>
<li><code>eq.subst</code></li>
<li><code>heq.refl</code></li>
<li><code>heq.rec</code></li>
<li><code>heq.subst</code></li>
<li><code>exists.intro</code></li>
<li><code>exists.elim</code></li>
<li><code>true.intro</code></li>
<li><code>false.elim</code></li>
</ul>
<p>Places where projection notation is useful, for example:</p>
<ul>
<li><code>and.symm</code></li>
<li><code>or.symm</code></li>
<li><code>or.resolve_left</code></li>
<li><code>or.resolve_right</code></li>
<li><code>eq.symm</code></li>
<li><code>eq.trans</code></li>
<li><code>heq.symm</code></li>
<li><code>heq.trans</code></li>
<li><code>iff.symm</code></li>
<li><code>iff.refl</code></li>
</ul>
<p>It is useful to use dot notation even for types which are not
inductive types. For instance, we use:</p>
<ul>
<li><code>le.trans</code></li>
<li><code>lt.trans_le</code></li>
<li><code>le.trans_lt</code></li>
</ul>
<h3 id="axiomatic-descriptions" class="markdown-heading">Axiomatic descriptions <a class="hover-link" href="#axiomatic-descriptions">#</a></h3>
<p>Some theorems are described using axiomatic names, rather than
describing their conclusions.</p>
<ul>
<li><code>def</code>  (for unfolding a definition)</li>
<li><code>refl</code></li>
<li><code>irrefl</code></li>
<li><code>symm</code></li>
<li><code>trans</code></li>
<li><code>antisymm</code></li>
<li><code>asymm</code></li>
<li><code>congr</code></li>
<li><code>comm</code></li>
<li><code>assoc</code></li>
<li><code>left_comm</code></li>
<li><code>right_comm</code></li>
<li><code>mul_left_cancel</code></li>
<li><code>mul_right_cancel</code></li>
<li><code>inj</code>  (injective)</li>
</ul>
<h3 id="variable-conventions" class="markdown-heading">Variable conventions <a class="hover-link" href="#variable-conventions">#</a></h3>
<ul>
<li><code>u</code>, <code>v</code>, <code>w</code>, ... for universes</li>
<li><code>Œ±</code>, <code>Œ≤</code>, <code>Œ≥</code>, ... for generic types</li>
<li><code>a</code>, <code>b</code>, <code>c</code>, ... for propositions</li>
<li><code>x</code>, <code>y</code>, <code>z</code>, ... for elements of a generic type</li>
<li><code>h</code>, <code>h‚ÇÅ</code>, ...     for assumptions</li>
<li><code>p</code>, <code>q</code>, <code>r</code>, ... for predicates and relations</li>
<li><code>s</code>, <code>t</code>, ...      for lists</li>
<li><code>s</code>, <code>t</code>, ...      for sets</li>
<li><code>m</code>, <code>n</code>, <code>k</code>, ... for natural numbers</li>
<li><code>i</code>, <code>j</code>, <code>k</code>, ... for integers</li>
</ul>
<p>Types with a mathematical content are expressed with the usual
mathematical notation, often with an upper case letter
(<code>G</code> for a group, <code>R</code> for a ring, <code>K</code> or <code>ùïú</code> for a field, <code>E</code> for a vector space, ...).
This convention is not followed in older files, where greek letters are used
for all types. Pull requests renaming type variables in these files are welcome.</p>
<h3 id="names-for-symbols" class="markdown-heading">Names for symbols <a class="hover-link" href="#names-for-symbols">#</a></h3>
<ul>
<li><code>imp</code>: implication</li>
<li><code>forall</code></li>
<li><code>exists</code></li>
<li><code>ball</code>: bounded forall</li>
<li><code>bex</code>: bounded exists</li>
</ul>
<h2 id="identifiers-and-theorem-names" class="markdown-heading">Identifiers and theorem names <a class="hover-link" href="#identifiers-and-theorem-names">#</a></h2>
<p>We generally use lower case with underscores for theorem names and
definitions. Sometimes upper case is used for bundled structures, such
as <code>Group</code>. In that case, use CamelCase for compound names, such as
<code>AbelianGroup</code>.</p>
<p>We adopt the following naming guidelines to make it easier for users
to guess the name of a theorem or find it using tab completion. Common
&quot;axiomatic&quot; properties of an operation like conjunction or
disjunction are put in a namespace that begins with the name of the
operation:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">logic.basic</span>

<span class="k">#check</span> <span class="n">and.comm</span>
<span class="k">#check</span> <span class="n">or.comm</span>
<span class="k">#check</span> <span class="n">and.assoc</span>
<span class="k">#check</span> <span class="n">or.assoc</span>
</code></pre></div>

<p>In particular, this includes <code>intro</code> and <code>elim</code> operations for logical
connectives, and properties of relations:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">logic.basic</span>

<span class="k">#check</span> <span class="n">and.intro</span>
<span class="k">#check</span> <span class="n">and.elim</span>
<span class="k">#check</span> <span class="n">or.intro_left</span>
<span class="k">#check</span> <span class="n">or.intro_right</span>
<span class="k">#check</span> <span class="n">or.elim</span>

<span class="k">#check</span> <span class="n">eq.refl</span>
<span class="k">#check</span> <span class="n">eq.symm</span>
<span class="k">#check</span> <span class="n">eq.trans</span>
</code></pre></div>

<p>Note however we do not do this for axiomatic arithmetic operations</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.basic</span>

<span class="k">#check</span> <span class="n">mul_comm</span>
<span class="k">#check</span> <span class="n">mul_assoc</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">mul_left_cancel</span>  <span class="c1">-- multiplication is left cancelative</span>
</code></pre></div>

<p>For the most part, however, we rely on descriptive names. Often the
name of theorem simply describes the conclusion:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.ring.basic</span>
<span class="kn">open</span> <span class="n">nat</span>
<span class="k">#check</span> <span class="n">succ_ne_zero</span>
<span class="k">#check</span> <span class="n">mul_zero</span>
<span class="k">#check</span> <span class="n">mul_one</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">sub_add_eq_add_sub</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">le_iff_lt_or_eq</span>
</code></pre></div>

<p>If only a prefix of the description is enough to convey the meaning,
the name may be made even shorter:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.ordered_ring</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">neg_neg</span>
<span class="k">#check</span> <span class="n">nat.pred_succ</span>
</code></pre></div>

<p>When an operation is written as infix, the theorem names follow
suit. For example, we write <code>neg_mul_neg</code> rather than <code>mul_neg_neg</code> to
describe the patter <code>-a * -b</code>.</p>
<p>Sometimes, to disambiguate the name of theorem or better convey the
intended reference, it is necessary to describe some of the
hypotheses. The word &quot;of&quot; is used to separate these hypotheses:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.ordered_ring</span>
<span class="kn">open</span> <span class="n">nat</span>
<span class="k">#check</span> <span class="n">lt_of_succ_le</span>
<span class="k">#check</span> <span class="n">lt_of_not_ge</span>
<span class="k">#check</span> <span class="n">lt_of_le_of_ne</span>
<span class="k">#check</span> <span class="n">add_lt_add_of_lt_of_le</span>
</code></pre></div>

<p>The hypotheses are listed in the order they appear, <em>not</em> reverse
order. For example, the theorem <code>A ‚Üí B ‚Üí C</code> would be named
<code>C_of_A_of_B</code>.</p>
<p>Sometimes abbreviations or alternative descriptions are easier to work
with. For example, we use <code>pos</code>, <code>neg</code>, <code>nonpos</code>, <code>nonneg</code> rather than
<code>zero_lt</code>, <code>lt_zero</code>, <code>le_zero</code>, and <code>zero_le</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.ordered_ring</span>
<span class="kn">open</span> <span class="n">nat</span>
<span class="k">#check</span> <span class="n">mul_pos</span>
<span class="k">#check</span> <span class="n">mul_nonpos_of_nonneg_of_nonpos</span>
<span class="k">#check</span> <span class="n">add_lt_of_lt_of_nonpos</span>
<span class="k">#check</span> <span class="n">add_lt_of_nonpos_of_lt</span>
</code></pre></div>

<p>These conventions are not perfect. They cannot distinguish compound
expressions up to associativity, or repeated occurrences in a
pattern. For that, we make do as best we can. For example, <code>a + b - b = a</code>
could be named either <code>add_sub_self</code> or <code>add_sub_cancel</code>.</p>
<p>Sometimes the word &quot;left&quot; or &quot;right&quot; is helpful to describe variants
of a theorem.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.ordered_ring</span>

<span class="k">#check</span> <span class="n">add_le_add_left</span>
<span class="k">#check</span> <span class="n">add_le_add_right</span>
<span class="k">#check</span> <span class="n">le_of_mul_le_mul_left</span>
<span class="k">#check</span> <span class="n">le_of_mul_le_mul_right</span>
</code></pre></div>

<h2 id="naming-of-structural-lemmas" class="markdown-heading">Naming of structural lemmas <a class="hover-link" href="#naming-of-structural-lemmas">#</a></h2>
<p>We are trying to standardize certain naming patterns for structural lemmas.
At present these are not uniform across mathlib.</p>
<h3 id="extensionality" class="markdown-heading">Extensionality <a class="hover-link" href="#extensionality">#</a></h3>
<p>A lemma of the form <code>(‚àÄ x, f x = g x) ‚Üí f = g</code> should be named <code>.ext</code>,
and labelled with the <code>@[ext]</code> attribute.
Often this type of lemma can be generated automatically by putting the
<code>@[ext]</code> attribute on a structure.
(However an automatically generated lemma will always be written in terms
of the structure projections, and often there is a better statement,
e.g. using coercions, that should be written by hand then marked with <code>@[ext]</code>.)</p>
<p>A lemma of the form <code>f = g ‚Üî ‚àÄ x, f x = g x</code> should be named <code>.ext_iff</code>.</p>
<h3 id="injectivity" class="markdown-heading">Injectivity <a class="hover-link" href="#injectivity">#</a></h3>
<p>Where possible, injectivity lemmas should be written in terms of an
<code>injective f</code> conclusion which use the full word <code>injective</code>, typically as <code>f_injective</code>.
The form <code>injective_f</code> still appears often in mathlib.</p>
<p>In addition to these, a variant should usually be provided as a bidirectional implication,
e.g. as <code>f x = f y ‚Üî x = y</code>, which can be obtained from <code>function.injective.eq_iff</code>.
Such lemmas should be named <code>f_inj</code>
(although if they are in an appropriate namespace <code>.inj</code> is good too).
Bidirectional injectivity lemmas are often good candidates for <code>@[simp]</code>.
There are still many unidirectional implications named <code>inj</code> in mathlib,
and it is reasonable to update and replace these as you come across them.</p>
<p>Note however that constructors for inductive types have
automatically generated unidirectional implications, named <code>.inj</code>,
and there is no intention to change this.
When such an automatically generated lemma already exists,
and a bidirectional lemma is needed, it may be named <code>.inj_iff</code>.</p>
<hr />
<p>Copyright (c) 2016 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Avigad</p>

  </main>

    <nav id="navbar" class="d-md-block bg-light sidebar collapse navbar-light pb-4">
      <div class="d-none d-md-block mt-4"><a class="navbar-brand" href="https://leanprover-community.github.io/index.html">Lean Community</a></div>
      
        <h6 class="sidebar-heading mt-4">Community</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover.zulipchat.com/">Zulip chat</a></li>
        
          <li class="nav-item col-12"><a href="https://github.com/leanprover-community/mathlib">GitHub</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/blog">Blog</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/meet.html">Community information</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/papers.html">Papers about Lean</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/lean_projects.html">Projects using Lean</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Installation</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/get_started.html">Get started</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/install/debian.html">Debian/Ubuntu installation</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/install/linux.html">Generic Linux installation</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/install/macos.html">MacOS installation</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/install/windows.html">Windows installation</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/lean-web-editor">Online version (no installation)</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/leanproject.html">Using leanproject</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/toolchain.html">The Lean toolchain</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Documentation</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/learn.html">Learning resources (start here)</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mathlib_docs">API documentation</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/extras/calc.html">Calc mode</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/extras/conv.html">Conv mode</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/extras/simp.html">Simplifier</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/extras/tactic_writing.html">Tactic writing tutorial</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/extras/well_founded_recursion.html">Well-founded recursion</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mwe.html">About MWEs</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/glossary.html">Glossary</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/tips_and_tricks.html">Tips and tricks</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Library overviews</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mathlib-overview.html">Library overview</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/undergrad.html">Undergraduate maths</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/100.html">Wiedijk's 100 theorems</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Theory docs</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/category_theory.html">Category theory</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/linear_algebra.html">Linear algebra</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/naturals.html">Natural numbers</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/sets.html">Sets and set-like objects</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/theories/topology.html">Topology</a></li>
        </ul>
      
        <h6 class="sidebar-heading mt-4">Contributing</h6>
        <ul class="nav">
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/index.html">Pull request lifecycle</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/naming.html">Naming conventions</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/style.html">Code style guideline</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/contribute/doc.html">Documentation style</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/ci.html">CI for 3rd party projects</a></li>
        
          <li class="nav-item col-12"><a href="https://leanprover-community.github.io/mathlib_stats.html">Contribution statistics</a></li>
        </ul>
      
    </nav>

</div>


  <nav class="footer navbar navbar-expand-lg navbar-light bg-light justify-content-end">
  <ul class="nav">
    <li class="nav-item">
      <a class="nav-link active" href="https://github.com/leanprover-community/leanprover-community.github.io/blob/newsite/templates/contribute/naming.md">Suggest edits to this page on GitHub</a>
    </li>
  </ul>
  </nav>

    <script src="https://code.jquery.com/jquery-3.5.1.min.js"
      integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
      crossorigin="anonymous"></script>
    <script src="https://leanprover-community.github.io//js/bootstrap.min.js"></script>
    
  </body>
</html>